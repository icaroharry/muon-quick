(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (Buffer){
'use strict';


var path = _dereq_('path');
var pump = _dereq_('pump');
var LocalMessageDuplexStream = _dereq_('post-message-stream');
var PongStream = _dereq_('ping-pong-stream/pong');
var ObjectMultiplex = _dereq_('obj-multiplex');
var extension = _dereq_('extensionizer');
var PortStream = _dereq_('./lib/port-stream.js');

var inpageContent = Buffer("KGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT0iZnVuY3Rpb24iJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKCJDYW5ub3QgZmluZCBtb2R1bGUgJyIrbysiJyIpO3Rocm93IGYuY29kZT0iTU9EVUxFX05PVF9GT1VORCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT0iZnVuY3Rpb24iJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsKXsKJ3VzZSBzdHJpY3QnOwoKLypnbG9iYWwgV2ViMyovCmNsZWFuQ29udGV4dEZvckltcG9ydHMoKTsKX2RlcmVxXygnd2ViMy9kaXN0L3dlYjMubWluLmpzJyk7CnZhciBsb2cgPSBfZGVyZXFfKCdsb2dsZXZlbCcpOwp2YXIgTG9jYWxNZXNzYWdlRHVwbGV4U3RyZWFtID0gX2RlcmVxXygncG9zdC1tZXNzYWdlLXN0cmVhbScpOwovLyBjb25zdCBQaW5nU3RyZWFtID0gcmVxdWlyZSgncGluZy1wb25nLXN0cmVhbS9waW5nJykKLy8gY29uc3QgZW5kT2ZTdHJlYW0gPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJykKdmFyIHNldHVwRGFwcEF1dG9SZWxvYWQgPSBfZGVyZXFfKCcuL2xpYi9hdXRvLXJlbG9hZC5qcycpOwp2YXIgTWV0YW1hc2tJbnBhZ2VQcm92aWRlciA9IF9kZXJlcV8oJy4vbGliL2lucGFnZS1wcm92aWRlci5qcycpOwpyZXN0b3JlQ29udGV4dEFmdGVySW1wb3J0cygpOwoKdmFyIE1FVEFNQVNLX0RFQlVHID0gdW5kZWZpbmVkOwp3aW5kb3cubG9nID0gbG9nOwpsb2cuc2V0RGVmYXVsdExldmVsKE1FVEFNQVNLX0RFQlVHID8gJ2RlYnVnJyA6ICd3YXJuJyk7CgovLwovLyBzZXR1cCBwbHVnaW4gY29tbXVuaWNhdGlvbgovLwoKLy8gc2V0dXAgYmFja2dyb3VuZCBjb25uZWN0aW9uCnZhciBtZXRhbWFza1N0cmVhbSA9IG5ldyBMb2NhbE1lc3NhZ2VEdXBsZXhTdHJlYW0oewogIG5hbWU6ICdpbnBhZ2UnLAogIHRhcmdldDogJ2NvbnRlbnRzY3JpcHQnCn0pOwoKLy8gY29tcG9zZSB0aGUgaW5wYWdlIHByb3ZpZGVyCnZhciBpbnBhZ2VQcm92aWRlciA9IG5ldyBNZXRhbWFza0lucGFnZVByb3ZpZGVyKG1ldGFtYXNrU3RyZWFtKTsKCi8vCi8vIHNldHVwIHdlYjMKLy8KCmlmICh0eXBlb2Ygd2luZG93LndlYjMgIT09ICd1bmRlZmluZWQnKSB7CiAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBkZXRlY3RlZCBhbm90aGVyIHdlYjMuXG4gICAgIE1ldGFNYXNrIHdpbGwgbm90IHdvcmsgcmVsaWFibHkgd2l0aCBhbm90aGVyIHdlYjMgZXh0ZW5zaW9uLlxuICAgICBUaGlzIHVzdWFsbHkgaGFwcGVucyBpZiB5b3UgaGF2ZSB0d28gTWV0YU1hc2tzIGluc3RhbGxlZCxcbiAgICAgb3IgTWV0YU1hc2sgYW5kIGFub3RoZXIgd2ViMyBleHRlbnNpb24uIFBsZWFzZSByZW1vdmUgb25lXG4gICAgIGFuZCB0cnkgYWdhaW4uJyk7Cn0KdmFyIHdlYjMgPSBuZXcgV2ViMyhpbnBhZ2VQcm92aWRlcik7CndlYjMuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7CiAgbG9nLmRlYnVnKCdNZXRhTWFzayAtIG92ZXJyb2RlIHdlYjMuc2V0UHJvdmlkZXInKTsKfTsKbG9nLmRlYnVnKCdNZXRhTWFzayAtIGluamVjdGVkIHdlYjMnKTsKLy8gZXhwb3J0IGdsb2JhbCB3ZWIzLCB3aXRoIHVzYWdlLWRldGVjdGlvbgpzZXR1cERhcHBBdXRvUmVsb2FkKHdlYjMsIGlucGFnZVByb3ZpZGVyLnB1YmxpY0NvbmZpZ1N0b3JlKTsKCi8vIHNldCB3ZWIzIGRlZmF1bHRBY2NvdW50CgppbnBhZ2VQcm92aWRlci5wdWJsaWNDb25maWdTdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0YXRlKSB7CiAgd2ViMy5ldGguZGVmYXVsdEFjY291bnQgPSBzdGF0ZS5zZWxlY3RlZEFkZHJlc3M7Cn0pOwoKLy8KLy8gdXRpbAovLwoKLy8gbmVlZCB0byBtYWtlIHN1cmUgd2UgYXJlbid0IGFmZmVjdGVkIGJ5IG92ZXJsYXBwaW5nIG5hbWVzcGFjZXMKLy8gYW5kIHRoYXQgd2UgZG9udCBhZmZlY3QgdGhlIGFwcCB3aXRoIG91ciBuYW1lc3BhY2UKLy8gbW9zdGx5IGEgZml4IGZvciB3ZWIzJ3MgQmlnTnVtYmVyIGlmIEFNRCdzICJkZWZpbmUiIGlzIGRlZmluZWQuLi4KdmFyIF9fZGVmaW5lOwoKZnVuY3Rpb24gY2xlYW5Db250ZXh0Rm9ySW1wb3J0cygpIHsKICBfX2RlZmluZSA9IGdsb2JhbC5kZWZpbmU7CiAgdHJ5IHsKICAgIGdsb2JhbC5kZWZpbmUgPSB1bmRlZmluZWQ7CiAgfSBjYXRjaCAoXykgewogICAgY29uc29sZS53YXJuKCdNZXRhTWFzayAtIGdsb2JhbC5kZWZpbmUgY291bGQgbm90IGJlIGRlbGV0ZWQuJyk7CiAgfQp9CgpmdW5jdGlvbiByZXN0b3JlQ29udGV4dEFmdGVySW1wb3J0cygpIHsKICB0cnkgewogICAgZ2xvYmFsLmRlZmluZSA9IF9fZGVmaW5lOwogIH0gY2F0Y2ggKF8pIHsKICAgIGNvbnNvbGUud2FybignTWV0YU1hc2sgLSBnbG9iYWwuZGVmaW5lIGNvdWxkIG5vdCBiZSBvdmVyd3JpdHRlbi4nKTsKICB9Cn0KCn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHsiLi9saWIvYXV0by1yZWxvYWQuanMiOjIsIi4vbGliL2lucGFnZS1wcm92aWRlci5qcyI6MywibG9nbGV2ZWwiOjExMSwicG9zdC1tZXNzYWdlLXN0cmVhbSI6MTE2LCJ3ZWIzL2Rpc3Qvd2ViMy5taW4uanMiOjEzOX1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKGdsb2JhbCl7Cid1c2Ugc3RyaWN0JzsKCm1vZHVsZS5leHBvcnRzID0gc2V0dXBEYXBwQXV0b1JlbG9hZDsKCmZ1bmN0aW9uIHNldHVwRGFwcEF1dG9SZWxvYWQod2ViMywgb2JzZXJ2YWJsZSkgewogIC8vIGV4cG9ydCB3ZWIzIGFzIGEgZ2xvYmFsLCBjaGVja2luZyBmb3IgdXNhZ2UKICB2YXIgaGFzQmVlbldhcm5lZCA9IGZhbHNlOwogIHZhciByZWxvYWRJblByb2dyZXNzID0gZmFsc2U7CiAgdmFyIGxhc3RUaW1lVXNlZCA9IHZvaWQgMDsKICB2YXIgbGFzdFNlZW5OZXR3b3JrID0gdm9pZCAwOwoKICBnbG9iYWwud2ViMyA9IG5ldyBQcm94eSh3ZWIzLCB7CiAgICBnZXQ6IGZ1bmN0aW9uIGdldChfd2ViMywga2V5KSB7CiAgICAgIC8vIHNob3cgd2FybmluZyBvbmNlIG9uIHdlYjMgYWNjZXNzCiAgICAgIGlmICghaGFzQmVlbldhcm5lZCAmJiBrZXkgIT09ICdjdXJyZW50UHJvdmlkZXInKSB7CiAgICAgICAgY29uc29sZS53YXJuKCdNZXRhTWFzazogd2ViMyB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIG5lYXIgZnV0dXJlIGluIGZhdm9yIG9mIHRoZSBldGhlcmV1bVByb3ZpZGVyIFxuaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2ZhcS9ibG9iL21hc3Rlci9kZXRlY3RpbmdfbWV0YW1hc2subWQjd2ViMy1kZXByZWNhdGlvbicpOwogICAgICAgIGhhc0JlZW5XYXJuZWQgPSB0cnVlOwogICAgICB9CiAgICAgIC8vIGdldCB0aGUgdGltZSBvZiB1c2UKICAgICAgbGFzdFRpbWVVc2VkID0gRGF0ZS5ub3coKTsKICAgICAgLy8gcmV0dXJuIHZhbHVlIG5vcm1hbGx5CiAgICAgIHJldHVybiBfd2ViM1trZXldOwogICAgfSwKICAgIHNldDogZnVuY3Rpb24gc2V0KF93ZWIzLCBrZXksIHZhbHVlKSB7CiAgICAgIC8vIHNldCB2YWx1ZSBub3JtYWxseQogICAgICBfd2ViM1trZXldID0gdmFsdWU7CiAgICB9CiAgfSk7CgogIG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkgewogICAgLy8gaWYgcmVsb2FkIGluIHByb2dyZXNzLCBubyBuZWVkIHRvIGNoZWNrIHJlbG9hZCBsb2dpYwogICAgaWYgKHJlbG9hZEluUHJvZ3Jlc3MpIHJldHVybjsKCiAgICB2YXIgY3VycmVudE5ldHdvcmsgPSBzdGF0ZS5uZXR3b3JrVmVyc2lvbjsKCiAgICAvLyBzZXQgdGhlIGluaXRpYWwgbmV0d29yawogICAgaWYgKCFsYXN0U2Vlbk5ldHdvcmspIHsKICAgICAgbGFzdFNlZW5OZXR3b3JrID0gY3VycmVudE5ldHdvcms7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBza2lwIHJlbG9hZCBsb2dpYyBpZiB3ZWIzIG5vdCB1c2VkCiAgICBpZiAoIWxhc3RUaW1lVXNlZCkgcmV0dXJuOwoKICAgIC8vIGlmIG5ldHdvcmsgZGlkIG5vdCBjaGFuZ2UsIGV4aXQKICAgIGlmIChjdXJyZW50TmV0d29yayA9PT0gbGFzdFNlZW5OZXR3b3JrKSByZXR1cm47CgogICAgLy8gaW5pdGlhdGUgcGFnZSByZWxvYWQKICAgIHJlbG9hZEluUHJvZ3Jlc3MgPSB0cnVlOwogICAgdmFyIHRpbWVTaW5jZVVzZSA9IERhdGUubm93KCkgLSBsYXN0VGltZVVzZWQ7CiAgICAvLyBpZiB3ZWIzIHdhcyByZWNlbnRseSB1c2VkIHRoZW4gZGVsYXkgdGhlIHJlbG9hZGluZyBvZiB0aGUgcGFnZQogICAgaWYgKHRpbWVTaW5jZVVzZSA+IDUwMCkgewogICAgICB0cmlnZ2VyUmVzZXQoKTsKICAgIH0gZWxzZSB7CiAgICAgIHNldFRpbWVvdXQodHJpZ2dlclJlc2V0LCA1MDApOwogICAgfQogIH0pOwp9CgovLyByZWxvYWQgdGhlIHBhZ2UKZnVuY3Rpb24gdHJpZ2dlclJlc2V0KCkgewogIGdsb2JhbC5sb2NhdGlvbi5yZWxvYWQoKTsKfQoKfSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Cgp2YXIgcHVtcCA9IF9kZXJlcV8oJ3B1bXAnKTsKdmFyIFJwY0VuZ2luZSA9IF9kZXJlcV8oJ2pzb24tcnBjLWVuZ2luZScpOwp2YXIgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUgPSBfZGVyZXFfKCdqc29uLXJwYy1lbmdpbmUvc3JjL2lkUmVtYXBNaWRkbGV3YXJlJyk7CnZhciBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlID0gX2RlcmVxXygnanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0nKTsKdmFyIExvY2FsU3RvcmFnZVN0b3JlID0gX2RlcmVxXygnb2JzLXN0b3JlJyk7CnZhciBhc1N0cmVhbSA9IF9kZXJlcV8oJ29icy1zdG9yZS9saWIvYXNTdHJlYW0nKTsKdmFyIE9iamVjdE11bHRpcGxleCA9IF9kZXJlcV8oJ29iai1tdWx0aXBsZXgnKTsKCm1vZHVsZS5leHBvcnRzID0gTWV0YW1hc2tJbnBhZ2VQcm92aWRlcjsKCmZ1bmN0aW9uIE1ldGFtYXNrSW5wYWdlUHJvdmlkZXIoY29ubmVjdGlvblN0cmVhbSkgewogIHZhciBzZWxmID0gdGhpczsKCiAgLy8gc2V0dXAgY29ubmVjdGlvblN0cmVhbSBtdWx0aXBsZXhpbmcKICB2YXIgbXV4ID0gc2VsZi5tdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7CiAgcHVtcChjb25uZWN0aW9uU3RyZWFtLCBtdXgsIGNvbm5lY3Rpb25TdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHsKICAgIHJldHVybiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZygnTWV0YU1hc2snLCBlcnIpOwogIH0pOwoKICAvLyBzdWJzY3JpYmUgdG8gbWV0YW1hc2sgcHVibGljIGNvbmZpZyAob25lLXdheSkKICBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlID0gbmV3IExvY2FsU3RvcmFnZVN0b3JlKHsgc3RvcmFnZUtleTogJ01ldGFNYXNrLUNvbmZpZycgfSk7CgogIHB1bXAobXV4LmNyZWF0ZVN0cmVhbSgncHVibGljQ29uZmlnJyksIGFzU3RyZWFtKHNlbGYucHVibGljQ29uZmlnU3RvcmUpLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFB1YmxpY0NvbmZpZ1N0b3JlJywgZXJyKTsKICB9KTsKCiAgLy8gaWdub3JlIHBoaXNoaW5nIHdhcm5pbmcgbWVzc2FnZSAoaGFuZGxlZCBlbHNld2hlcmUpCiAgbXV4Lmlnbm9yZVN0cmVhbSgncGhpc2hpbmcnKTsKCiAgLy8gY29ubmVjdCB0byBhc3luYyBwcm92aWRlcgogIHZhciBzdHJlYW1NaWRkbGV3YXJlID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpOwogIHB1bXAoc3RyZWFtTWlkZGxld2FyZS5zdHJlYW0sIG11eC5jcmVhdGVTdHJlYW0oJ3Byb3ZpZGVyJyksIHN0cmVhbU1pZGRsZXdhcmUuc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFJwY1Byb3ZpZGVyJywgZXJyKTsKICB9KTsKCiAgLy8gaGFuZGxlIHNlbmRBc3luYyByZXF1ZXN0cyB2aWEgZGFwcC1zaWRlIHJwYyBlbmdpbmUKICB2YXIgcnBjRW5naW5lID0gbmV3IFJwY0VuZ2luZSgpOwogIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkpOwogIHJwY0VuZ2luZS5wdXNoKHN0cmVhbU1pZGRsZXdhcmUpOwogIHNlbGYucnBjRW5naW5lID0gcnBjRW5naW5lOwp9CgovLyBoYW5kbGUgc2VuZEFzeW5jIHJlcXVlc3RzIHZpYSBhc3luY1Byb3ZpZGVyCi8vIGFsc28gcmVtYXAgaWRzIGluYm91bmQgYW5kIG91dGJvdW5kCk1ldGFtYXNrSW5wYWdlUHJvdmlkZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYikgewogIHZhciBzZWxmID0gdGhpczsKICBzZWxmLnJwY0VuZ2luZS5oYW5kbGUocGF5bG9hZCwgY2IpOwp9OwoKTWV0YW1hc2tJbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7CiAgdmFyIHNlbGYgPSB0aGlzOwoKICB2YXIgc2VsZWN0ZWRBZGRyZXNzID0gdm9pZCAwOwogIHZhciByZXN1bHQgPSBudWxsOwogIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHsKCiAgICBjYXNlICdldGhfYWNjb3VudHMnOgogICAgICAvLyByZWFkIGZyb20gbG9jYWxTdG9yYWdlCiAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IHNlbGYucHVibGljQ29uZmlnU3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7CiAgICAgIHJlc3VsdCA9IHNlbGVjdGVkQWRkcmVzcyA/IFtzZWxlY3RlZEFkZHJlc3NdIDogW107CiAgICAgIGJyZWFrOwoKICAgIGNhc2UgJ2V0aF9jb2luYmFzZSc6CiAgICAgIC8vIHJlYWQgZnJvbSBsb2NhbFN0b3JhZ2UKICAgICAgc2VsZWN0ZWRBZGRyZXNzID0gc2VsZi5wdWJsaWNDb25maWdTdG9yZS5nZXRTdGF0ZSgpLnNlbGVjdGVkQWRkcmVzczsKICAgICAgcmVzdWx0ID0gc2VsZWN0ZWRBZGRyZXNzIHx8IG51bGw7CiAgICAgIGJyZWFrOwoKICAgIGNhc2UgJ2V0aF91bmluc3RhbGxGaWx0ZXInOgogICAgICBzZWxmLnNlbmRBc3luYyhwYXlsb2FkLCBub29wKTsKICAgICAgcmVzdWx0ID0gdHJ1ZTsKICAgICAgYnJlYWs7CgogICAgY2FzZSAnbmV0X3ZlcnNpb24nOgogICAgICB2YXIgbmV0d29ya1ZlcnNpb24gPSBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlLmdldFN0YXRlKCkubmV0d29ya1ZlcnNpb247CiAgICAgIHJlc3VsdCA9IG5ldHdvcmtWZXJzaW9uIHx8IG51bGw7CiAgICAgIGJyZWFrOwoKICAgIC8vIHRocm93IG5vdC1zdXBwb3J0ZWQgRXJyb3IKICAgIGRlZmF1bHQ6CiAgICAgIHZhciBsaW5rID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9mYXEvYmxvYi9tYXN0ZXIvREVWRUxPUEVSUy5tZCNkaXp6eS1hbGwtYXN5bmMtLS10aGluay1vZi1tZXRhbWFzay1hcy1hLWxpZ2h0LWNsaWVudCc7CiAgICAgIHZhciBtZXNzYWdlID0gJ1RoZSBNZXRhTWFzayBXZWIzIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IHN5bmNocm9ub3VzIG1ldGhvZHMgbGlrZSAnICsgcGF5bG9hZC5tZXRob2QgKyAnIHdpdGhvdXQgYSBjYWxsYmFjayBwYXJhbWV0ZXIuIFNlZSAnICsgbGluayArICcgZm9yIGRldGFpbHMuJzsKICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOwoKICB9CgogIC8vIHJldHVybiB0aGUgcmVzdWx0CiAgcmV0dXJuIHsKICAgIGlkOiBwYXlsb2FkLmlkLAogICAganNvbnJwYzogcGF5bG9hZC5qc29ucnBjLAogICAgcmVzdWx0OiByZXN1bHQKICB9Owp9OwoKTWV0YW1hc2tJbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIHRydWU7Cn07CgpNZXRhbWFza0lucGFnZVByb3ZpZGVyLnByb3RvdHlwZS5pc01ldGFNYXNrID0gdHJ1ZTsKCi8vIHV0aWwKCmZ1bmN0aW9uIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nKHJlbW90ZUxhYmVsLCBlcnIpIHsKICB2YXIgd2FybmluZ01zZyA9ICdNZXRhbWFza0lucGFnZVByb3ZpZGVyIC0gbG9zdCBjb25uZWN0aW9uIHRvICcgKyByZW1vdGVMYWJlbDsKICBpZiAoZXJyKSB3YXJuaW5nTXNnICs9ICdcbicgKyBlcnIuc3RhY2s7CiAgY29uc29sZS53YXJuKHdhcm5pbmdNc2cpOwp9CgpmdW5jdGlvbiBub29wKCkge30KCn0seyJqc29uLXJwYy1lbmdpbmUiOjEwNywianNvbi1ycGMtZW5naW5lL3NyYy9pZFJlbWFwTWlkZGxld2FyZSI6MTA2LCJqc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbSI6MTEwLCJvYmotbXVsdGlwbGV4IjoxMTIsIm9icy1zdG9yZSI6MTEzLCJvYnMtc3RvcmUvbGliL2FzU3RyZWFtIjoxMTQsInB1bXAiOjExOH1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXsKKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHsKICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDoKICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDoKICAoZmFjdG9yeSgoZ2xvYmFsLmFzeW5jID0gZ2xvYmFsLmFzeW5jIHx8IHt9KSkpOwp9KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7CgpmdW5jdGlvbiBzbGljZShhcnJheUxpa2UsIHN0YXJ0KSB7CiAgICBzdGFydCA9IHN0YXJ0fDA7CiAgICB2YXIgbmV3TGVuID0gTWF0aC5tYXgoYXJyYXlMaWtlLmxlbmd0aCAtIHN0YXJ0LCAwKTsKICAgIHZhciBuZXdBcnIgPSBBcnJheShuZXdMZW4pOwogICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCBuZXdMZW47IGlkeCsrKSAgewogICAgICAgIG5ld0FycltpZHhdID0gYXJyYXlMaWtlW3N0YXJ0ICsgaWR4XTsKICAgIH0KICAgIHJldHVybiBuZXdBcnI7Cn0KCnZhciBpbml0aWFsUGFyYW1zID0gZnVuY3Rpb24gKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uYXJncywgY2FsbGJhY2sqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTsKICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpOwogICAgICAgIGZuLmNhbGwodGhpcywgYXJncywgY2FsbGJhY2spOwogICAgfTsKfTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUKICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKQogKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDAuMS4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc09iamVjdCh7fSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc09iamVjdChbMSwgMiwgM10pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNPYmplY3QoXy5ub29wKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzT2JqZWN0KG51bGwpOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTsKICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpOwp9Cgp2YXIgaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7CnZhciBoYXNOZXh0VGljayA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJzsKCmZ1bmN0aW9uIGZhbGxiYWNrKGZuKSB7CiAgICBzZXRUaW1lb3V0KGZuLCAwKTsKfQoKZnVuY3Rpb24gd3JhcChkZWZlcikgewogICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgZGVmZXIoZnVuY3Rpb24gKCkgewogICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTsKICAgICAgICB9KTsKICAgIH07Cn0KCnZhciBfZGVmZXI7CgppZiAoaGFzU2V0SW1tZWRpYXRlKSB7CiAgICBfZGVmZXIgPSBzZXRJbW1lZGlhdGU7Cn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHsKICAgIF9kZWZlciA9IHByb2Nlc3MubmV4dFRpY2s7Cn0gZWxzZSB7CiAgICBfZGVmZXIgPSBmYWxsYmFjazsKfQoKdmFyIHNldEltbWVkaWF0ZSQxID0gd3JhcChfZGVmZXIpOwoKLyoqCiAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYQogKiBjYWxsYmFjay4gVGhpcyBpcyB1c2VmdWwgZm9yIHBsdWdnaW5nIHN5bmMgZnVuY3Rpb25zIGludG8gYSB3YXRlcmZhbGwsCiAqIHNlcmllcywgb3Igb3RoZXIgYXN5bmMgZnVuY3Rpb25zLiBBbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZ2VuZXJhdGVkCiAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbAogKiBjYWxsYmFjayBhcmd1bWVudCkuIEVycm9ycyB0aHJvd24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLgogKgogKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMncwogKiByZXNvbHZlZC9yZWplY3RlZCBzdGF0ZSB3aWxsIGJlIHVzZWQgdG8gY2FsbCB0aGUgY2FsbGJhY2ssIHJhdGhlciB0aGFuIHNpbXBseQogKiB0aGUgc3luY2hyb25vdXMgcmV0dXJuIHZhbHVlLgogKgogKiBUaGlzIGFsc28gbWVhbnMgeW91IGNhbiBhc3luY2lmeSBFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbnMuCiAqCiAqIEBuYW1lIGFzeW5jaWZ5CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBhbGlhcyB3cmFwU3luYwogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZwogKiBmdW5jdGlvbiB0byBjb252ZXJ0IHRvIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufS4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IEFuIGFzeW5jaHJvbm91cyB3cmFwcGVyIG9mIHRoZSBgZnVuY2AuIFRvIGJlCiAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuCiAqIEBleGFtcGxlCiAqCiAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsICJ1dGY4IiksCiAqICAgICBhc3luYy5hc3luY2lmeShKU09OLnBhcnNlKSwKICogICAgIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7CiAqICAgICAgICAgLy8gZGF0YSBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIHRleHQuCiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGFyc2luZyBlcnJvciwgaXQgd291bGQgaGF2ZSBiZWVuIGNhdWdodC4KICogICAgIH0KICogXSwgY2FsbGJhY2spOwogKgogKiAvLyBwYXNzaW5nIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZQogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCAidXRmOCIpLAogKiAgICAgYXN5bmMuYXN5bmNpZnkoZnVuY3Rpb24gKGNvbnRlbnRzKSB7CiAqICAgICAgICAgcmV0dXJuIGRiLm1vZGVsLmNyZWF0ZShjb250ZW50cyk7CiAqICAgICB9KSwKICogICAgIGZ1bmN0aW9uIChtb2RlbCwgbmV4dCkgewogKiAgICAgICAgIC8vIGBtb2RlbGAgaXMgdGhlIGluc3RhbnRpYXRlZCBtb2RlbCBvYmplY3QuCiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yLCB0aGlzIGZ1bmN0aW9uIHdvdWxkIGJlIHNraXBwZWQuCiAqICAgICB9CiAqIF0sIGNhbGxiYWNrKTsKICoKICogLy8gZXMyMDE3IGV4YW1wbGUsIHRob3VnaCBgYXN5bmNpZnlgIGlzIG5vdCBuZWVkZWQgaWYgeW91ciBKUyBlbnZpcm9ubWVudAogKiAvLyBzdXBwb3J0cyBhc3luYyBmdW5jdGlvbnMgb3V0IG9mIHRoZSBib3gKICogdmFyIHEgPSBhc3luYy5xdWV1ZShhc3luYy5hc3luY2lmeShhc3luYyBmdW5jdGlvbihmaWxlKSB7CiAqICAgICB2YXIgaW50ZXJtZWRpYXRlU3RlcCA9IGF3YWl0IHByb2Nlc3NGaWxlKGZpbGUpOwogKiAgICAgcmV0dXJuIGF3YWl0IHNvbWVQcm9taXNlKGludGVybWVkaWF0ZVN0ZXApCiAqIH0pKTsKICoKICogcS5wdXNoKGZpbGVzKTsKICovCmZ1bmN0aW9uIGFzeW5jaWZ5KGZ1bmMpIHsKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIHZhciByZXN1bHQ7CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgICAgICB9CiAgICAgICAgLy8gaWYgcmVzdWx0IGlzIFByb21pc2Ugb2JqZWN0CiAgICAgICAgaWYgKGlzT2JqZWN0KHJlc3VsdCkgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgbnVsbCwgdmFsdWUpOwogICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIubWVzc2FnZSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTsKICAgICAgICB9CiAgICB9KTsKfQoKZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVycm9yLCB2YWx1ZSkgewogICAgdHJ5IHsKICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpOwogICAgfSBjYXRjaCAoZSkgewogICAgICAgIHNldEltbWVkaWF0ZSQxKHJldGhyb3csIGUpOwogICAgfQp9CgpmdW5jdGlvbiByZXRocm93KGVycm9yKSB7CiAgICB0aHJvdyBlcnJvcjsKfQoKdmFyIHN1cHBvcnRzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJzsKCmZ1bmN0aW9uIGlzQXN5bmMoZm4pIHsKICAgIHJldHVybiBzdXBwb3J0c1N5bWJvbCAmJiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNGdW5jdGlvbic7Cn0KCmZ1bmN0aW9uIHdyYXBBc3luYyhhc3luY0ZuKSB7CiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/IGFzeW5jaWZ5KGFzeW5jRm4pIDogYXN5bmNGbjsKfQoKZnVuY3Rpb24gYXBwbHlFYWNoJDEoZWFjaGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oZm5zLyosIC4uLmFyZ3MqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICB2YXIgZ28gPSBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpczsKICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHsKICAgICAgICAgICAgICAgIHdyYXBBc3luYyhmbikuYXBwbHkodGhhdCwgYXJncy5jb25jYXQoY2IpKTsKICAgICAgICAgICAgfSwgY2FsbGJhY2spOwogICAgICAgIH0pOwogICAgICAgIGlmIChhcmdzLmxlbmd0aCkgewogICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICByZXR1cm4gZ287CiAgICAgICAgfQogICAgfTsKfQoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi8KdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsOwoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi8KdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CgovKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi8KdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIFN5bWJvbCQxID0gcm9vdC5TeW1ib2w7CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7CgovKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi8KdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7CgovKioKICogVXNlZCB0byByZXNvbHZlIHRoZQogKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZykKICogb2YgdmFsdWVzLgogKi8KdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIHN5bVRvU3RyaW5nVGFnJDEgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkOwoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LgogKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC4KICovCmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkgewogIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLAogICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTsKCiAgdHJ5IHsKICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdW5kZWZpbmVkOwogICAgdmFyIHVubWFza2VkID0gdHJ1ZTsKICB9IGNhdGNoIChlKSB7fQoKICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7CiAgaWYgKHVubWFza2VkKSB7CiAgICBpZiAoaXNPd24pIHsKICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB0YWc7CiAgICB9IGVsc2UgewogICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07CiAgICB9CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlOwoKLyoqCiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUKICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpCiAqIG9mIHZhbHVlcy4KICovCnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kMS50b1N0cmluZzsKCi8qKgogKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy4KICovCmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7Cn0KCi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi8KdmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXSc7CnZhciB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJzsKCi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqLwp2YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LgogKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLgogKi8KZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkgewogIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7CiAgfQogIHZhbHVlID0gT2JqZWN0KHZhbHVlKTsKICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIHZhbHVlKQogICAgPyBnZXRSYXdUYWcodmFsdWUpCiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTsKfQoKLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqLwp2YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7CnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJzsKdmFyIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7CnZhciBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAwLjEuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzRnVuY3Rpb24oXyk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0Z1bmN0aW9uKC9hYmMvKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsKICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3IKICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy4KICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7CiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZzsKfQoKLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovCnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLgogKgogKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbgogKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSA0LjAuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0xlbmd0aCgzKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpOwogKiAvLyA9PiBmYWxzZQogKgogKiBfLmlzTGVuZ3RoKEluZmluaXR5KTsKICogLy8gPT4gZmFsc2UKICoKICogXy5pc0xlbmd0aCgnMycpOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHsKICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmCiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7Cn0KCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzCiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3IKICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0FycmF5TGlrZSgnYWJjJyk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0FycmF5TGlrZShfLm5vb3ApOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHsKICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTsKfQoKLy8gQSB0ZW1wb3JhcnkgdmFsdWUgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgbG9vcCBzaG91bGQgYmUgYnJva2VuLgovLyBTZWUgIzEwNjQsICMxMjkzCnZhciBicmVha0xvb3AgPSB7fTsKCi8qKgogKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAyLjMuMAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAZXhhbXBsZQogKgogKiBfLnRpbWVzKDIsIF8ubm9vcCk7CiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF0KICovCmZ1bmN0aW9uIG5vb3AoKSB7CiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC4KfQoKZnVuY3Rpb24gb25jZShmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICBpZiAoZm4gPT09IG51bGwpIHJldHVybjsKICAgICAgICB2YXIgY2FsbEZuID0gZm47CiAgICAgICAgZm4gPSBudWxsOwogICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfTsKfQoKdmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7Cgp2YXIgZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoY29sbCkgewogICAgcmV0dXJuIGl0ZXJhdG9yU3ltYm9sICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdKCk7Cn07CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcwogKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLgogKi8KZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIHJlc3VsdCA9IEFycmF5KG4pOwoKICB3aGlsZSAoKytpbmRleCA8IG4pIHsKICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGAKICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiAib2JqZWN0Ii4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNPYmplY3RMaWtlKHt9KTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNPYmplY3RMaWtlKG51bGwpOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnOwp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LAogKi8KZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7CiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZzsKfQoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7CgovKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi8KdmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5OwoKLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovCnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvJDMucHJvcGVydHlJc0VudW1lcmFibGU7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMC4xLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwKICogIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7CiAqIC8vID0+IGZhbHNlCiAqLwp2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkgewogIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5JDIuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmCiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpOwp9OwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDAuMS4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNBcnJheSgnYWJjJyk7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNBcnJheShfLm5vb3ApOwogKiAvLyA9PiBmYWxzZQogKi8KdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OwoKLyoqCiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4xMy4wCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpOwogKiAvLyA9PiBbZmFsc2UsIGZhbHNlXQogKi8KZnVuY3Rpb24gc3R1YkZhbHNlKCkgewogIHJldHVybiBmYWxzZTsKfQoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi8KdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqLwp2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwoKLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi8KdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDsKCi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi8KdmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSA0LjMuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTsKICogLy8gPT4gZmFsc2UKICovCnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTsKCi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqLwp2YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gOTAwNzE5OTI1NDc0MDk5MTsKCi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi8KdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXGQqKSQvOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7CiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSJDEgOiBsZW5ndGg7CiAgcmV0dXJuICEhbGVuZ3RoICYmCiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJgogICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpOwp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJzsKdmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJzsKdmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7CnZhciBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nOwp2YXIgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nOwp2YXIgZnVuY1RhZyQxID0gJ1tvYmplY3QgRnVuY3Rpb25dJzsKdmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nOwp2YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7CnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJzsKdmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nOwp2YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7CnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJzsKdmFyIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7Cgp2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nOwp2YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nOwp2YXIgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOwp2YXIgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOwp2YXIgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nOwp2YXIgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XSc7CnZhciBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJzsKdmFyIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nOwp2YXIgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzsKdmFyIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XSc7CnZhciB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nOwoKLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqLwp2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTsKdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9CnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID0KdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID0KdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPQp0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTsKdHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9CnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0KdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPQp0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnJDFdID0KdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPQp0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9CnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0KdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkgewogIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmCiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldOwp9CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi4KICovCmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7CiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7CiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7CiAgfTsKfQoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi8KdmFyIGZyZWVFeHBvcnRzJDEgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovCnZhciBmcmVlTW9kdWxlJDEgPSBmcmVlRXhwb3J0cyQxICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwoKLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi8KdmFyIG1vZHVsZUV4cG9ydHMkMSA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMkMTsKCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqLwp2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzJDEgJiYgZnJlZUdsb2JhbC5wcm9jZXNzOwoKLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovCnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHsKICB0cnkgewogICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTsKICB9IGNhdGNoIChlKSB7fQp9KCkpOwoKLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi8KdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAzLjAuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc1R5cGVkQXJyYXkoW10pOwogKiAvLyA9PiBmYWxzZQogKi8KdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5OwoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7CgovKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi8KdmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQyLmhhc093blByb3BlcnR5OwoKLyoqCiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuCiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4KICovCmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkgewogIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLAogICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksCiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLAogICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSwKICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLAogICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSwKICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsKCiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7CiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwodmFsdWUsIGtleSkpICYmCiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoCiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLgogICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fAogICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLgogICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fAogICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy4KICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHwKICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuCiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aCkKICAgICAgICApKSkgewogICAgICByZXN1bHQucHVzaChrZXkpOwogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byQ1ID0gT2JqZWN0LnByb3RvdHlwZTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC4KICovCmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7CiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciwKICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG8kNTsKCiAgcmV0dXJuIHZhbHVlID09PSBwcm90bzsKfQoKLyoqCiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS4KICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uCiAqLwpmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkgewogIHJldHVybiBmdW5jdGlvbihhcmcpIHsKICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTsKICB9Owp9CgovKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovCnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTsKCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvJDQgPSBPYmplY3QucHJvdG90eXBlOwoKLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovCnZhciBoYXNPd25Qcm9wZXJ0eSQzID0gb2JqZWN0UHJvdG8kNC5oYXNPd25Qcm9wZXJ0eTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4KICovCmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkgewogIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkgewogICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTsKICB9CiAgdmFyIHJlc3VsdCA9IFtdOwogIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkgewogICAgaWYgKGhhc093blByb3BlcnR5JDMuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHsKICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqCiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLgogKgogKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZQogKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpCiAqIGZvciBtb3JlIGRldGFpbHMuCiAqCiAqIEBzdGF0aWMKICogQHNpbmNlIDAuMS4wCiAqIEBtZW1iZXJPZiBfCiAqIEBjYXRlZ29yeSBPYmplY3QKICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLgogKiBAZXhhbXBsZQogKgogKiBmdW5jdGlvbiBGb28oKSB7CiAqICAgdGhpcy5hID0gMTsKICogICB0aGlzLmIgPSAyOwogKiB9CiAqCiAqIEZvby5wcm90b3R5cGUuYyA9IDM7CiAqCiAqIF8ua2V5cyhuZXcgRm9vKTsKICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKQogKgogKiBfLmtleXMoJ2hpJyk7CiAqIC8vID0+IFsnMCcsICcxJ10KICovCmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7CiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpOwp9CgpmdW5jdGlvbiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpIHsKICAgIHZhciBpID0gLTE7CiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7CiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICByZXR1cm4gKytpIDwgbGVuID8ge3ZhbHVlOiBjb2xsW2ldLCBrZXk6IGl9IDogbnVsbDsKICAgIH0KfQoKZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHsKICAgIHZhciBpID0gLTE7CiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTsKICAgICAgICBpZiAoaXRlbS5kb25lKQogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICBpKys7CiAgICAgICAgcmV0dXJuIHt2YWx1ZTogaXRlbS52YWx1ZSwga2V5OiBpfTsKICAgIH0KfQoKZnVuY3Rpb24gY3JlYXRlT2JqZWN0SXRlcmF0b3Iob2JqKSB7CiAgICB2YXIgb2tleXMgPSBrZXlzKG9iaik7CiAgICB2YXIgaSA9IC0xOwogICAgdmFyIGxlbiA9IG9rZXlzLmxlbmd0aDsKICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkgewogICAgICAgIHZhciBrZXkgPSBva2V5c1srK2ldOwogICAgICAgIHJldHVybiBpIDwgbGVuID8ge3ZhbHVlOiBvYmpba2V5XSwga2V5OiBrZXl9IDogbnVsbDsKICAgIH07Cn0KCmZ1bmN0aW9uIGl0ZXJhdG9yKGNvbGwpIHsKICAgIGlmIChpc0FycmF5TGlrZShjb2xsKSkgewogICAgICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpOwogICAgfQoKICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGwpOwogICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7Cn0KCmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC4iKTsKICAgICAgICB2YXIgY2FsbEZuID0gZm47CiAgICAgICAgZm4gPSBudWxsOwogICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfTsKfQoKZnVuY3Rpb24gX2VhY2hPZkxpbWl0KGxpbWl0KSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgICAgIGlmIChsaW1pdCA8PSAwIHx8ICFvYmopIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgICAgIH0KICAgICAgICB2YXIgbmV4dEVsZW0gPSBpdGVyYXRvcihvYmopOwogICAgICAgIHZhciBkb25lID0gZmFsc2U7CiAgICAgICAgdmFyIHJ1bm5pbmcgPSAwOwoKICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHsKICAgICAgICAgICAgcnVubmluZyAtPSAxOwogICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IGJyZWFrTG9vcCB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7CiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiByZXBsZW5pc2ggKCkgewogICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFkb25lKSB7CiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5leHRFbGVtKCk7CiAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gbnVsbCkgewogICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTsKICAgICAgICAgICAgICAgIGl0ZXJhdGVlKGVsZW0udmFsdWUsIGVsZW0ua2V5LCBvbmx5T25jZShpdGVyYXRlZUNhbGxiYWNrKSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJlcGxlbmlzaCgpOwogICAgfTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIGVhY2hPZkxpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0KICogQGFsaWFzIGZvckVhY2hPZkxpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaAogKiBpdGVtIGluIGBjb2xsYC4gVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhbgogKiBhcnJheS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLgogKi8KZnVuY3Rpb24gZWFjaE9mTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgX2VhY2hPZkxpbWl0KGxpbWl0KShjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7Cn0KCmZ1bmN0aW9uIGRvTGltaXQoZm4sIGxpbWl0KSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgICAgICByZXR1cm4gZm4oaXRlcmFibGUsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spOwogICAgfTsKfQoKLy8gZWFjaE9mIGltcGxlbWVudGF0aW9uIG9wdGltaXplZCBmb3IgYXJyYXktbGlrZXMKZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIGluZGV4ID0gMCwKICAgICAgICBjb21wbGV0ZWQgPSAwLAogICAgICAgIGxlbmd0aCA9IGNvbGwubGVuZ3RoOwogICAgaWYgKGxlbmd0aCA9PT0gMCkgewogICAgICAgIGNhbGxiYWNrKG51bGwpOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkgewogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9IGVsc2UgaWYgKCgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoKSB8fCB2YWx1ZSA9PT0gYnJlYWtMb29wKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpOwogICAgICAgIH0KICAgIH0KCiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHsKICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsIG9ubHlPbmNlKGl0ZXJhdG9yQ2FsbGJhY2spKTsKICAgIH0KfQoKLy8gYSBnZW5lcmljIHZlcnNpb24gb2YgZWFjaE9mIHdoaWNoIGNhbiBoYW5kbGUgYXJyYXksIG9iamVjdCwgYW5kIGl0ZXJhdG9yIGNhc2VzLgp2YXIgZWFjaE9mR2VuZXJpYyA9IGRvTGltaXQoZWFjaE9mTGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBMaWtlIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSwgZXhjZXB0IHRoYXQgaXQgcGFzc2VzIHRoZSBrZXkgKG9yIGluZGV4KSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50CiAqIHRvIHRoZSBpdGVyYXRlZS4KICoKICogQG5hbWUgZWFjaE9mCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBmb3JFYWNoT2YKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9CiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaAogKiBpdGVtIGluIGBjb2xsYC4KICogVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLgogKiBAZXhhbXBsZQogKgogKiB2YXIgb2JqID0ge2RldjogIi9kZXYuanNvbiIsIHRlc3Q6ICIvdGVzdC5qc29uIiwgcHJvZDogIi9wcm9kLmpzb24ifTsKICogdmFyIGNvbmZpZ3MgPSB7fTsKICoKICogYXN5bmMuZm9yRWFjaE9mKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7CiAqICAgICBmcy5yZWFkRmlsZShfX2Rpcm5hbWUgKyB2YWx1ZSwgInV0ZjgiLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7CiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAqICAgICAgICAgdHJ5IHsKICogICAgICAgICAgICAgY29uZmlnc1trZXldID0gSlNPTi5wYXJzZShkYXRhKTsKICogICAgICAgICB9IGNhdGNoIChlKSB7CiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICogICAgICAgICB9CiAqICAgICAgICAgY2FsbGJhY2soKTsKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbiAoZXJyKSB7CiAqICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKTsKICogICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YQogKiAgICAgZG9Tb21ldGhpbmdXaXRoKGNvbmZpZ3MpOwogKiB9KTsKICovCnZhciBlYWNoT2YgPSBmdW5jdGlvbihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciBlYWNoT2ZJbXBsZW1lbnRhdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGwpID8gZWFjaE9mQXJyYXlMaWtlIDogZWFjaE9mR2VuZXJpYzsKICAgIGVhY2hPZkltcGxlbWVudGF0aW9uKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTsKfTsKCmZ1bmN0aW9uIGRvUGFyYWxsZWwoZm4pIHsKICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgICAgICByZXR1cm4gZm4oZWFjaE9mLCBvYmosIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTsKICAgIH07Cn0KCmZ1bmN0aW9uIF9hc3luY01hcChlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICBhcnIgPSBhcnIgfHwgW107CiAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgdmFyIGNvdW50ZXIgPSAwOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CgogICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHZhbHVlLCBfLCBjYWxsYmFjaykgewogICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKzsKICAgICAgICBfaXRlcmF0ZWUodmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHsKICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2OwogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVycikgewogICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7CiAgICB9KTsKfQoKLyoqCiAqIFByb2R1Y2VzIGEgbmV3IGNvbGxlY3Rpb24gb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBgY29sbGAgdGhyb3VnaAogKiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIGBjb2xsYAogKiBhbmQgYSBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFjawogKiB0YWtlcyAyIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYGNvbGxgLiBJZgogKiBgaXRlcmF0ZWVgIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgKGZvciB0aGUKICogYG1hcGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci4KICoKICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluCiAqIHBhcmFsbGVsLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZQogKiBpbiBvcmRlci4gSG93ZXZlciwgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUKICogb3JpZ2luYWwgYGNvbGxgLgogKgogKiBJZiBgbWFwYCBpcyBwYXNzZWQgYW4gT2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGFuIEFycmF5LiAgVGhlIHJlc3VsdHMKICogd2lsbCByb3VnaGx5IGJlIGluIHRoZSBvcmRlciBvZiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuCiAqIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuCiAqCiAqIEBuYW1lIG1hcAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIEFycmF5IG9mIHRoZQogKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICoKICogYXN5bmMubWFwKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZzLnN0YXQsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2Ygc3RhdHMgZm9yIGVhY2ggZmlsZQogKiB9KTsKICovCnZhciBtYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7CgovKioKICogQXBwbGllcyB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIHRvIGVhY2ggZnVuY3Rpb24gaW4gdGhlIGFycmF5LCBjYWxsaW5nCiAqIGBjYWxsYmFja2AgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gSWYgeW91IG9ubHkgcHJvdmlkZSB0aGUgZmlyc3QKICogYXJndW1lbnQsIGBmbnNgLCB0aGVuIGl0IHdpbGwgcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGUKICogYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUgZnVuY3Rpb24gY2FsbC4gSWYgbW9yZSBhcmd1bWVudHMgYXJlCiAqIHByb3ZpZGVkLCBgY2FsbGJhY2tgIGlzIHJlcXVpcmVkIHdoaWxlIGBhcmdzYCBpcyBzdGlsbCBvcHRpb25hbC4KICoKICogQG5hbWUgYXBwbHlFYWNoCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGZucyAtIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zCiAqIHRvIGFsbCBjYWxsIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzCiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUKICogZnVuY3Rpb24uCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSB0aGUgZmluYWwgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBjYWxsYmFjaywKICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gSWYgb25seSB0aGUgZmlyc3QgYXJndW1lbnQsIGBmbnNgLCBpcyBwcm92aWRlZCwgaXQgd2lsbAogKiByZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZSBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZQogKiBmdW5jdGlvbiBjYWxsLiBUaGUgc2lnbmF0dXJlIGlzIGAoLi5hcmdzLCBjYWxsYmFjaylgLiBJZiBpbnZva2VkIHdpdGggYW55CiAqIGFyZ3VtZW50cywgYGNhbGxiYWNrYCBpcyByZXF1aXJlZC4KICogQGV4YW1wbGUKICoKICogYXN5bmMuYXBwbHlFYWNoKFtlbmFibGVTZWFyY2gsIHVwZGF0ZVNjaGVtYV0sICdidWNrZXQnLCBjYWxsYmFjayk7CiAqCiAqIC8vIHBhcnRpYWwgYXBwbGljYXRpb24gZXhhbXBsZToKICogYXN5bmMuZWFjaCgKICogICAgIGJ1Y2tldHMsCiAqICAgICBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSksCiAqICAgICBjYWxsYmFjawogKiApOwogKi8KdmFyIGFwcGx5RWFjaCA9IGFwcGx5RWFjaCQxKG1hcCk7CgpmdW5jdGlvbiBkb1BhcmFsbGVsTGltaXQoZm4pIHsKICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIGZuKF9lYWNoT2ZMaW1pdChsaW1pdCksIG9iaiwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spOwogICAgfTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIG1hcExpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZQogKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCnZhciBtYXBMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfYXN5bmNNYXApOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBtYXBTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZQogKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCnZhciBtYXBTZXJpZXMgPSBkb0xpbWl0KG1hcExpbWl0LCAxKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGFwcGx5RWFjaGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgYXBwbHlFYWNoU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmFwcGx5RWFjaF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmFwcGx5RWFjaH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gZm5zIC0gQSBjb2xsZWN0aW9uIG9mIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgdG8gYWxsCiAqIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMKICogQHBhcmFtIHsuLi4qfSBbYXJnc10gLSBhbnkgbnVtYmVyIG9mIHNlcGFyYXRlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZQogKiBmdW5jdGlvbi4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLAogKiBjYWxsZWQgd2hlbiBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHByb2Nlc3NpbmcuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBJZiBvbmx5IHRoZSBmaXJzdCBhcmd1bWVudCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4KICogYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZSBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZQogKiBmdW5jdGlvbiBjYWxsLgogKi8KdmFyIGFwcGx5RWFjaFNlcmllcyA9IGFwcGx5RWFjaCQxKG1hcFNlcmllcyk7CgovKioKICogQ3JlYXRlcyBhIGNvbnRpbnVhdGlvbiBmdW5jdGlvbiB3aXRoIHNvbWUgYXJndW1lbnRzIGFscmVhZHkgYXBwbGllZC4KICoKICogVXNlZnVsIGFzIGEgc2hvcnRoYW5kIHdoZW4gY29tYmluZWQgd2l0aCBvdGhlciBjb250cm9sIGZsb3cgZnVuY3Rpb25zLiBBbnkKICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gYXJlIGFkZGVkIHRvIHRoZSBhcmd1bWVudHMKICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuCiAqCiAqIEBuYW1lIGFwcGx5CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHkgYWxsCiAqIGFyZ3VtZW50cyB0by4gSW52b2tlcyB3aXRoIChhcmd1bWVudHMuLi4pLgogKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkKICogd2hlbiB0aGUgY29udGludWF0aW9uIGlzIGNhbGxlZC4KICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcGFydGlhbGx5LWFwcGxpZWQgZnVuY3Rpb24KICogQGV4YW1wbGUKICoKICogLy8gdXNpbmcgYXBwbHkKICogYXN5bmMucGFyYWxsZWwoWwogKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUxJywgJ3Rlc3QxJyksCiAqICAgICBhc3luYy5hcHBseShmcy53cml0ZUZpbGUsICd0ZXN0ZmlsZTInLCAndGVzdDInKQogKiBdKTsKICoKICoKICogLy8gdGhlIHNhbWUgcHJvY2VzcyB3aXRob3V0IHVzaW5nIGFwcGx5CiAqIGFzeW5jLnBhcmFsbGVsKFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTEnLCAndGVzdDEnLCBjYWxsYmFjayk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMicsICd0ZXN0MicsIGNhbGxiYWNrKTsKICogICAgIH0KICogXSk7CiAqCiAqIC8vIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHdoZW4gY2FsbGluZyB0aGUKICogLy8gY29udGludWF0aW9uOgogKgogKiBub2RlPiB2YXIgZm4gPSBhc3luYy5hcHBseShzeXMucHV0cywgJ29uZScpOwogKiBub2RlPiBmbigndHdvJywgJ3RocmVlJyk7CiAqIG9uZQogKiB0d28KICogdGhyZWUKICovCnZhciBhcHBseSA9IGZ1bmN0aW9uKGZuLyosIC4uLmFyZ3MqLykgewogICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgcmV0dXJuIGZ1bmN0aW9uKC8qY2FsbEFyZ3MqLykgewogICAgICAgIHZhciBjYWxsQXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGNhbGxBcmdzKSk7CiAgICB9Owp9OwoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IKICogaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC4KICovCmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkgewogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIGFycmF5Owp9CgovKioKICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHsKICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHsKICAgIHZhciBpbmRleCA9IC0xLAogICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksCiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLAogICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsKCiAgICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdOwogICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBvYmplY3Q7CiAgfTsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgCiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LgogKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uCiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuCiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuCiAqLwp2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC4KICovCmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkgewogIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXQKICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuCiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS4KICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuCiAqLwpmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7CiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwKICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTsKCiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHsKICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7CiAgICAgIHJldHVybiBpbmRleDsKICAgIH0KICB9CiAgcmV0dXJuIC0xOwp9CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTsKfQoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHkKICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC4KICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci4KICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuCiAqLwpmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7CiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwKICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwoKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHsKICAgICAgcmV0dXJuIGluZGV4OwogICAgfQogIH0KICByZXR1cm4gLTE7Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LgogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLgogKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC4KICovCmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7CiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZQogICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KQogICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7Cn0KCi8qKgogKiBEZXRlcm1pbmVzIHRoZSBiZXN0IG9yZGVyIGZvciBydW5uaW5nIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGluIGB0YXNrc2AsIGJhc2VkIG9uCiAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zCiAqIGJlaW5nIGNvbXBsZXRlZCBmaXJzdCwgYW5kIGVhY2ggZnVuY3Rpb24gaXMgcnVuIGFzIHNvb24gYXMgaXRzIHJlcXVpcmVtZW50cwogKiBhcmUgc2F0aXNmaWVkLgogKgogKiBJZiBhbnkgb2YgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjaywgdGhlIGBhdXRvYCBzZXF1ZW5jZQogKiB3aWxsIHN0b3AuIEZ1cnRoZXIgdGFza3Mgd2lsbCBub3QgZXhlY3V0ZSAoc28gYW55IG90aGVyIGZ1bmN0aW9ucyBkZXBlbmRpbmcKICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlCiAqIGVycm9yLgogKgogKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2gKICogaGF2ZSBjb21wbGV0ZWQgc28gZmFyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgdGhleSBoYXZlIGRlcGVuZGVuY2llcy4gSWYgYQogKiB0YXNrIGZ1bmN0aW9uIGhhcyBubyBkZXBlbmRlbmNpZXMsIGl0IHdpbGwgb25seSBiZSBwYXNzZWQgYSBjYWxsYmFjay4KICoKICogQG5hbWUgYXV0bwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYQogKiBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiByZXF1aXJlbWVudHMsIHdpdGggdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufSBpdHNlbGYgdGhlIGxhc3QgaXRlbQogKiBpbiB0aGUgYXJyYXkuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eSBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sKICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yCiAqIG90aGVyIHRhc2tzLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgb25lIG9yIHR3byBhcmd1bWVudHM6CiAqICogYSBgcmVzdWx0c2Agb2JqZWN0LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91c2x5IGV4ZWN1dGVkCiAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcywKICogKiBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGZ1bmN0aW9uLCB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aGVuIGZpbmlzaGVkLAogKiAgIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uJ3MKICogICBleGVjdXRpb24uCiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvcgogKiBkZXRlcm1pbmluZyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGFza3MgdGhhdCBjYW4gYmUgcnVuIGluIHBhcmFsbGVsLiBCeQogKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIHRoZSB0YXNrcyBoYXZlIGJlZW4gY29tcGxldGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYXJndW1lbnQgaWYgYW55IGB0YXNrc2AKICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhbgogKiBlcnJvciBvY2N1cnMsIG5vIGZ1cnRoZXIgYHRhc2tzYCB3aWxsIGJlIHBlcmZvcm1lZCwgYW5kIHRoZSByZXN1bHRzIG9iamVjdAogKiB3aWxsIG9ubHkgY29udGFpbiBwYXJ0aWFsIHJlc3VsdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgLy8gdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgYmUgcGFzc2VkIGEgY2FsbGJhY2sKICogICAgIHJlYWREYXRhOiBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgJ2RhdGEudHh0JywgJ3V0Zi04JyksCiAqICAgICBzaG93RGF0YTogWydyZWFkRGF0YScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNiKSB7CiAqICAgICAgICAgLy8gcmVzdWx0cy5yZWFkRGF0YSBpcyB0aGUgZmlsZSdzIGNvbnRlbnRzCiAqICAgICAgICAgLy8gLi4uCiAqICAgICB9XQogKiB9LCBjYWxsYmFjayk7CiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIGdldF9kYXRhJyk7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7CiAqICAgICB9LAogKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIG1ha2VfZm9sZGVyJyk7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluCiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpOwogKiAgICAgfSwKICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiB3cml0ZV9maWxlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpOwogKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cywKICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpOwogKiAgICAgfV0sCiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBlbWFpbF9saW5rJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpOwogKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi4KICogICAgICAgICAvLyByZXN1bHRzLndyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7CiAqICAgICB9XQogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpOwogKiAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTsKICogfSk7CiAqLwp2YXIgYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY29uY3VycmVuY3ksIGNhbGxiYWNrKSB7CiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgLy8gY29uY3VycmVuY3kgaXMgb3B0aW9uYWwsIHNoaWZ0IHRoZSBhcmdzLgogICAgICAgIGNhbGxiYWNrID0gY29uY3VycmVuY3k7CiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsOwogICAgfQogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIGtleXMkJDEgPSBrZXlzKHRhc2tzKTsKICAgIHZhciBudW1UYXNrcyA9IGtleXMkJDEubGVuZ3RoOwogICAgaWYgKCFudW1UYXNrcykgewogICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgIH0KICAgIGlmICghY29uY3VycmVuY3kpIHsKICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzOwogICAgfQoKICAgIHZhciByZXN1bHRzID0ge307CiAgICB2YXIgcnVubmluZ1Rhc2tzID0gMDsKICAgIHZhciBoYXNFcnJvciA9IGZhbHNlOwoKICAgIHZhciBsaXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwoKICAgIHZhciByZWFkeVRhc2tzID0gW107CgogICAgLy8gZm9yIGN5Y2xlIGRldGVjdGlvbjoKICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGUKICAgIC8vIHdpdGhvdXQgdGhlIHBvc3NpYmlsaXR5IG9mIHJldHVybmluZyB0byBhbiBhbmNlc3RvciB0YXNrCiAgICB2YXIgdW5jaGVja2VkRGVwZW5kZW5jaWVzID0ge307CgogICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSkgewogICAgICAgIGlmICghaXNBcnJheSh0YXNrKSkgewogICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXMKICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCBbdGFza10pOwogICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChrZXkpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpOwogICAgICAgIHZhciByZW1haW5pbmdEZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubGVuZ3RoOwogICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHsKICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTsKICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goa2V5KTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB1bmNoZWNrZWREZXBlbmRlbmNpZXNba2V5XSA9IHJlbWFpbmluZ0RlcGVuZGVuY2llczsKCiAgICAgICAgYXJyYXlFYWNoKGRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGRlcGVuZGVuY3lOYW1lKSB7CiAgICAgICAgICAgIGlmICghdGFza3NbZGVwZW5kZW5jeU5hbWVdKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jLmF1dG8gdGFzayBgJyArIGtleSArCiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgKwogICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lOYW1lICsgJ2AgaW4gJyArCiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmpvaW4oJywgJykpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGFkZExpc3RlbmVyKGRlcGVuZGVuY3lOYW1lLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZW1haW5pbmdEZXBlbmRlbmNpZXMtLTsKICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIHRhc2spOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgIH0pOwoKICAgIGNoZWNrRm9yRGVhZGxvY2tzKCk7CiAgICBwcm9jZXNzUXVldWUoKTsKCiAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayhrZXksIHRhc2spIHsKICAgICAgICByZWFkeVRhc2tzLnB1c2goZnVuY3Rpb24gKCkgewogICAgICAgICAgICBydW5UYXNrKGtleSwgdGFzayk7CiAgICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkgewogICAgICAgIGlmIChyZWFkeVRhc2tzLmxlbmd0aCA9PT0gMCAmJiBydW5uaW5nVGFza3MgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpOwogICAgICAgIH0KICAgICAgICB3aGlsZShyZWFkeVRhc2tzLmxlbmd0aCAmJiBydW5uaW5nVGFza3MgPCBjb25jdXJyZW5jeSkgewogICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpOwogICAgICAgICAgICBydW4oKTsKICAgICAgICB9CgogICAgfQoKICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikgewogICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXTsKICAgICAgICBpZiAoIXRhc2tMaXN0ZW5lcnMpIHsKICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTsKICAgICAgICB9CgogICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7CiAgICB9CgogICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7CiAgICAgICAgdmFyIHRhc2tMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdGFza05hbWVdIHx8IFtdOwogICAgICAgIGFycmF5RWFjaCh0YXNrTGlzdGVuZXJzLCBmdW5jdGlvbiAoZm4pIHsKICAgICAgICAgICAgZm4oKTsKICAgICAgICB9KTsKICAgICAgICBwcm9jZXNzUXVldWUoKTsKICAgIH0KCgogICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHsKICAgICAgICBpZiAoaGFzRXJyb3IpIHJldHVybjsKCiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAgICAgICAgICAgIHJ1bm5pbmdUYXNrcy0tOwogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307CiAgICAgICAgICAgICAgICBiYXNlRm9yT3duKHJlc3VsdHMsIGZ1bmN0aW9uKHZhbCwgcmtleSkgewogICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gdmFsOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trZXldID0gcmVzdWx0OwogICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlOwogICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKCiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDsKICAgICAgICAgICAgICAgIHRhc2tDb21wbGV0ZShrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIHJ1bm5pbmdUYXNrcysrOwogICAgICAgIHZhciB0YXNrRm4gPSB3cmFwQXN5bmModGFza1t0YXNrLmxlbmd0aCAtIDFdKTsKICAgICAgICBpZiAodGFzay5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRhc2tGbih0YXNrQ2FsbGJhY2spOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHsKICAgICAgICAvLyBLYWhuJ3MgYWxnb3JpdGhtCiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9wb2xvZ2ljYWxfc29ydGluZyNLYWhuLjI3c19hbGdvcml0aG0KICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWwKICAgICAgICB2YXIgY3VycmVudFRhc2s7CiAgICAgICAgdmFyIGNvdW50ZXIgPSAwOwogICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7CiAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcmVhZHlUb0NoZWNrLnBvcCgpOwogICAgICAgICAgICBjb3VudGVyKys7CiAgICAgICAgICAgIGFycmF5RWFjaChnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKSwgZnVuY3Rpb24gKGRlcGVuZGVudCkgewogICAgICAgICAgICAgICAgaWYgKC0tdW5jaGVja2VkRGVwZW5kZW5jaWVzW2RlcGVuZGVudF0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChkZXBlbmRlbnQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIGlmIChjb3VudGVyICE9PSBudW1UYXNrcykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeScKICAgICAgICAgICAgKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW50cyh0YXNrTmFtZSkgewogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICBiYXNlRm9yT3duKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5KSB7CiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhc2spICYmIGJhc2VJbmRleE9mKHRhc2ssIHRhc2tOYW1lLCAwKSA+PSAwKSB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KfTsKCi8qKgogKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUKICogc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsCiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJzsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzU3ltYm9sKCdhYmMnKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7CiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fAogICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTsKfQoKLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovCnZhciBJTkZJTklUWSA9IDEgLyAwOwoKLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovCnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCQxID8gU3ltYm9sJDEucHJvdG90eXBlIDogdW5kZWZpbmVkOwp2YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaAogKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLgogKi8KZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7CiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy4KICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gdmFsdWU7CiAgfQogIGlmIChpc0FycmF5KHZhbHVlKSkgewogICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS4KICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnOwogIH0KICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7CiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnOwogIH0KICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpOwogIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS4KICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uCiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLgogKi8KZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKCiAgaWYgKHN0YXJ0IDwgMCkgewogICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTsKICB9CiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kOwogIGlmIChlbmQgPCAwKSB7CiAgICBlbmQgKz0gbGVuZ3RoOwogIH0KICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7CiAgc3RhcnQgPj4+PSAwOwoKICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKioKICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi4KICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuCiAqLwpmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHsKICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kOwogIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpOwp9CgovKioKICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sCiAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuCiAqLwpmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHsKICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDsKCiAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9CiAgcmV0dXJuIGluZGV4Owp9CgovKioKICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sCiAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLgogKi8KZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fQogIHJldHVybiBpbmRleDsKfQoKLyoqCiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7CiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7Cn0KCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi8KdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFx1ZDgwMC1cXHVkZmZmJzsKdmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyMyc7CnZhciByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcdTIwZDAtXFx1MjBmMCc7CnZhciByc1ZhclJhbmdlID0gJ1xcdWZlMGVcXHVmZTBmJzsKCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi8KdmFyIHJzWldKID0gJ1xcdTIwMGQnOwoKLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovCnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9NYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpOwoKLyoqCiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC4KICovCmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7CiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7Cn0KCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi8KdmFyIHJzQXN0cmFsUmFuZ2UkMSA9ICdcXHVkODAwLVxcdWRmZmYnOwp2YXIgcnNDb21ib01hcmtzUmFuZ2UkMSA9ICdcXHUwMzAwLVxcdTAzNmZcXHVmZTIwLVxcdWZlMjMnOwp2YXIgcnNDb21ib1N5bWJvbHNSYW5nZSQxID0gJ1xcdTIwZDAtXFx1MjBmMCc7CnZhciByc1ZhclJhbmdlJDEgPSAnXFx1ZmUwZVxcdWZlMGYnOwoKLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqLwp2YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlJDEgKyAnXSc7CnZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib01hcmtzUmFuZ2UkMSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMSArICddJzsKdmFyIHJzRml0eiA9ICdcXHVkODNjW1xcdWRmZmItXFx1ZGZmZl0nOwp2YXIgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJzsKdmFyIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJzsKdmFyIHJzUmVnaW9uYWwgPSAnKD86XFx1ZDgzY1tcXHVkZGU2LVxcdWRkZmZdKXsyfSc7CnZhciByc1N1cnJQYWlyID0gJ1tcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0nOwp2YXIgcnNaV0okMSA9ICdcXHUyMDBkJzsKCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqLwp2YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nOwp2YXIgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlJDEgKyAnXT8nOwp2YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiQxICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonOwp2YXIgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luOwp2YXIgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7CgovKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqLwp2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7CgovKioKICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHsKICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107Cn0KCi8qKgogKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LgogKi8KZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHsKICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpCiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZykKICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7Cn0KCi8qKgogKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYAogKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy4KICogQGV4YW1wbGUKICoKICogXy50b1N0cmluZyhudWxsKTsKICogLy8gPT4gJycKICoKICogXy50b1N0cmluZygtMCk7CiAqIC8vID0+ICctMCcKICoKICogXy50b1N0cmluZyhbMSwgMiwgM10pOwogKiAvLyA9PiAnMSwyLDMnCiAqLwpmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkgewogIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpOwp9CgovKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqLwp2YXIgcmVUcmltID0gL15ccyt8XHMrJC9nOwoKLyoqCiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAzLjAuMAogKiBAY2F0ZWdvcnkgU3RyaW5nCiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uCiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS4KICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuCiAqIEBleGFtcGxlCiAqCiAqIF8udHJpbSgnICBhYmMgICcpOwogKiAvLyA9PiAnYWJjJwogKgogKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpOwogKiAvLyA9PiAnYWJjJwogKgogKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pOwogKiAvLyA9PiBbJ2ZvbycsICdiYXInXQogKi8KZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkgewogIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7CiAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHsKICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTsKICB9CiAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7CiAgICByZXR1cm4gc3RyaW5nOwogIH0KICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwKICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLAogICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSwKICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7CgogIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7Cn0KCnZhciBGTl9BUkdTID0gL14oPzphc3luY1xzKyk/KGZ1bmN0aW9uKT9ccypbXlwoXSpcKFxzKihbXlwpXSopXCkvbTsKdmFyIEZOX0FSR19TUExJVCA9IC8sLzsKdmFyIEZOX0FSRyA9IC8oPS4rKT8oXHMqKSQvOwp2YXIgU1RSSVBfQ09NTUVOVFMgPSAvKChcL1wvLiokKXwoXC9cKltcc1xTXSo/XCpcLykpL21nOwoKZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykgewogICAgZnVuYyA9IGZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKFNUUklQX0NPTU1FTlRTLCAnJyk7CiAgICBmdW5jID0gZnVuYy5tYXRjaChGTl9BUkdTKVsyXS5yZXBsYWNlKCcgJywgJycpOwogICAgZnVuYyA9IGZ1bmMgPyBmdW5jLnNwbGl0KEZOX0FSR19TUExJVCkgOiBbXTsKICAgIGZ1bmMgPSBmdW5jLm1hcChmdW5jdGlvbiAoYXJnKXsKICAgICAgICByZXR1cm4gdHJpbShhcmcucmVwbGFjZShGTl9BUkcsICcnKSk7CiAgICB9KTsKICAgIHJldHVybiBmdW5jOwp9CgovKioKICogQSBkZXBlbmRlbmN5LWluamVjdGVkIHZlcnNpb24gb2YgdGhlIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30gZnVuY3Rpb24uIERlcGVuZGVudAogKiB0YXNrcyBhcmUgc3BlY2lmaWVkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGZ1bmN0aW9uLCBhZnRlciB0aGUgdXN1YWwgY2FsbGJhY2sKICogcGFyYW1ldGVyLCB3aXRoIHRoZSBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2hpbmcgdGhlIG5hbWVzIG9mIHRoZSB0YXNrcyBpdAogKiBkZXBlbmRzIG9uLiBUaGlzIGNhbiBwcm92aWRlIGV2ZW4gbW9yZSByZWFkYWJsZSB0YXNrIGdyYXBocyB3aGljaCBjYW4gYmUKICogZWFzaWVyIHRvIG1haW50YWluLgogKgogKiBJZiBhIGZpbmFsIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgdGhlIHRhc2sgcmVzdWx0cyBhcmUgc2ltaWxhcmx5IGluamVjdGVkLAogKiBzcGVjaWZpZWQgYXMgbmFtZWQgcGFyYW1ldGVycyBhZnRlciB0aGUgaW5pdGlhbCBlcnJvciBwYXJhbWV0ZXIuCiAqCiAqIFRoZSBhdXRvSW5qZWN0IGZ1bmN0aW9uIGlzIHB1cmVseSBzeW50YWN0aWMgc3VnYXIgYW5kIGl0cyBzZW1hbnRpY3MgYXJlCiAqIG90aGVyd2lzZSBlcXVpdmFsZW50IHRvIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uCiAqCiAqIEBuYW1lIGF1dG9JbmplY3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtPYmplY3R9IHRhc2tzIC0gQW4gb2JqZWN0LCBlYWNoIG9mIHdob3NlIHByb3BlcnRpZXMgaXMgYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259IG9mCiAqIHRoZSBmb3JtICdmdW5jKFtkZXBlbmRlbmNpZXMuLi5dLCBjYWxsYmFjaykuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eQogKiBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sgZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkCiAqIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yIG90aGVyIHRhc2tzLgogKiAqIFRoZSBgY2FsbGJhY2tgIHBhcmFtZXRlciBpcyBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqICAgd2hlbiBmaW5pc2hlZCwgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZgogKiAgIHRoZSBmdW5jdGlvbidzIGV4ZWN1dGlvbi4gVGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzIG5hbWUgb3RoZXIgdGFza3Mgb24KICogICB3aGljaCB0aGUgdGFzayBpcyBkZXBlbmRlbnQsIGFuZCB0aGUgcmVzdWx0cyBmcm9tIHRob3NlIHRhc2tzIGFyZSB0aGUKICogICBhcmd1bWVudHMgb2YgdGhvc2UgcGFyYW1ldGVycy4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgCiAqIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIGFuZCBhIGByZXN1bHRzYCBvYmplY3Qgd2l0aCBhbnkgY29tcGxldGVkCiAqIHRhc2sgcmVzdWx0cywgc2ltaWxhciB0byBgYXV0b2AuCiAqIEBleGFtcGxlCiAqCiAqIC8vICBUaGUgZXhhbXBsZSBmcm9tIGBhdXRvYCBjYW4gYmUgcmV3cml0dGVuIGFzIGZvbGxvd3M6CiAqIGFzeW5jLmF1dG9JbmplY3QoewogKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7CiAqICAgICB9LAogKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluCiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpOwogKiAgICAgfSwKICogICAgIHdyaXRlX2ZpbGU6IGZ1bmN0aW9uKGdldF9kYXRhLCBtYWtlX2ZvbGRlciwgY2FsbGJhY2spIHsKICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsCiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnkKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTsKICogICAgIH0sCiAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykgewogKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi4KICogICAgICAgICAvLyB3cml0ZV9maWxlIGNvbnRhaW5zIHRoZSBmaWxlbmFtZSByZXR1cm5lZCBieSB3cml0ZV9maWxlLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTsKICogICAgIGNvbnNvbGUubG9nKCdlbWFpbF9saW5rID0gJywgcmVzdWx0cy5lbWFpbF9saW5rKTsKICogfSk7CiAqCiAqIC8vIElmIHlvdSBhcmUgdXNpbmcgYSBKUyBtaW5pZmllciB0aGF0IG1hbmdsZXMgcGFyYW1ldGVyIG5hbWVzLCBgYXV0b0luamVjdGAKICogLy8gd2lsbCBub3Qgd29yayB3aXRoIHBsYWluIGZ1bmN0aW9ucywgc2luY2UgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsIGJlCiAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW4KICogLy8gZXhwbGljaXRseSBzcGVjaWZ5IHRoZSBuYW1lcyBvZiB0aGUgcGFyYW1ldGVycyB5b3VyIHRhc2sgZnVuY3Rpb24gbmVlZHMKICogLy8gaW4gYW4gYXJyYXksIHNpbWlsYXIgdG8gQW5ndWxhci5qcyBkZXBlbmRlbmN5IGluamVjdGlvbi4KICoKICogLy8gVGhpcyBzdGlsbCBoYXMgYW4gYWR2YW50YWdlIG92ZXIgcGxhaW4gYGF1dG9gLCBzaW5jZSB0aGUgcmVzdWx0cyBhIHRhc2sKICogLy8gZGVwZW5kcyBvbiBhcmUgc3RpbGwgc3ByZWFkIGludG8gYXJndW1lbnRzLgogKiBhc3luYy5hdXRvSW5qZWN0KHsKICogICAgIC8vLi4uCiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpOwogKiAgICAgfV0sCiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTsKICogICAgIH1dCiAqICAgICAvLy4uLgogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpOwogKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspOwogKiB9KTsKICovCmZ1bmN0aW9uIGF1dG9JbmplY3QodGFza3MsIGNhbGxiYWNrKSB7CiAgICB2YXIgbmV3VGFza3MgPSB7fTsKCiAgICBiYXNlRm9yT3duKHRhc2tzLCBmdW5jdGlvbiAodGFza0ZuLCBrZXkpIHsKICAgICAgICB2YXIgcGFyYW1zOwogICAgICAgIHZhciBmbklzQXN5bmMgPSBpc0FzeW5jKHRhc2tGbik7CiAgICAgICAgdmFyIGhhc05vRGVwcyA9CiAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8CiAgICAgICAgICAgIChmbklzQXN5bmMgJiYgdGFza0ZuLmxlbmd0aCA9PT0gMCk7CgogICAgICAgIGlmIChpc0FycmF5KHRhc2tGbikpIHsKICAgICAgICAgICAgcGFyYW1zID0gdGFza0ZuLnNsaWNlKDAsIC0xKTsKICAgICAgICAgICAgdGFza0ZuID0gdGFza0ZuW3Rhc2tGbi5sZW5ndGggLSAxXTsKCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KHBhcmFtcy5sZW5ndGggPiAwID8gbmV3VGFzayA6IHRhc2tGbik7CiAgICAgICAgfSBlbHNlIGlmIChoYXNOb0RlcHMpIHsKICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGZ1bmN0aW9uIGFzLWlzCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSB0YXNrRm47CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXModGFza0ZuKTsKICAgICAgICAgICAgaWYgKHRhc2tGbi5sZW5ndGggPT09IDAgJiYgIWZuSXNBc3luYyAmJiBwYXJhbXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLiIpOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyByZW1vdmUgY2FsbGJhY2sgcGFyYW0KICAgICAgICAgICAgaWYgKCFmbklzQXN5bmMpIHBhcmFtcy5wb3AoKTsKCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KG5ld1Rhc2spOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gbmV3VGFzayhyZXN1bHRzLCB0YXNrQ2IpIHsKICAgICAgICAgICAgdmFyIG5ld0FyZ3MgPSBhcnJheU1hcChwYXJhbXMsIGZ1bmN0aW9uIChuYW1lKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tuYW1lXTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIG5ld0FyZ3MucHVzaCh0YXNrQ2IpOwogICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKS5hcHBseShudWxsLCBuZXdBcmdzKTsKICAgICAgICB9CiAgICB9KTsKCiAgICBhdXRvKG5ld1Rhc2tzLCBjYWxsYmFjayk7Cn0KCi8vIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJseV9saW5rZWRfbGlzdCkgaW1wbGVtZW50YXRpb24KLy8gdXNlZCBmb3IgcXVldWVzLiBUaGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhhdCB0aGUgbm9kZSBwcm92aWRlZCBieSB0aGUgdXNlciBjYW4gYmUgbW9kaWZpZWQKLy8gdG8gYWRqdXN0IHRoZSBuZXh0IGFuZCBsYXN0IHByb3BlcnRpZXMuIFdlIGltcGxlbWVudCBvbmx5IHRoZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkKLy8gZm9yIHF1ZXVlIHN1cHBvcnQuCmZ1bmN0aW9uIERMTCgpIHsKICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICB0aGlzLmxlbmd0aCA9IDA7Cn0KCmZ1bmN0aW9uIHNldEluaXRpYWwoZGxsLCBub2RlKSB7CiAgICBkbGwubGVuZ3RoID0gMTsKICAgIGRsbC5oZWFkID0gZGxsLnRhaWwgPSBub2RlOwp9CgpETEwucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihub2RlKSB7CiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDsKICAgIGVsc2UgdGhpcy5oZWFkID0gbm9kZS5uZXh0OwogICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7CiAgICBlbHNlIHRoaXMudGFpbCA9IG5vZGUucHJldjsKCiAgICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsOwogICAgdGhpcy5sZW5ndGggLT0gMTsKICAgIHJldHVybiBub2RlOwp9OwoKRExMLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsKICAgIHdoaWxlKHRoaXMuaGVhZCkgdGhpcy5zaGlmdCgpOwogICAgcmV0dXJuIHRoaXM7Cn07CgpETEwucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkgewogICAgbmV3Tm9kZS5wcmV2ID0gbm9kZTsKICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDsKICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbmV3Tm9kZTsKICAgIGVsc2UgdGhpcy50YWlsID0gbmV3Tm9kZTsKICAgIG5vZGUubmV4dCA9IG5ld05vZGU7CiAgICB0aGlzLmxlbmd0aCArPSAxOwp9OwoKRExMLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbihub2RlLCBuZXdOb2RlKSB7CiAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7CiAgICBuZXdOb2RlLm5leHQgPSBub2RlOwogICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBuZXdOb2RlOwogICAgZWxzZSB0aGlzLmhlYWQgPSBuZXdOb2RlOwogICAgbm9kZS5wcmV2ID0gbmV3Tm9kZTsKICAgIHRoaXMubGVuZ3RoICs9IDE7Cn07CgpETEwucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihub2RlKSB7CiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsIG5vZGUpOwogICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpOwp9OwoKRExMLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkgewogICAgaWYgKHRoaXMudGFpbCkgdGhpcy5pbnNlcnRBZnRlcih0aGlzLnRhaWwsIG5vZGUpOwogICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpOwp9OwoKRExMLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy5oZWFkKTsKfTsKCkRMTC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdGhpcy50YWlsICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLnRhaWwpOwp9OwoKRExMLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgewogICAgdmFyIGFyciA9IEFycmF5KHRoaXMubGVuZ3RoKTsKICAgIHZhciBjdXJyID0gdGhpcy5oZWFkOwogICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmxlbmd0aDsgaWR4KyspIHsKICAgICAgICBhcnJbaWR4XSA9IGN1cnIuZGF0YTsKICAgICAgICBjdXJyID0gY3Vyci5uZXh0OwogICAgfQogICAgcmV0dXJuIGFycjsKfTsKCkRMTC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRlc3RGbikgewogICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7CiAgICB3aGlsZSghIWN1cnIpIHsKICAgICAgICB2YXIgbmV4dCA9IGN1cnIubmV4dDsKICAgICAgICBpZiAodGVzdEZuKGN1cnIpKSB7CiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGluayhjdXJyKTsKICAgICAgICB9CiAgICAgICAgY3VyciA9IG5leHQ7CiAgICB9CiAgICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIHF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3ksIHBheWxvYWQpIHsKICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7CiAgICAgICAgY29uY3VycmVuY3kgPSAxOwogICAgfQogICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpOwogICAgfQoKICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7CiAgICB2YXIgbnVtUnVubmluZyA9IDA7CiAgICB2YXIgd29ya2Vyc0xpc3QgPSBbXTsKCiAgICBmdW5jdGlvbiBfaW5zZXJ0KGRhdGEsIGluc2VydEF0RnJvbnQsIGNhbGxiYWNrKSB7CiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKICAgICAgICB9CiAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTsKICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHsKICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTsKICAgICAgICB9CiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7CiAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzCiAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUkMShmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHEuZHJhaW4oKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfQoKICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBpdGVtID0gewogICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXSwKICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayB8fCBub29wCiAgICAgICAgICAgIH07CgogICAgICAgICAgICBpZiAoaW5zZXJ0QXRGcm9udCkgewogICAgICAgICAgICAgICAgcS5fdGFza3MudW5zaGlmdChpdGVtKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHEuX3Rhc2tzLnB1c2goaXRlbSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc2V0SW1tZWRpYXRlJDEocS5wcm9jZXNzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBfbmV4dCh0YXNrcykgewogICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpewogICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7CgogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1tpXTsKCiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlSW5kZXhPZih3b3JrZXJzTGlzdCwgdGFzaywgMCk7CiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkgewogICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNwbGljZShpbmRleCwgMSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpOwoKICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkgewogICAgICAgICAgICAgICAgICAgIHEuZXJyb3IoZXJyLCB0YXNrLmRhdGEpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAobnVtUnVubmluZyA8PSAocS5jb25jdXJyZW5jeSAtIHEuYnVmZmVyKSApIHsKICAgICAgICAgICAgICAgIHEudW5zYXR1cmF0ZWQoKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHEuaWRsZSgpKSB7CiAgICAgICAgICAgICAgICBxLmRyYWluKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcS5wcm9jZXNzKCk7CiAgICAgICAgfTsKICAgIH0KCiAgICB2YXIgaXNQcm9jZXNzaW5nID0gZmFsc2U7CiAgICB2YXIgcSA9IHsKICAgICAgICBfdGFza3M6IG5ldyBETEwoKSwKICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksCiAgICAgICAgcGF5bG9hZDogcGF5bG9hZCwKICAgICAgICBzYXR1cmF0ZWQ6IG5vb3AsCiAgICAgICAgdW5zYXR1cmF0ZWQ6bm9vcCwKICAgICAgICBidWZmZXI6IGNvbmN1cnJlbmN5IC8gNCwKICAgICAgICBlbXB0eTogbm9vcCwKICAgICAgICBkcmFpbjogbm9vcCwKICAgICAgICBlcnJvcjogbm9vcCwKICAgICAgICBzdGFydGVkOiBmYWxzZSwKICAgICAgICBwYXVzZWQ6IGZhbHNlLAogICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykgewogICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7CiAgICAgICAgfSwKICAgICAgICBraWxsOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHEuZHJhaW4gPSBub29wOwogICAgICAgICAgICBxLl90YXNrcy5lbXB0eSgpOwogICAgICAgIH0sCiAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIF9pbnNlcnQoZGF0YSwgdHJ1ZSwgY2FsbGJhY2spOwogICAgICAgIH0sCiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAodGVzdEZuKSB7CiAgICAgICAgICAgIHEuX3Rhc2tzLnJlbW92ZSh0ZXN0Rm4pOwogICAgICAgIH0sCiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAvLyBBdm9pZCB0cnlpbmcgdG8gc3RhcnQgdG9vIG1hbnkgcHJvY2Vzc2luZyBvcGVyYXRpb25zLiBUaGlzIGNhbiBvY2N1cgogICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyByZXNvbHZlIHN5bmNocm9ub3VzbHkgKCMxMjY3KS4KICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykgewogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7CiAgICAgICAgICAgIHdoaWxlKCFxLnBhdXNlZCAmJiBudW1SdW5uaW5nIDwgcS5jb25jdXJyZW5jeSAmJiBxLl90YXNrcy5sZW5ndGgpewogICAgICAgICAgICAgICAgdmFyIHRhc2tzID0gW10sIGRhdGEgPSBbXTsKICAgICAgICAgICAgICAgIHZhciBsID0gcS5fdGFza3MubGVuZ3RoOwogICAgICAgICAgICAgICAgaWYgKHEucGF5bG9hZCkgbCA9IE1hdGgubWluKGwsIHEucGF5bG9hZCk7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcS5fdGFza3Muc2hpZnQoKTsKICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKG5vZGUpOwogICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnB1c2gobm9kZSk7CiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKG5vZGUuZGF0YSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgbnVtUnVubmluZyArPSAxOwoKICAgICAgICAgICAgICAgIGlmIChxLl90YXNrcy5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPT09IHEuY29uY3VycmVuY3kpIHsKICAgICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlPbmNlKF9uZXh0KHRhc2tzKSk7CiAgICAgICAgICAgICAgICBfd29ya2VyKGRhdGEsIGNiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTsKICAgICAgICB9LAogICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gcS5fdGFza3MubGVuZ3RoOwogICAgICAgIH0sCiAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gbnVtUnVubmluZzsKICAgICAgICB9LAogICAgICAgIHdvcmtlcnNMaXN0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHJldHVybiB3b3JrZXJzTGlzdDsKICAgICAgICB9LAogICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZXR1cm4gcS5fdGFza3MubGVuZ3RoICsgbnVtUnVubmluZyA9PT0gMDsKICAgICAgICB9LAogICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTsKICAgICAgICB9LAogICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfQogICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlOwogICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpOwogICAgICAgIH0KICAgIH07CiAgICByZXR1cm4gcTsKfQoKLyoqCiAqIEEgY2FyZ28gb2YgdGFza3MgZm9yIHRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuIENhcmdvIGluaGVyaXRzIGFsbCBvZgogKiB0aGUgc2FtZSBtZXRob2RzIGFuZCBldmVudCBjYWxsYmFja3MgYXMgW2BxdWV1ZWBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0uCiAqIEB0eXBlZGVmIHtPYmplY3R9IENhcmdvT2JqZWN0CiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtcwogKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIGxpa2UgYGNhcmdvLmxlbmd0aCgpYC4KICogQHByb3BlcnR5IHtudW1iZXJ9IHBheWxvYWQgLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IHRhc2tzCiAqIHNob3VsZCBiZSBwcm9jZXNzIHBlciByb3VuZC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhIGBjYXJnb2AgaXMKICogY3JlYXRlZCB0byBhbHRlciB0aGUgcGF5bG9hZCBvbi10aGUtZmx5LgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwdXNoIC0gQWRkcyBgdGFza2AgdG8gdGhlIGBxdWV1ZWAuIFRoZSBjYWxsYmFjayBpcwogKiBjYWxsZWQgb25jZSB0aGUgYHdvcmtlcmAgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcgdGhlIHRhc2suIEluc3RlYWQgb2YgYQogKiBzaW5nbGUgdGFzaywgYW4gYXJyYXkgb2YgYHRhc2tzYCBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpcwogKiB1c2VkIGZvciBldmVyeSB0YXNrIGluIHRoZSBsaXN0LiBJbnZva2UgbGlrZSBgY2FyZ28ucHVzaCh0YXNrLCBbY2FsbGJhY2tdKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHNhdHVyYXRlZCAtIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUKICogYHF1ZXVlLmxlbmd0aCgpYCBoaXRzIHRoZSBjb25jdXJyZW5jeSBhbmQgZnVydGhlciB0YXNrcyB3aWxsIGJlIHF1ZXVlZC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZW1wdHkgLSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGxhc3QgaXRlbQogKiBmcm9tIHRoZSBgcXVldWVgIGlzIGdpdmVuIHRvIGEgYHdvcmtlcmAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRyYWluIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW0KICogZnJvbSB0aGUgYHF1ZXVlYCBoYXMgcmV0dXJuZWQgZnJvbSB0aGUgYHdvcmtlcmAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGlkbGUgLSBhIGZ1bmN0aW9uIHJldHVybmluZyBmYWxzZSBpZiB0aGVyZSBhcmUgaXRlbXMKICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2UgbGlrZSBgY2FyZ28uaWRsZSgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcGF1c2UgLSBhIGZ1bmN0aW9uIHRoYXQgcGF1c2VzIHRoZSBwcm9jZXNzaW5nIG9mIHRhc2tzCiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2UgbGlrZSBgY2FyZ28ucGF1c2UoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlc3VtZSAtIGEgZnVuY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mCiAqIHF1ZXVlZCB0YXNrcyB3aGVuIHRoZSBxdWV1ZSBpcyBwYXVzZWQuIEludm9rZSBsaWtlIGBjYXJnby5yZXN1bWUoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmQKICogZW1wdGllcyByZW1haW5pbmcgdGFza3MgZnJvbSB0aGUgcXVldWUgZm9yY2luZyBpdCB0byBnbyBpZGxlLiBJbnZva2UgbGlrZSBgY2FyZ28ua2lsbCgpYC4KICovCgovKioKICogQ3JlYXRlcyBhIGBjYXJnb2Agb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkLiBUYXNrcyBhZGRlZCB0byB0aGUKICogY2FyZ28gd2lsbCBiZSBwcm9jZXNzZWQgYWx0b2dldGhlciAodXAgdG8gdGhlIGBwYXlsb2FkYCBsaW1pdCkuIElmIHRoZQogKiBgd29ya2VyYCBpcyBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBPbmNlCiAqIHRoZSBgd29ya2VyYCBoYXMgY29tcGxldGVkIHNvbWUgdGFza3MsIGVhY2ggY2FsbGJhY2sgb2YgdGhvc2UgdGFza3MgaXMKICogY2FsbGVkLiBDaGVjayBvdXQgW3RoZXNlXShodHRwczovL2NhbW8uZ2l0aHVidXNlcmNvbnRlbnQuY29tLzZiYmQzNmY0Y2Y1YjM1YTBmMTFhOTZkY2QyZTk3NzExZmZjMmZiMzcvNjg3NDc0NzA3MzNhMmYyZjY2MmU2MzZjNmY3NTY0MmU2NzY5NzQ2ODc1NjIyZTYzNmY2ZDJmNjE3MzczNjU3NDczMmYzMTM2MzczNjM4MzczMTJmMzYzODMxMzAzODJmNjI2MjYzMzA2MzY2NjIzMDJkMzU2NjMyMzkyZDMxMzE2NTMyMmQzOTM3MzQ2NjJkMzMzMzM5Mzc2MzM2MzQ2NDYzMzgzNTM4MmU2NzY5NjYpIFthbmltYXRpb25zXShodHRwczovL2NhbW8uZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Y0ODEwZTAwZTFjNWY1ZjhhZGRiZTNlOWY0OTA2NGZkNWQxMDI2OTkvNjg3NDc0NzA3MzNhMmYyZjY2MmU2MzZjNmY3NTY0MmU2NzY5NzQ2ODc1NjIyZTYzNmY2ZDJmNjE3MzczNjU3NDczMmYzMTM2MzczNjM4MzczMTJmMzYzODMxMzAzMTJmMzgzNDYzMzkzMjMwMzYzNjJkMzU2NjMyMzkyZDMxMzE2NTMyMmQzODMxMzQ2NjJkMzk2NDMzNjQzMDMyMzQzMTMzNjI2NjY0MmU2NzY5NjYpCiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLgogKgogKiBXaGlsZSBbYHF1ZXVlYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfSBwYXNzZXMgb25seSBvbmUgdGFzayB0byBvbmUgb2YgYSBncm91cCBvZiB3b3JrZXJzCiAqIGF0IGEgdGltZSwgY2FyZ28gcGFzc2VzIGFuIGFycmF5IG9mIHRhc2tzIHRvIGEgc2luZ2xlIHdvcmtlciwgcmVwZWF0aW5nCiAqIHdoZW4gdGhlIHdvcmtlciBpcyBmaW5pc2hlZC4KICoKICogQG5hbWUgY2FyZ28KICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhbiBhcnJheQogKiBvZiBxdWV1ZWQgdGFza3MuIEludm9rZWQgd2l0aCBgKHRhc2tzLCBjYWxsYmFjaylgLgogKiBAcGFyYW0ge251bWJlcn0gW3BheWxvYWQ9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvciBkZXRlcm1pbmluZwogKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXMKICogdW5saW1pdGVkLgogKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LkNhcmdvT2JqZWN0fSBBIGNhcmdvIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBDYWxsYmFja3MgY2FuCiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlCiAqIGxpZmVjeWNsZSBvZiB0aGUgY2FyZ28gYW5kIGlubmVyIHF1ZXVlLgogKiBAZXhhbXBsZQogKgogKiAvLyBjcmVhdGUgYSBjYXJnbyBvYmplY3Qgd2l0aCBwYXlsb2FkIDIKICogdmFyIGNhcmdvID0gYXN5bmMuY2FyZ28oZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7CiAqICAgICBmb3IgKHZhciBpPTA7IGk8dGFza3MubGVuZ3RoOyBpKyspIHsKICogICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2tzW2ldLm5hbWUpOwogKiAgICAgfQogKiAgICAgY2FsbGJhY2soKTsKICogfSwgMik7CiAqCiAqIC8vIGFkZCBzb21lIGl0ZW1zCiAqIGNhcmdvLnB1c2goe25hbWU6ICdmb28nfSwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBmb28nKTsKICogfSk7CiAqIGNhcmdvLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTsKICogfSk7CiAqIGNhcmdvLnB1c2goe25hbWU6ICdiYXonfSwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXonKTsKICogfSk7CiAqLwpmdW5jdGlvbiBjYXJnbyh3b3JrZXIsIHBheWxvYWQpIHsKICAgIHJldHVybiBxdWV1ZSh3b3JrZXIsIDEsIHBheWxvYWQpOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGVhY2hPZlNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9CiAqIEBhbGlhcyBmb3JFYWNoT2ZTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLgogKi8KdmFyIGVhY2hPZlNlcmllcyA9IGRvTGltaXQoZWFjaE9mTGltaXQsIDEpOwoKLyoqCiAqIFJlZHVjZXMgYGNvbGxgIGludG8gYSBzaW5nbGUgdmFsdWUgdXNpbmcgYW4gYXN5bmMgYGl0ZXJhdGVlYCB0byByZXR1cm4gZWFjaAogKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uCiAqIG9ubHkgb3BlcmF0ZXMgaW4gc2VyaWVzLgogKgogKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb24KICogaW50byBhIHBhcmFsbGVsIG1hcCwgYW5kIHRoZW4gdXNlIHRoZSBub3JtYWwgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG9uIHRoZQogKiByZXN1bHRzLiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBzaXR1YXRpb25zIHdoZXJlIGVhY2ggc3RlcCBpbiB0aGUgcmVkdWN0aW9uCiAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQncwogKiBwcm9iYWJseSBhIGdvb2QgaWRlYSB0byBkbyBzby4KICoKICogQG5hbWUgcmVkdWNlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBpbmplY3QKICogQGFsaWFzIGZvbGRsCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlCiAqIGFycmF5IHRvIHByb2R1Y2UgdGhlIG5leHQgc3RlcCBpbiB0aGUgcmVkdWN0aW9uLgogKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLgogKiBJZiB0aGUgaXRlcmF0ZWUgY29tcGxldGUgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGUKICogbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci4KICogSW52b2tlZCB3aXRoIChtZW1vLCBpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCBpcyB0aGUgcmVkdWNlZCB2YWx1ZS4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnJlZHVjZShbMSwyLDNdLCAwLCBmdW5jdGlvbihtZW1vLCBpdGVtLCBjYWxsYmFjaykgewogKiAgICAgLy8gcG9pbnRsZXNzIGFzeW5jOgogKiAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCBtZW1vICsgaXRlbSkKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGlzIG5vdyBlcXVhbCB0byB0aGUgbGFzdCB2YWx1ZSBvZiBtZW1vLCB3aGljaCBpcyA2CiAqIH0pOwogKi8KZnVuY3Rpb24gcmVkdWNlKGNvbGwsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBlYWNoT2ZTZXJpZXMoY29sbCwgZnVuY3Rpb24oeCwgaSwgY2FsbGJhY2spIHsKICAgICAgICBfaXRlcmF0ZWUobWVtbywgeCwgZnVuY3Rpb24oZXJyLCB2KSB7CiAgICAgICAgICAgIG1lbW8gPSB2OwogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTsKICAgIH0pOwp9CgovKioKICogVmVyc2lvbiBvZiB0aGUgY29tcG9zZSBmdW5jdGlvbiB0aGF0IGlzIG1vcmUgbmF0dXJhbCB0byByZWFkLiBFYWNoIGZ1bmN0aW9uCiAqIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLiBJdCBpcyB0aGUgZXF1aXZhbGVudCBvZgogKiBbY29tcG9zZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNvbXBvc2V9IHdpdGggdGhlIGFyZ3VtZW50cyByZXZlcnNlZC4KICoKICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uCiAqCiAqIEBuYW1lIHNlcQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5jb21wb3NlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuY29tcG9zZX0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0gey4uLkFzeW5jRnVuY3Rpb259IGZ1bmN0aW9ucyAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIHRvIGNvbXBvc2UKICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGBmdW5jdGlvbnNgIGluIG9yZGVyCiAqIEBleGFtcGxlCiAqCiAqIC8vIFJlcXVpcmVzIGxvZGFzaCAob3IgdW5kZXJzY29yZSksIGV4cHJlc3MzIGFuZCBkcmVzZW5kZSdzIG9ybTIuCiAqIC8vIFBhcnQgb2YgYW4gYXBwLCB0aGF0IGZldGNoZXMgY2F0cyBvZiB0aGUgbG9nZ2VkIHVzZXIuCiAqIC8vIFRoaXMgZXhhbXBsZSB1c2VzIGBzZXFgIGZ1bmN0aW9uIHRvIGF2b2lkIG92ZXJuZXN0aW5nIGFuZCBlcnJvcgogKiAvLyBoYW5kbGluZyBjbHV0dGVyLgogKiBhcHAuZ2V0KCcvY2F0cycsIGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7CiAqICAgICB2YXIgVXNlciA9IHJlcXVlc3QubW9kZWxzLlVzZXI7CiAqICAgICBhc3luYy5zZXEoCiAqICAgICAgICAgXy5iaW5kKFVzZXIuZ2V0LCBVc2VyKSwgIC8vICdVc2VyLmdldCcgaGFzIHNpZ25hdHVyZSAoaWQsIGNhbGxiYWNrKGVyciwgZGF0YSkpCiAqICAgICAgICAgZnVuY3Rpb24odXNlciwgZm4pIHsKICogICAgICAgICAgICAgdXNlci5nZXRDYXRzKGZuKTsgICAgICAvLyAnZ2V0Q2F0cycgaGFzIHNpZ25hdHVyZSAoY2FsbGJhY2soZXJyLCBkYXRhKSkKICogICAgICAgICB9CiAqICAgICApKHJlcS5zZXNzaW9uLnVzZXJfaWQsIGZ1bmN0aW9uIChlcnIsIGNhdHMpIHsKICogICAgICAgICBpZiAoZXJyKSB7CiAqICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTsKICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogZXJyLm1lc3NhZ2UgfSk7CiAqICAgICAgICAgfSBlbHNlIHsKICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ29rJywgbWVzc2FnZTogJ0NhdHMgZm91bmQnLCBkYXRhOiBjYXRzIH0pOwogKiAgICAgICAgIH0KICogICAgIH0pOwogKiB9KTsKICovCmZ1bmN0aW9uIHNlcSgvKi4uLmZ1bmN0aW9ucyovKSB7CiAgICB2YXIgX2Z1bmN0aW9ucyA9IGFycmF5TWFwKGFyZ3VtZW50cywgd3JhcEFzeW5jKTsKICAgIHJldHVybiBmdW5jdGlvbigvKi4uLmFyZ3MqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTsKICAgICAgICB2YXIgdGhhdCA9IHRoaXM7CgogICAgICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTsKICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgYXJncy5wb3AoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYiA9IG5vb3A7CiAgICAgICAgfQoKICAgICAgICByZWR1Y2UoX2Z1bmN0aW9ucywgYXJncywgZnVuY3Rpb24obmV3YXJncywgZm4sIGNiKSB7CiAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KGZ1bmN0aW9uKGVyci8qLCAuLi5uZXh0YXJncyovKSB7CiAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICB9LAogICAgICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogICAgICAgICAgICBjYi5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpOwogICAgICAgIH0pOwogICAgfTsKfQoKLyoqCiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBpcyBhIGNvbXBvc2l0aW9uIG9mIHRoZSBwYXNzZWQgYXN5bmNocm9ub3VzCiAqIGZ1bmN0aW9ucy4gRWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0CiAqIGZvbGxvd3MuIENvbXBvc2luZyBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgd291bGQgcHJvZHVjZSB0aGUgcmVzdWx0CiAqIG9mIGBmKGcoaCgpKSlgLCBvbmx5IHRoaXMgdmVyc2lvbiB1c2VzIGNhbGxiYWNrcyB0byBvYnRhaW4gdGhlIHJldHVybiB2YWx1ZXMuCiAqCiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLgogKgogKiBAbmFtZSBjb21wb3NlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2VkCiAqIGFzeW5jaHJvbm91cyBgZnVuY3Rpb25zYAogKiBAZXhhbXBsZQogKgogKiBmdW5jdGlvbiBhZGQxKG4sIGNhbGxiYWNrKSB7CiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICsgMSk7CiAqICAgICB9LCAxMCk7CiAqIH0KICoKICogZnVuY3Rpb24gbXVsMyhuLCBjYWxsYmFjaykgewogKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbiAqIDMpOwogKiAgICAgfSwgMTApOwogKiB9CiAqCiAqIHZhciBhZGQxbXVsMyA9IGFzeW5jLmNvbXBvc2UobXVsMywgYWRkMSk7CiAqIGFkZDFtdWwzKDQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgMTUKICogfSk7CiAqLwp2YXIgY29tcG9zZSA9IGZ1bmN0aW9uKC8qLi4uYXJncyovKSB7CiAgICByZXR1cm4gc2VxLmFwcGx5KG51bGwsIHNsaWNlKGFyZ3VtZW50cykucmV2ZXJzZSgpKTsKfTsKCnZhciBfY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBjb25jYXRMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLAogKiB3aGljaCBzaG91bGQgdXNlIGFuIGFycmF5IGFzIGl0cyByZXN1bHQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkKICogY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdHMgb2YgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHRzKS4KICovCnZhciBjb25jYXRMaW1pdCA9IGZ1bmN0aW9uKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgbWFwTGltaXQoY29sbCwgbGltaXQsIGZ1bmN0aW9uKHZhbCwgY2FsbGJhY2spIHsKICAgICAgICBfaXRlcmF0ZWUodmFsLCBmdW5jdGlvbihlcnIgLyosIC4uLmFyZ3MqLykgewogICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24oZXJyLCBtYXBSZXN1bHRzKSB7CiAgICAgICAgdmFyIHJlc3VsdCA9IFtdOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbmNhdC5hcHBseShyZXN1bHQsIG1hcFJlc3VsdHNbaV0pOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpOwogICAgfSk7Cn07CgovKioKICogQXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGNvbmNhdGVuYXRpbmcgdGhlIHJlc3VsdHMuIFJldHVybnMKICogdGhlIGNvbmNhdGVuYXRlZCBsaXN0LiBUaGUgYGl0ZXJhdGVlYHMgYXJlIGNhbGxlZCBpbiBwYXJhbGxlbCwgYW5kIHRoZQogKiByZXN1bHRzIGFyZSBjb25jYXRlbmF0ZWQgYXMgdGhleSByZXR1cm4uIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZQogKiByZXN1bHRzIGFycmF5IHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG9yaWdpbmFsIG9yZGVyIG9mIGBjb2xsYCBwYXNzZWQgdG8gdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb24uCiAqCiAqIEBuYW1lIGNvbmNhdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsCiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjayhlcnIpXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5CiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0cykuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmNvbmNhdChbJ2RpcjEnLCdkaXIyJywnZGlyMyddLCBmcy5yZWFkZGlyLCBmdW5jdGlvbihlcnIsIGZpbGVzKSB7CiAqICAgICAvLyBmaWxlcyBpcyBub3cgYSBsaXN0IG9mIGZpbGVuYW1lcyB0aGF0IGV4aXN0IGluIHRoZSAzIGRpcmVjdG9yaWVzCiAqIH0pOwogKi8KdmFyIGNvbmNhdCA9IGRvTGltaXQoY29uY2F0TGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgY29uY2F0U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmNvbmNhdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYW4gYXJyYXkgYW4gYXJyYXkgb2YgcmVzdWx0cy4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjayhlcnIpXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5CiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgY29uY2F0U2VyaWVzID0gZG9MaW1pdChjb25jYXRMaW1pdCwgMSk7CgovKioKICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBjYWxsZWQsIGNhbGxzLWJhY2sgd2l0aCB0aGUgdmFsdWVzIHByb3ZpZGVkLgogKiBVc2VmdWwgYXMgdGhlIGZpcnN0IGZ1bmN0aW9uIGluIGEgW2B3YXRlcmZhbGxgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2F0ZXJmYWxsfSwgb3IgZm9yIHBsdWdnaW5nIHZhbHVlcyBpbiB0bwogKiBbYGF1dG9gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uCiAqCiAqIEBuYW1lIGNvbnN0YW50CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXV0b21hdGljYWxseSBpbnZva2UKICogY2FsbGJhY2sgd2l0aC4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gaW52b2tlZCwgYXV0b21hdGljYWxseQogKiBpbnZva2VzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcmV2aW91cyBnaXZlbiBhcmd1bWVudHMuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBhc3luYy5jb25zdGFudCg0MiksCiAqICAgICBmdW5jdGlvbiAodmFsdWUsIG5leHQpIHsKICogICAgICAgICAvLyB2YWx1ZSA9PT0gNDIKICogICAgIH0sCiAqICAgICAvLy4uLgogKiBdLCBjYWxsYmFjayk7CiAqCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBhc3luYy5jb25zdGFudChmaWxlbmFtZSwgInV0ZjgiKSwKICogICAgIGZzLnJlYWRGaWxlLAogKiAgICAgZnVuY3Rpb24gKGZpbGVEYXRhLCBuZXh0KSB7CiAqICAgICAgICAgLy8uLi4KICogICAgIH0KICogICAgIC8vLi4uCiAqIF0sIGNhbGxiYWNrKTsKICoKICogYXN5bmMuYXV0byh7CiAqICAgICBob3N0bmFtZTogYXN5bmMuY29uc3RhbnQoImh0dHBzOi8vc2VydmVyLm5ldC8iKSwKICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCwKICogICAgIGxhdW5jaFNlcnZlcjogWyJob3N0bmFtZSIsICJwb3J0IiwgZnVuY3Rpb24gKG9wdGlvbnMsIGNiKSB7CiAqICAgICAgICAgc3RhcnRTZXJ2ZXIob3B0aW9ucywgY2IpOwogKiAgICAgfV0sCiAqICAgICAvLy4uLgogKiB9LCBjYWxsYmFjayk7CiAqLwp2YXIgY29uc3RhbnQgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7CiAgICB2YXIgdmFsdWVzID0gc2xpY2UoYXJndW1lbnRzKTsKICAgIHZhciBhcmdzID0gW251bGxdLmNvbmNhdCh2YWx1ZXMpOwogICAgcmV0dXJuIGZ1bmN0aW9uICgvKi4uLmlnbm9yZWRBcmdzLCBjYWxsYmFjayovKSB7CiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTsKICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7CiAgICB9Owp9OwoKLyoqCiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLgogKgogKiBAc3RhdGljCiAqIEBzaW5jZSAwLjEuMAogKiBAbWVtYmVyT2YgXwogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS4KICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC4KICogQGV4YW1wbGUKICoKICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07CiAqCiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTsKICogLy8gPT4gdHJ1ZQogKi8KZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHsKICByZXR1cm4gdmFsdWU7Cn0KCmZ1bmN0aW9uIF9jcmVhdGVUZXN0ZXIoY2hlY2ssIGdldFJlc3VsdCkgewogICAgcmV0dXJuIGZ1bmN0aW9uKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2IpIHsKICAgICAgICBjYiA9IGNiIHx8IG5vb3A7CiAgICAgICAgdmFyIHRlc3RQYXNzZWQgPSBmYWxzZTsKICAgICAgICB2YXIgdGVzdFJlc3VsdDsKICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbih2YWx1ZSwgXywgY2FsbGJhY2spIHsKICAgICAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hlY2socmVzdWx0KSAmJiAhdGVzdFJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgIHRlc3RQYXNzZWQgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgPSBnZXRSZXN1bHQodHJ1ZSwgdmFsdWUpOwogICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJyZWFrTG9vcCk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgIH0sIGZ1bmN0aW9uKGVycikgewogICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICBjYihlcnIpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY2IobnVsbCwgdGVzdFBhc3NlZCA/IHRlc3RSZXN1bHQgOiBnZXRSZXN1bHQoZmFsc2UpKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgfTsKfQoKZnVuY3Rpb24gX2ZpbmRHZXRSZXN1bHQodiwgeCkgewogICAgcmV0dXJuIHg7Cn0KCi8qKgogKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiBgY29sbGAgdGhhdCBwYXNzZXMgYW4gYXN5bmMgdHJ1dGggdGVzdC4gVGhlCiAqIGBpdGVyYXRlZWAgaXMgYXBwbGllZCBpbiBwYXJhbGxlbCwgbWVhbmluZyB0aGUgZmlyc3QgaXRlcmF0ZWUgdG8gcmV0dXJuCiAqIGB0cnVlYCB3aWxsIGZpcmUgdGhlIGRldGVjdCBgY2FsbGJhY2tgIHdpdGggdGhhdCByZXN1bHQuIFRoYXQgbWVhbnMgdGhlCiAqIHJlc3VsdCBtaWdodCBub3QgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIG9yaWdpbmFsIGBjb2xsYCAoaW4gdGVybXMgb2Ygb3JkZXIpCiAqIHRoYXQgcGFzc2VzIHRoZSB0ZXN0LgoKICogSWYgb3JkZXIgd2l0aGluIHRoZSBvcmlnaW5hbCBgY29sbGAgaXMgaW1wb3J0YW50LCB0aGVuIGxvb2sgYXQKICogW2BkZXRlY3RTZXJpZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0U2VyaWVzfS4KICoKICogQG5hbWUgZGV0ZWN0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBmaW5kCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9ucwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueQogKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLgogKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3QKICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHQpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5kZXRlY3QoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7CiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIHRoZSBmaXJzdCBmaWxlIGluIHRoZSBsaXN0IHRoYXQgZXhpc3RzCiAqIH0pOwogKi8KdmFyIGRldGVjdCA9IGRvUGFyYWxsZWwoX2NyZWF0ZVRlc3RlcihpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSBkZXRlY3RMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5kZXRlY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9CiAqIEBhbGlhcyBmaW5kTGltaXQKICogQGNhdGVnb3J5IENvbGxlY3Rpb25zCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0CiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0KS4KICovCnZhciBkZXRlY3RMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfY3JlYXRlVGVzdGVyKGlkZW50aXR5LCBfZmluZEdldFJlc3VsdCkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZGV0ZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBkZXRlY3RTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZGV0ZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fQogKiBAYWxpYXMgZmluZFNlcmllcwogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnMKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0CiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0KS4KICovCnZhciBkZXRlY3RTZXJpZXMgPSBkb0xpbWl0KGRldGVjdExpbWl0LCAxKTsKCmZ1bmN0aW9uIGNvbnNvbGVGdW5jKG5hbWUpIHsKICAgIHJldHVybiBmdW5jdGlvbiAoZm4vKiwgLi4uYXJncyovKSB7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLyosIC4uLmFyZ3MqLykgewogICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7CiAgICAgICAgICAgICAgICAgICAgYXJyYXlFYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICB3cmFwQXN5bmMoZm4pLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgfTsKfQoKLyoqCiAqIExvZ3MgdGhlIHJlc3VsdCBvZiBhbiBbYGFzeW5jYCBmdW5jdGlvbl17QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gdGhlCiAqIGBjb25zb2xlYCB1c2luZyBgY29uc29sZS5kaXJgIHRvIGRpc3BsYXkgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc3VsdGluZyBvYmplY3QuCiAqIE9ubHkgd29ya3MgaW4gTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUuZGlyYCBhbmQKICogYGNvbnNvbGUuZXJyb3JgIChzdWNoIGFzIEZGIGFuZCBDaHJvbWUpLgogKiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9uLAogKiBgY29uc29sZS5kaXJgIGlzIGNhbGxlZCBvbiBlYWNoIGFyZ3VtZW50IGluIG9yZGVyLgogKgogKiBAbmFtZSBkaXIKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5CiAqIGFsbCBhcmd1bWVudHMgdG8uCiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLgogKiBAZXhhbXBsZQogKgogKiAvLyBpbiBhIG1vZHVsZQogKiB2YXIgaGVsbG8gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykgewogKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCB7aGVsbG86IG5hbWV9KTsKICogICAgIH0sIDEwMDApOwogKiB9OwogKgogKiAvLyBpbiB0aGUgbm9kZSByZXBsCiAqIG5vZGU+IGFzeW5jLmRpcihoZWxsbywgJ3dvcmxkJyk7CiAqIHtoZWxsbzogJ3dvcmxkJ30KICovCnZhciBkaXIgPSBjb25zb2xlRnVuYygnZGlyJyk7CgovKioKICogVGhlIHBvc3QtY2hlY2sgdmVyc2lvbiBvZiBbYGR1cmluZ2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9LiBUbyByZWZsZWN0IHRoZSBkaWZmZXJlbmNlIGluCiAqIHRoZSBvcmRlciBvZiBvcGVyYXRpb25zLCB0aGUgYXJndW1lbnRzIGB0ZXN0YCBhbmQgYGZuYCBhcmUgc3dpdGNoZWQuCiAqCiAqIEFsc28gYSB2ZXJzaW9uIG9mIFtgZG9XaGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9IHdpdGggYXN5bmNocm9ub3VzIGB0ZXN0YCBmdW5jdGlvbi4KICogQG5hbWUgZG9EdXJpbmcKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZHVyaW5nXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZHVyaW5nfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lCiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgZm5gLiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKSwgd2hlcmUgYC4uLmFyZ3NgIGFyZSB0aGUKICogbm9uLWVycm9yIGFyZ3MgZnJvbSB0aGUgcHJldmlvdXMgY2FsbGJhY2sgb2YgYGZuYC4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgZm5gIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGlmIG9uZSBvY2N1cnJlZCwgb3RoZXJ3aXNlIGBudWxsYC4KICovCmZ1bmN0aW9uIGRvRHVyaW5nKGZuLCB0ZXN0LCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmx5T25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pOwogICAgdmFyIF90ZXN0ID0gd3JhcEFzeW5jKHRlc3QpOwoKICAgIGZ1bmN0aW9uIG5leHQoZXJyLyosIC4uLmFyZ3MqLykgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICBhcmdzLnB1c2goY2hlY2spOwogICAgICAgIF90ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoZWNrKGVyciwgdHJ1dGgpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCk7CiAgICAgICAgX2ZuKG5leHQpOwogICAgfQoKICAgIGNoZWNrKG51bGwsIHRydWUpOwoKfQoKLyoqCiAqIFRoZSBwb3N0LWNoZWNrIHZlcnNpb24gb2YgW2B3aGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS4gVG8gcmVmbGVjdCB0aGUgZGlmZmVyZW5jZSBpbgogKiB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucywgdGhlIGFyZ3VtZW50cyBgdGVzdGAgYW5kIGBpdGVyYXRlZWAgYXJlIHN3aXRjaGVkLgogKgogKiBgZG9XaGlsc3RgIGlzIHRvIGB3aGlsc3RgIGFzIGBkbyB3aGlsZWAgaXMgdG8gYHdoaWxlYCBpbiBwbGFpbiBKYXZhU2NyaXB0LgogKgogKiBAbmFtZSBkb1doaWxzdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZSBgdGVzdGAKICogcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdCAtIHN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBhZnRlciBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggYW55IG5vbi1lcnJvciBjYWxsYmFjayByZXN1bHRzIG9mCiAqIGBpdGVyYXRlZWAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdAogKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4KICogYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsCiAqIGBpdGVyYXRlZWAncyBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7CiAqLwpmdW5jdGlvbiBkb1doaWxzdChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyLyosIC4uLmFyZ3MqLykgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICBpZiAodGVzdC5hcHBseSh0aGlzLCBhcmdzKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTsKICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTsKICAgIH07CiAgICBfaXRlcmF0ZWUobmV4dCk7Cn0KCi8qKgogKiBMaWtlIFsnZG9XaGlsc3QnXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9LCBleGNlcHQgdGhlIGB0ZXN0YCBpcyBpbnZlcnRlZC4gTm90ZSB0aGUKICogYXJndW1lbnQgb3JkZXJpbmcgZGlmZmVycyBmcm9tIGB1bnRpbGAuCiAqCiAqIEBuYW1lIGRvVW50aWwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZG9XaGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kb1doaWxzdH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZQogKiBgdGVzdGAgZmFpbHMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2gKICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCBhbnkgbm9uLWVycm9yIGNhbGxiYWNrIHJlc3VsdHMgb2YKICogYGl0ZXJhdGVlYC4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBwYXNzZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTsKICovCmZ1bmN0aW9uIGRvVW50aWwoaXRlcmF0ZWUsIHRlc3QsIGNhbGxiYWNrKSB7CiAgICBkb1doaWxzdChpdGVyYXRlZSwgZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuICF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9LCBjYWxsYmFjayk7Cn0KCi8qKgogKiBMaWtlIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0sIGV4Y2VwdCB0aGUgYHRlc3RgIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0CiAqIGlzIHBhc3NlZCBhIGNhbGxiYWNrIGluIHRoZSBmb3JtIG9mIGBmdW5jdGlvbiAoZXJyLCB0cnV0aClgLiBJZiBlcnJvciBpcwogKiBwYXNzZWQgdG8gYHRlc3RgIG9yIGBmbmAsIHRoZSBtYWluIGNhbGxiYWNrIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZQogKiB2YWx1ZSBvZiB0aGUgZXJyb3IuCiAqCiAqIEBuYW1lIGR1cmluZwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBiZWZvcmUgZWFjaAogKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lCiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBmbmAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2AKICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IsIGlmIG9uZSBvY2N1cnJlZCwgb3RoZXJ3aXNlIGBudWxsYC4KICogQGV4YW1wbGUKICoKICogdmFyIGNvdW50ID0gMDsKICoKICogYXN5bmMuZHVyaW5nKAogKiAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7CiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvdW50IDwgNSk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY291bnQrKzsKICogICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbiAoZXJyKSB7CiAqICAgICAgICAgLy8gNSBzZWNvbmRzIGhhdmUgcGFzc2VkCiAqICAgICB9CiAqICk7CiAqLwpmdW5jdGlvbiBkdXJpbmcodGVzdCwgZm4sIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7CiAgICB2YXIgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7CgogICAgZnVuY3Rpb24gbmV4dChlcnIpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICBfdGVzdChjaGVjayk7CiAgICB9CgogICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIGlmICghdHJ1dGgpIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgICAgICBfZm4obmV4dCk7CiAgICB9CgogICAgX3Rlc3QoY2hlY2spOwp9CgpmdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgY2FsbGJhY2spIHsKICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUsIGNhbGxiYWNrKTsKICAgIH07Cn0KCi8qKgogKiBBcHBsaWVzIHRoZSBmdW5jdGlvbiBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGluIHBhcmFsbGVsLgogKiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBhbiBpdGVtIGZyb20gdGhlIGxpc3QsIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuCiAqIGl0IGhhcyBmaW5pc2hlZC4gSWYgdGhlIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBgY2FsbGJhY2tgLCB0aGUKICogbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBlYWNoYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlCiAqIGVycm9yLgogKgogKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBwYXJhbGxlbCwKICogdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlIGluIG9yZGVyLgogKgogKiBAbmFtZSBlYWNoCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBmb3JFYWNoCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvCiAqIGVhY2ggaXRlbSBpbiBgY29sbGAuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBUaGUgYXJyYXkgaW5kZXggaXMgbm90IHBhc3NlZCB0byB0aGUgaXRlcmF0ZWUuCiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZgLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuCiAqIEBleGFtcGxlCiAqCiAqIC8vIGFzc3VtaW5nIG9wZW5GaWxlcyBpcyBhbiBhcnJheSBvZiBmaWxlIG5hbWVzIGFuZCBzYXZlRmlsZSBpcyBhIGZ1bmN0aW9uCiAqIC8vIHRvIHNhdmUgdGhlIG1vZGlmaWVkIGNvbnRlbnRzIG9mIHRoYXQgZmlsZToKICoKICogYXN5bmMuZWFjaChvcGVuRmlsZXMsIHNhdmVGaWxlLCBmdW5jdGlvbihlcnIpewogKiAgIC8vIGlmIGFueSBvZiB0aGUgc2F2ZXMgcHJvZHVjZWQgYW4gZXJyb3IsIGVyciB3b3VsZCBlcXVhbCB0aGF0IGVycm9yCiAqIH0pOwogKgogKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lcwogKiBhc3luYy5lYWNoKG9wZW5GaWxlcywgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHsKICoKICogICAgIC8vIFBlcmZvcm0gb3BlcmF0aW9uIG9uIGZpbGUgaGVyZS4KICogICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGZpbGUgJyArIGZpbGUpOwogKgogKiAgICAgaWYoIGZpbGUubGVuZ3RoID4gMzIgKSB7CiAqICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGZpbGUgbmFtZSBpcyB0b28gbG9uZycpOwogKiAgICAgICBjYWxsYmFjaygnRmlsZSBuYW1lIHRvbyBsb25nJyk7CiAqICAgICB9IGVsc2UgewogKiAgICAgICAvLyBEbyB3b3JrIHRvIHByb2Nlc3MgZmlsZSBoZXJlCiAqICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIHByb2Nlc3NlZCcpOwogKiAgICAgICBjYWxsYmFjaygpOwogKiAgICAgfQogKiB9LCBmdW5jdGlvbihlcnIpIHsKICogICAgIC8vIGlmIGFueSBvZiB0aGUgZmlsZSBwcm9jZXNzaW5nIHByb2R1Y2VkIGFuIGVycm9yLCBlcnIgd291bGQgZXF1YWwgdGhhdCBlcnJvcgogKiAgICAgaWYoIGVyciApIHsKICogICAgICAgLy8gT25lIG9mIHRoZSBpdGVyYXRpb25zIHByb2R1Y2VkIGFuIGVycm9yLgogKiAgICAgICAvLyBBbGwgcHJvY2Vzc2luZyB3aWxsIG5vdyBzdG9wLgogKiAgICAgICBjb25zb2xlLmxvZygnQSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzJyk7CiAqICAgICB9IGVsc2UgewogKiAgICAgICBjb25zb2xlLmxvZygnQWxsIGZpbGVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5Jyk7CiAqICAgICB9CiAqIH0pOwogKi8KZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgZWFjaE9mKGNvbGwsIF93aXRob3V0SW5kZXgod3JhcEFzeW5jKGl0ZXJhdGVlKSksIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICoKICogQG5hbWUgZWFjaExpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofQogKiBAYWxpYXMgZm9yRWFjaExpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLgogKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mTGltaXRgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLgogKi8KZnVuY3Rpb24gZWFjaExpbWl0JDEoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgX2VhY2hPZkxpbWl0KGxpbWl0KShjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBlYWNoU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofQogKiBAYWxpYXMgZm9yRWFjaFNlcmllcwogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoCiAqIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgYXJyYXkgaW5kZXggaXMgbm90IHBhc3NlZCB0byB0aGUgaXRlcmF0ZWUuCiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLgogKi8KdmFyIGVhY2hTZXJpZXMgPSBkb0xpbWl0KGVhY2hMaW1pdCQxLCAxKTsKCi8qKgogKiBXcmFwIGFuIGFzeW5jIGZ1bmN0aW9uIGFuZCBlbnN1cmUgaXQgY2FsbHMgaXRzIGNhbGxiYWNrIG9uIGEgbGF0ZXIgdGljayBvZgogKiB0aGUgZXZlbnQgbG9vcC4gIElmIHRoZSBmdW5jdGlvbiBhbHJlYWR5IGNhbGxzIGl0cyBjYWxsYmFjayBvbiBhIG5leHQgdGljaywKICogbm8gZXh0cmEgZGVmZXJyYWwgaXMgYWRkZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBwcmV2ZW50aW5nIHN0YWNrIG92ZXJmbG93cwogKiAoYFJhbmdlRXJyb3I6IE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkYCkgYW5kIGdlbmVyYWxseSBrZWVwaW5nCiAqIFtaYWxnb10oaHR0cDovL2Jsb2cuaXpzLm1lL3Bvc3QvNTkxNDI3NDIxNDMvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpCiAqIGNvbnRhaW5lZC4gRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zIGFyZSByZXR1cm5lZCBhcy1pcyAtLSB0aGV5IGFyZSBpbW11bmUKICogdG8gWmFsZ28ncyBjb3JydXB0aW5nIGluZmx1ZW5jZXMsIGFzIHRoZXkgYWx3YXlzIHJlc29sdmUgb24gYSBsYXRlciB0aWNrLgogKgogKiBAbmFtZSBlbnN1cmVBc3luYwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24sIG9uZSB0aGF0IGV4cGVjdHMgYSBub2RlLXN0eWxlCiAqIGNhbGxiYWNrIGFzIGl0cyBsYXN0IGFyZ3VtZW50LgogKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gd2l0aCB0aGUgZXhhY3Qgc2FtZSBjYWxsCiAqIHNpZ25hdHVyZSBhcyB0aGUgZnVuY3Rpb24gcGFzc2VkIGluLgogKiBAZXhhbXBsZQogKgogKiBmdW5jdGlvbiBzb21ldGltZXNBc3luYyhhcmcsIGNhbGxiYWNrKSB7CiAqICAgICBpZiAoY2FjaGVbYXJnXSkgewogKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZVthcmddKTsgLy8gdGhpcyB3b3VsZCBiZSBzeW5jaHJvbm91cyEhCiAqICAgICB9IGVsc2UgewogKiAgICAgICAgIGRvU29tZUlPKGFyZywgY2FsbGJhY2spOyAvLyB0aGlzIElPIHdvdWxkIGJlIGFzeW5jaHJvbm91cwogKiAgICAgfQogKiB9CiAqCiAqIC8vIHRoaXMgaGFzIGEgcmlzayBvZiBzdGFjayBvdmVyZmxvd3MgaWYgbWFueSByZXN1bHRzIGFyZSBjYWNoZWQgaW4gYSByb3cKICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIHNvbWV0aW1lc0FzeW5jLCBkb25lKTsKICoKICogLy8gdGhpcyB3aWxsIGRlZmVyIHNvbWV0aW1lc0FzeW5jJ3MgY2FsbGJhY2sgaWYgbmVjZXNzYXJ5LAogKiAvLyBwcmV2ZW50aW5nIHN0YWNrIG92ZXJmbG93cwogKiBhc3luYy5tYXBTZXJpZXMoYXJncywgYXN5bmMuZW5zdXJlQXN5bmMoc29tZXRpbWVzQXN5bmMpLCBkb25lKTsKICovCmZ1bmN0aW9uIGVuc3VyZUFzeW5jKGZuKSB7CiAgICBpZiAoaXNBc3luYyhmbikpIHJldHVybiBmbjsKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIHZhciBzeW5jID0gdHJ1ZTsKICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKCkgewogICAgICAgICAgICB2YXIgaW5uZXJBcmdzID0gYXJndW1lbnRzOwogICAgICAgICAgICBpZiAoc3luYykgewogICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGlubmVyQXJncyk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGlubmVyQXJncyk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTsKICAgICAgICBzeW5jID0gZmFsc2U7CiAgICB9KTsKfQoKZnVuY3Rpb24gbm90SWQodikgewogICAgcmV0dXJuICF2Owp9CgovKioKICogUmV0dXJucyBgdHJ1ZWAgaWYgZXZlcnkgZWxlbWVudCBpbiBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuIElmIGFueQogKiBpdGVyYXRlZSBjYWxsIHJldHVybnMgYGZhbHNlYCwgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQuCiAqCiAqIEBuYW1lIGV2ZXJ5CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBhbGwKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gcGFyYWxsZWwuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYAogKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5ldmVyeShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHsKICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycikKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBldmVyeSBmaWxlIGV4aXN0cwogKiB9KTsKICovCnZhciBldmVyeSA9IGRvUGFyYWxsZWwoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICoKICogQG5hbWUgZXZlcnlMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5ldmVyeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fQogKiBAYWxpYXMgYWxsTGltaXQKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbQogKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC4KICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgCiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgZXZlcnlMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfY3JlYXRlVGVzdGVyKG5vdElkLCBub3RJZCkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZXZlcnlTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0KICogQGFsaWFzIGFsbFNlcmllcwogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbQogKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBzZXJpZXMuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYAogKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KdmFyIGV2ZXJ5U2VyaWVzID0gZG9MaW1pdChldmVyeUxpbWl0LCAxKTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC4KICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uCiAqLwpmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7CiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkgewogICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07CiAgfTsKfQoKZnVuY3Rpb24gZmlsdGVyQXJyYXkoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIHRydXRoVmFsdWVzID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOwogICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykgewogICAgICAgIGl0ZXJhdGVlKHgsIGZ1bmN0aW9uIChlcnIsIHYpIHsKICAgICAgICAgICAgdHJ1dGhWYWx1ZXNbaW5kZXhdID0gISF2OwogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVycikgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIHZhciByZXN1bHRzID0gW107CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKHRydXRoVmFsdWVzW2ldKSByZXN1bHRzLnB1c2goYXJyW2ldKTsKICAgICAgICB9CiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7CiAgICB9KTsKfQoKZnVuY3Rpb24gZmlsdGVyR2VuZXJpYyhlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIGVhY2hmbihjb2xsLCBmdW5jdGlvbiAoeCwgaW5kZXgsIGNhbGxiYWNrKSB7CiAgICAgICAgaXRlcmF0ZWUoeCwgZnVuY3Rpb24gKGVyciwgdikgewogICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgaWYgKHYpIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe2luZGV4OiBpbmRleCwgdmFsdWU6IHh9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYXJyYXlNYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7CiAgICAgICAgICAgIH0pLCBiYXNlUHJvcGVydHkoJ3ZhbHVlJykpKTsKICAgICAgICB9CiAgICB9KTsKfQoKZnVuY3Rpb24gX2ZpbHRlcihlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIGZpbHRlciA9IGlzQXJyYXlMaWtlKGNvbGwpID8gZmlsdGVyQXJyYXkgOiBmaWx0ZXJHZW5lcmljOwogICAgZmlsdGVyKGVhY2hmbiwgY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2sgfHwgbm9vcCk7Cn0KCi8qKgogKiBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGFsbCB0aGUgdmFsdWVzIGluIGBjb2xsYCB3aGljaCBwYXNzIGFuIGFzeW5jIHRydXRoCiAqIHRlc3QuIFRoaXMgb3BlcmF0aW9uIGlzIHBlcmZvcm1lZCBpbiBwYXJhbGxlbCwgYnV0IHRoZSByZXN1bHRzIGFycmF5IHdpbGwgYmUKICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIG9yaWdpbmFsLgogKgogKiBAbmFtZSBmaWx0ZXIKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIHNlbGVjdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWQKICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5maWx0ZXIoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7CiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIG5vdyBlcXVhbHMgYW4gYXJyYXkgb2YgdGhlIGV4aXN0aW5nIGZpbGVzCiAqIH0pOwogKi8KdmFyIGZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7CgovKioKICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgZmlsdGVyTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfQogKiBAYWxpYXMgc2VsZWN0TGltaXQKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWQKICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIGZpbHRlckxpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9maWx0ZXIpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBmaWx0ZXJTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfQogKiBAYWxpYXMgc2VsZWN0U2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZAogKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykKICovCnZhciBmaWx0ZXJTZXJpZXMgPSBkb0xpbWl0KGZpbHRlckxpbWl0LCAxKTsKCi8qKgogKiBDYWxscyB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGBmbmAgd2l0aCBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IGFsbG93cyBpdAogKiB0byBjYWxsIGl0c2VsZiBhZ2FpbiwgaW4gc2VyaWVzLCBpbmRlZmluaXRlbHkuCgogKiBJZiBhbiBlcnJvciBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHRoZW4gYGVycmJhY2tgIGlzIGNhbGxlZCB3aXRoIHRoZQogKiBlcnJvciwgYW5kIGV4ZWN1dGlvbiBzdG9wcywgb3RoZXJ3aXNlIGl0IHdpbGwgbmV2ZXIgYmUgY2FsbGVkLgogKgogKiBAbmFtZSBmb3JldmVyCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgcmVwZWF0ZWRseS4KICogSW52b2tlZCB3aXRoIChuZXh0KS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2VycmJhY2tdIC0gd2hlbiBgZm5gIHBhc3NlcyBhbiBlcnJvciB0byBpdCdzIGNhbGxiYWNrLAogKiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLCBhbmQgZXhlY3V0aW9uIHN0b3BzLiBJbnZva2VkIHdpdGggKGVycikuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmZvcmV2ZXIoCiAqICAgICBmdW5jdGlvbihuZXh0KSB7CiAqICAgICAgICAgLy8gbmV4dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byB0aGluZ3MgdGhhdCBuZWVkIGEgY2FsbGJhY2soZXJyIFssIHdoYXRldmVyXSk7CiAqICAgICAgICAgLy8gaXQgd2lsbCByZXN1bHQgaW4gdGhpcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgYWdhaW4uCiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAgICAgLy8gaWYgbmV4dCBpcyBjYWxsZWQgd2l0aCBhIHZhbHVlIGluIGl0cyBmaXJzdCBwYXJhbWV0ZXIsIGl0IHdpbGwgYXBwZWFyCiAqICAgICAgICAgLy8gaW4gaGVyZSBhcyAnZXJyJywgYW5kIGV4ZWN1dGlvbiB3aWxsIHN0b3AuCiAqICAgICB9CiAqICk7CiAqLwpmdW5jdGlvbiBmb3JldmVyKGZuLCBlcnJiYWNrKSB7CiAgICB2YXIgZG9uZSA9IG9ubHlPbmNlKGVycmJhY2sgfHwgbm9vcCk7CiAgICB2YXIgdGFzayA9IHdyYXBBc3luYyhlbnN1cmVBc3luYyhmbikpOwoKICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTsKICAgICAgICB0YXNrKG5leHQpOwogICAgfQogICAgbmV4dCgpOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2Bncm91cEJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBncm91cEJ5TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZ3JvdXBCeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXMKICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuCiAqLwp2YXIgZ3JvdXBCeUxpbWl0ID0gZnVuY3Rpb24oY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBtYXBMaW1pdChjb2xsLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBjYWxsYmFjaykgewogICAgICAgIF9pdGVyYXRlZSh2YWwsIGZ1bmN0aW9uKGVyciwga2V5KSB7CiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge2tleToga2V5LCB2YWw6IHZhbH0pOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24oZXJyLCBtYXBSZXN1bHRzKSB7CiAgICAgICAgdmFyIHJlc3VsdCA9IHt9OwogICAgICAgIC8vIGZyb20gTUROLCBoYW5kbGUgb2JqZWN0IGhhdmluZyBhbiBgaGFzT3duUHJvcGVydHlgIHByb3AKICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5OwoKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcFJlc3VsdHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHsKICAgICAgICAgICAgICAgIHZhciBrZXkgPSBtYXBSZXN1bHRzW2ldLmtleTsKICAgICAgICAgICAgICAgIHZhciB2YWwgPSBtYXBSZXN1bHRzW2ldLnZhbDsKCiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbCk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbF07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7CiAgICB9KTsKfTsKCi8qKgogKiBSZXR1cm5zIGEgbmV3IG9iamVjdCwgd2hlcmUgZWFjaCB2YWx1ZSBjb3JyZXNwb25kcyB0byBhbiBhcnJheSBvZiBpdGVtcywgZnJvbQogKiBgY29sbGAsIHRoYXQgcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBUaGF0IGlzLCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0CiAqIGNvcnJlc3BvbmQgdG8gdGhlIHZhbHVlcyBwYXNzZWQgdG8gdGhlIGBpdGVyYXRlZWAgY2FsbGJhY2suCiAqCiAqIE5vdGU6IFNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsCiAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlIGluIG9yZGVyLgogKiBIb3dldmVyLCB0aGUgdmFsdWVzIGZvciBlYWNoIGtleSBpbiB0aGUgYHJlc3VsdGAgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcwogKiB0aGUgb3JpZ2luYWwgYGNvbGxgLiBGb3IgT2JqZWN0cywgdGhlIHZhbHVlcyB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mCiAqIHRoZSBvcmlnaW5hbCBPYmplY3RzJyBrZXlzIChidXQgdGhpcyBjYW4gdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS4KICoKICogQG5hbWUgZ3JvdXBCeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuCiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3NlcwogKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZ3JvdXBCeShbJ3VzZXJJZDEnLCAndXNlcklkMicsICd1c2VySWQzJ10sIGZ1bmN0aW9uKHVzZXJJZCwgY2FsbGJhY2spIHsKICogICAgIGRiLmZpbmRCeUlkKHVzZXJJZCwgZnVuY3Rpb24oZXJyLCB1c2VyKSB7CiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHVzZXIuYWdlKTsKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGlzIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VySWRzIGdyb3VwZWQgYnkgYWdlCiAqICAgICAvLyBlLmcuIHsgMzA6IFsndXNlcklkMScsICd1c2VySWQzJ10sIDQyOiBbJ3VzZXJJZDInXX07CiAqIH0pOwogKi8KdmFyIGdyb3VwQnkgPSBkb0xpbWl0KGdyb3VwQnlMaW1pdCwgSW5maW5pdHkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGdyb3VwQnlTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZ3JvdXBCeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXMKICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuCiAqLwp2YXIgZ3JvdXBCeVNlcmllcyA9IGRvTGltaXQoZ3JvdXBCeUxpbWl0LCAxKTsKCi8qKgogKiBMb2dzIHRoZSByZXN1bHQgb2YgYW4gYGFzeW5jYCBmdW5jdGlvbiB0byB0aGUgYGNvbnNvbGVgLiBPbmx5IHdvcmtzIGluCiAqIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmxvZ2AgYW5kIGBjb25zb2xlLmVycm9yYCAoc3VjaAogKiBhcyBGRiBhbmQgQ2hyb21lKS4gSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luYwogKiBmdW5jdGlvbiwgYGNvbnNvbGUubG9nYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci4KICoKICogQG5hbWUgbG9nCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseQogKiBhbGwgYXJndW1lbnRzIHRvLgogKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi4KICogQGV4YW1wbGUKICoKICogLy8gaW4gYSBtb2R1bGUKICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHsKICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2hlbGxvICcgKyBuYW1lKTsKICogICAgIH0sIDEwMDApOwogKiB9OwogKgogKiAvLyBpbiB0aGUgbm9kZSByZXBsCiAqIG5vZGU+IGFzeW5jLmxvZyhoZWxsbywgJ3dvcmxkJyk7CiAqICdoZWxsbyB3b3JsZCcKICovCnZhciBsb2cgPSBjb25zb2xlRnVuYygnbG9nJyk7CgovKioKICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgbWFwVmFsdWVzTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWFwVmFsdWVzXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXkKICogaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuCiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZwogKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS4KICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwpmdW5jdGlvbiBtYXBWYWx1ZXNMaW1pdChvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBuZXdPYmogPSB7fTsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgZWFjaE9mTGltaXQob2JqLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBrZXksIG5leHQpIHsKICAgICAgICBfaXRlcmF0ZWUodmFsLCBrZXksIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgewogICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpOwogICAgICAgICAgICBuZXdPYmpba2V5XSA9IHJlc3VsdDsKICAgICAgICAgICAgbmV4dCgpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVycikgewogICAgICAgIGNhbGxiYWNrKGVyciwgbmV3T2JqKTsKICAgIH0pOwp9CgovKioKICogQSByZWxhdGl2ZSBvZiBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggb2JqZWN0cy4KICoKICogUHJvZHVjZXMgYSBuZXcgT2JqZWN0IGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBvZiBgb2JqYCB0aHJvdWdoIHRoZSBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgZWFjaCBgdmFsdWVgIGFuZCBga2V5YCBmcm9tIGBvYmpgIGFuZCBhCiAqIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrcyB0YWtlcwogKiB0d28gYXJndW1lbnRzOiBhbiBgZXJyb3JgLCBhbmQgdGhlIHRyYW5zZm9ybWVkIGl0ZW0gZnJvbSBgb2JqYC4gSWYgYGl0ZXJhdGVlYAogKiBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBtYXBWYWx1ZXNgCiAqIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuCiAqCiAqIE5vdGUsIHRoZSBvcmRlciBvZiB0aGUga2V5cyBpbiB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkLiAgVGhlIGtleXMgd2lsbAogKiBiZSByb3VnaGx5IGluIHRoZSBvcmRlciB0aGV5IGNvbXBsZXRlLCAoYnV0IHRoaXMgaXMgdmVyeSBlbmdpbmUtc3BlY2lmaWMpCiAqCiAqIEBuYW1lIG1hcFZhbHVlcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5CiAqIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmcKICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5tYXBWYWx1ZXMoewogKiAgICAgZjE6ICdmaWxlMScsCiAqICAgICBmMjogJ2ZpbGUyJywKICogICAgIGYzOiAnZmlsZTMnCiAqIH0sIGZ1bmN0aW9uIChmaWxlLCBrZXksIGNhbGxiYWNrKSB7CiAqICAgZnMuc3RhdChmaWxlLCBjYWxsYmFjayk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgaXMgbm93IGEgbWFwIG9mIHN0YXRzIGZvciBlYWNoIGZpbGUsIGUuZy4KICogICAgIC8vIHsKICogICAgIC8vICAgICBmMTogW3N0YXRzIGZvciBmaWxlMV0sCiAqICAgICAvLyAgICAgZjI6IFtzdGF0cyBmb3IgZmlsZTJdLAogKiAgICAgLy8gICAgIGYzOiBbc3RhdHMgZm9yIGZpbGUzXQogKiAgICAgLy8gfQogKiB9KTsKICovCgp2YXIgbWFwVmFsdWVzID0gZG9MaW1pdChtYXBWYWx1ZXNMaW1pdCwgSW5maW5pdHkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBtYXBWYWx1ZXNTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWFwVmFsdWVzXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5CiAqIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmcKICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KdmFyIG1hcFZhbHVlc1NlcmllcyA9IGRvTGltaXQobWFwVmFsdWVzTGltaXQsIDEpOwoKZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7CiAgICByZXR1cm4ga2V5IGluIG9iajsKfQoKLyoqCiAqIENhY2hlcyB0aGUgcmVzdWx0cyBvZiBhbiBhc3luYyBmdW5jdGlvbi4gV2hlbiBjcmVhdGluZyBhIGhhc2ggdG8gc3RvcmUKICogZnVuY3Rpb24gcmVzdWx0cyBhZ2FpbnN0LCB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCBmcm9tIHRoZSBoYXNoIGFuZCBhbgogKiBvcHRpb25hbCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSB1c2VkLgogKgogKiBJZiBubyBoYXNoIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoYXNoIGtleSwKICogd2hpY2ggbWF5IHdvcmsgcmVhc29uYWJseSBpZiBpdCBpcyBhIHN0cmluZyBvciBhIGRhdGEgdHlwZSB0aGF0IGNvbnZlcnRzIHRvIGEKICogZGlzdGluY3Qgc3RyaW5nLiBOb3RlIHRoYXQgb2JqZWN0cyBhbmQgYXJyYXlzIHdpbGwgbm90IGJlaGF2ZSByZWFzb25hYmx5LgogKiBOZWl0aGVyIHdpbGwgY2FzZXMgd2hlcmUgdGhlIG90aGVyIGFyZ3VtZW50cyBhcmUgc2lnbmlmaWNhbnQuIEluIHN1Y2ggY2FzZXMsCiAqIHNwZWNpZnkgeW91ciBvd24gaGFzaCBmdW5jdGlvbi4KICoKICogVGhlIGNhY2hlIG9mIHJlc3VsdHMgaXMgZXhwb3NlZCBhcyB0aGUgYG1lbW9gIHByb3BlcnR5IG9mIHRoZSBmdW5jdGlvbgogKiByZXR1cm5lZCBieSBgbWVtb2l6ZWAuCiAqCiAqIEBuYW1lIG1lbW9pemUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBwcm94eSBhbmQgY2FjaGUgcmVzdWx0cyBmcm9tLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNoZXIgLSBBbiBvcHRpb25hbCBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhIGN1c3RvbSBoYXNoCiAqIGZvciBzdG9yaW5nIHJlc3VsdHMuIEl0IGhhcyBhbGwgdGhlIGFyZ3VtZW50cyBhcHBsaWVkIHRvIGl0IGFwYXJ0IGZyb20gdGhlCiAqIGNhbGxiYWNrLCBhbmQgbXVzdCBiZSBzeW5jaHJvbm91cy4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgbWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gCiAqIEBleGFtcGxlCiAqCiAqIHZhciBzbG93X2ZuID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHsKICogICAgIC8vIGRvIHNvbWV0aGluZwogKiAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTsKICogfTsKICogdmFyIGZuID0gYXN5bmMubWVtb2l6ZShzbG93X2ZuKTsKICoKICogLy8gZm4gY2FuIG5vdyBiZSB1c2VkIGFzIGlmIGl0IHdlcmUgc2xvd19mbgogKiBmbignc29tZSBuYW1lJywgZnVuY3Rpb24oKSB7CiAqICAgICAvLyBjYWxsYmFjawogKiB9KTsKICovCmZ1bmN0aW9uIG1lbW9pemUoZm4sIGhhc2hlcikgewogICAgdmFyIG1lbW8gPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgdmFyIHF1ZXVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICBoYXNoZXIgPSBoYXNoZXIgfHwgaWRlbnRpdHk7CiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGZuKTsKICAgIHZhciBtZW1vaXplZCA9IGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gbWVtb2l6ZWQoYXJncywgY2FsbGJhY2spIHsKICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgICAgIGlmIChoYXMobWVtbywga2V5KSkgewogICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSBpZiAoaGFzKHF1ZXVlcywga2V5KSkgewogICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107CiAgICAgICAgICAgIF9mbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChmdW5jdGlvbigvKmFyZ3MqLykgewogICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpOwogICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJnczsKICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07CiAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07CiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmdzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkpOwogICAgICAgIH0KICAgIH0pOwogICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87CiAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47CiAgICByZXR1cm4gbWVtb2l6ZWQ7Cn0KCi8qKgogKiBDYWxscyBgY2FsbGJhY2tgIG9uIGEgbGF0ZXIgbG9vcCBhcm91bmQgdGhlIGV2ZW50IGxvb3AuIEluIE5vZGUuanMgdGhpcyBqdXN0CiAqIGNhbGxzIGBzZXRJbW1lZGlhdGVgLiAgSW4gdGhlIGJyb3dzZXIgaXQgd2lsbCB1c2UgYHNldEltbWVkaWF0ZWAgaWYKICogYXZhaWxhYmxlLCBvdGhlcndpc2UgYHNldFRpbWVvdXQoY2FsbGJhY2ssIDApYCwgd2hpY2ggbWVhbnMgb3RoZXIgaGlnaGVyCiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuCiAqCiAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciBicm93c2VyLWNvbXBhdGliaWxpdHkgcHVycG9zZXMuCiAqCiAqIEBuYW1lIG5leHRUaWNrCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBhbGlhcyBzZXRJbW1lZGlhdGUKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kCiAqIHRoZSBldmVudCBsb29wLiBJbnZva2VkIHdpdGggKGFyZ3MuLi4pLgogKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlCiAqIGNhbGxiYWNrIG9uIHRoZSBuZXh0IHRpY2suCiAqIEBleGFtcGxlCiAqCiAqIHZhciBjYWxsX29yZGVyID0gW107CiAqIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uKCkgewogKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTsKICogICAgIC8vIGNhbGxfb3JkZXIgbm93IGVxdWFscyBbJ29uZScsJ3R3byddCiAqIH0pOwogKiBjYWxsX29yZGVyLnB1c2goJ29uZScpOwogKgogKiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKGEsIGIsIGMpIHsKICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzCiAqIH0sIDEsIDIsIDMpOwogKi8KdmFyIF9kZWZlciQxOwoKaWYgKGhhc05leHRUaWNrKSB7CiAgICBfZGVmZXIkMSA9IHByb2Nlc3MubmV4dFRpY2s7Cn0gZWxzZSBpZiAoaGFzU2V0SW1tZWRpYXRlKSB7CiAgICBfZGVmZXIkMSA9IHNldEltbWVkaWF0ZTsKfSBlbHNlIHsKICAgIF9kZWZlciQxID0gZmFsbGJhY2s7Cn0KCnZhciBuZXh0VGljayA9IHdyYXAoX2RlZmVyJDEpOwoKZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICB2YXIgcmVzdWx0cyA9IGlzQXJyYXlMaWtlKHRhc2tzKSA/IFtdIDoge307CgogICAgZWFjaGZuKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5LCBjYWxsYmFjaykgewogICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpOwogICAgfSk7Cn0KCi8qKgogKiBSdW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbAogKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IG9mIHRoZSBmdW5jdGlvbnMgcGFzcyBhbiBlcnJvciB0bwogKiBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZQogKiBlcnJvci4gT25jZSB0aGUgYHRhc2tzYCBoYXZlIGNvbXBsZXRlZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWwKICogYGNhbGxiYWNrYCBhcyBhbiBhcnJheS4KICoKICogKipOb3RlOioqIGBwYXJhbGxlbGAgaXMgYWJvdXQga2lja2luZy1vZmYgSS9PIHRhc2tzIGluIHBhcmFsbGVsLCBub3QgYWJvdXQKICogcGFyYWxsZWwgZXhlY3V0aW9uIG9mIGNvZGUuICBJZiB5b3VyIHRhc2tzIGRvIG5vdCB1c2UgYW55IHRpbWVycyBvciBwZXJmb3JtCiAqIGFueSBJL08sIHRoZXkgd2lsbCBhY3R1YWxseSBiZSBleGVjdXRlZCBpbiBzZXJpZXMuICBBbnkgc3luY2hyb25vdXMgc2V0dXAKICogc2VjdGlvbnMgZm9yIGVhY2ggdGFzayB3aWxsIGhhcHBlbiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiAgSmF2YVNjcmlwdCByZW1haW5zCiAqIHNpbmdsZS10aHJlYWRlZC4KICoKICogKipIaW50OioqIFVzZSBbYHJlZmxlY3RgXXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0gdG8gY29udGludWUgdGhlCiAqIGV4ZWN1dGlvbiBvZiBvdGhlciB0YXNrcyB3aGVuIGEgdGFzayBmYWlscy4KICoKICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbAogKiBiZSBydW4gYXMgYSBmdW5jdGlvbiBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2AKICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmcKICogcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5wYXJhbGxlbH0uCiAqCiAqIEBuYW1lIHBhcmFsbGVsCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mCiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHJ1bi4KICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGUKICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBmdW5jdGlvbiBnZXRzIGEgcmVzdWx0cyBhcnJheQogKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqCiAqIEBleGFtcGxlCiAqIGFzeW5jLnBhcmFsbGVsKFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgICAgIH0sIDIwMCk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogXSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGVxdWFsIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2gKICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LgogKiB9KTsKICoKICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheQogKiBhc3luYy5wYXJhbGxlbCh7CiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBlcXVhbHMgdG86IHtvbmU6IDEsIHR3bzogMn0KICogfSk7CiAqLwpmdW5jdGlvbiBwYXJhbGxlbExpbWl0KHRhc2tzLCBjYWxsYmFjaykgewogICAgX3BhcmFsbGVsKGVhY2hPZiwgdGFza3MsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgcGFyYWxsZWxgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucGFyYWxsZWx9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSBwYXJhbGxlbExpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnBhcmFsbGVsXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucGFyYWxsZWx9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mCiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHJ1bi4KICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5CiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQkMSh0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7CiAgICBfcGFyYWxsZWwoX2VhY2hPZkxpbWl0KGxpbWl0KSwgdGFza3MsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIEEgcXVldWUgb2YgdGFza3MgZm9yIHRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuCiAqIEB0eXBlZGVmIHtPYmplY3R9IFF1ZXVlT2JqZWN0CiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtcwogKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLmxlbmd0aCgpYC4KICogQHByb3BlcnR5IHtib29sZWFufSBzdGFydGVkIC0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgYW55CiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJ1bm5pbmcgLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zCiAqIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5ydW5uaW5nKClgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtcwogKiBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUud29ya2Vyc0xpc3QoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGlkbGUgLSBhIGZ1bmN0aW9uIHJldHVybmluZyBmYWxzZSBpZiB0aGVyZSBhcmUgaXRlbXMKICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC4KICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gYW4gaW50ZWdlciBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkgYHdvcmtlcmAKICogZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGNoYW5nZWQgYWZ0ZXIgYQogKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHB1c2ggLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgYHF1ZXVlYC4gQ2FsbHMgYGNhbGxiYWNrYAogKiBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhIHNpbmdsZSB0YXNrLAogKiBhIGB0YXNrc2AgYXJyYXkgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMgdXNlZCBmb3IgZXZlcnkKICogdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIHdpdGggYHF1ZXVlLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLAogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1bnNoaWZ0IC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGZyb250IG9mIHRoZSBgcXVldWVgLgogKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlbW92ZSAtIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBxdWV1ZSB0aGF0IG1hdGNoIGEgdGVzdAogKiBmdW5jdGlvbi4gIFRoZSB0ZXN0IGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFuIG9iamVjdCB3aXRoIGEgYGRhdGFgIHByb3BlcnR5LAogKiBhbmQgYSBgcHJpb3JpdHlgIHByb3BlcnR5LCBpZiB0aGlzIGlzIGEKICogW3ByaW9yaXR5UXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wcmlvcml0eVF1ZXVlfSBvYmplY3QuCiAqIEludm9rZWQgd2l0aCBgcXVldWUucmVtb3ZlKHRlc3RGbilgLCB3aGVyZSBgdGVzdEZuYCBpcyBvZiB0aGUgZm9ybQogKiBgZnVuY3Rpb24gKHtkYXRhLCBwcmlvcml0eX0pIHt9YCBhbmQgcmV0dXJucyBhIEJvb2xlYW4uCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHNhdHVyYXRlZCAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyIG9mCiAqIHJ1bm5pbmcgd29ya2VycyBoaXRzIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0LCBhbmQgZnVydGhlciB0YXNrcyB3aWxsIGJlCiAqIHF1ZXVlZC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdW5zYXR1cmF0ZWQgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIG51bWJlcgogKiBvZiBydW5uaW5nIHdvcmtlcnMgaXMgbGVzcyB0aGFuIHRoZSBgY29uY3VycmVuY3lgICYgYGJ1ZmZlcmAgbGltaXRzLCBhbmQKICogZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuCiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBidWZmZXIgLSBBIG1pbmltdW0gdGhyZXNob2xkIGJ1ZmZlciBpbiBvcmRlciB0byBzYXkgdGhhdAogKiB0aGUgYHF1ZXVlYCBpcyBgdW5zYXR1cmF0ZWRgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtCiAqIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZHJhaW4gLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGxhc3QgaXRlbQogKiBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZXJyb3IgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSB0YXNrIGVycm9ycy4KICogSGFzIHRoZSBzaWduYXR1cmUgYGZ1bmN0aW9uKGVycm9yLCB0YXNrKWAuCiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpcwogKiBpbiBhIHBhdXNlZCBzdGF0ZS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcGF1c2UgLSBhIGZ1bmN0aW9uIHRoYXQgcGF1c2VzIHRoZSBwcm9jZXNzaW5nIG9mIHRhc2tzCiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlc3VtZSAtIGEgZnVuY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mCiAqIHF1ZXVlZCB0YXNrcyB3aGVuIHRoZSBxdWV1ZSBpcyBwYXVzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5yZXN1bWUoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmQKICogZW1wdGllcyByZW1haW5pbmcgdGFza3MgZnJvbSB0aGUgcXVldWUgZm9yY2luZyBpdCB0byBnbyBpZGxlLiBObyBtb3JlIHRhc2tzCiAqIHNob3VsZCBiZSBwdXNoZWQgdG8gdGhlIHF1ZXVlIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4gSW52b2tlIHdpdGggYHF1ZXVlLmtpbGwoKWAuCiAqLwoKLyoqCiAqIENyZWF0ZXMgYSBgcXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYGNvbmN1cnJlbmN5YC4gVGFza3MgYWRkZWQgdG8gdGhlCiAqIGBxdWV1ZWAgYXJlIHByb2Nlc3NlZCBpbiBwYXJhbGxlbCAodXAgdG8gdGhlIGBjb25jdXJyZW5jeWAgbGltaXQpLiBJZiBhbGwKICogYHdvcmtlcmBzIGFyZSBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIG9uZSBiZWNvbWVzIGF2YWlsYWJsZS4KICogT25jZSBhIGB3b3JrZXJgIGNvbXBsZXRlcyBhIGB0YXNrYCwgdGhhdCBgdGFza2AncyBjYWxsYmFjayBpcyBjYWxsZWQuCiAqCiAqIEBuYW1lIHF1ZXVlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLgogKiBJZiB5b3Ugd2FudCB0byBoYW5kbGUgZXJyb3JzIGZyb20gYW4gaW5kaXZpZHVhbCB0YXNrLCBwYXNzIGEgY2FsbGJhY2sgdG8KICogYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9MV0gLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55CiAqIGB3b3JrZXJgIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5CiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi4KICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBxdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhbgogKiBhdHRhY2hlZCBhcyBjZXJ0YWluIHByb3BlcnRpZXMgdG8gbGlzdGVuIGZvciBzcGVjaWZpYyBldmVudHMgZHVyaW5nIHRoZQogKiBsaWZlY3ljbGUgb2YgdGhlIHF1ZXVlLgogKiBAZXhhbXBsZQogKgogKiAvLyBjcmVhdGUgYSBxdWV1ZSBvYmplY3Qgd2l0aCBjb25jdXJyZW5jeSAyCiAqIHZhciBxID0gYXN5bmMucXVldWUoZnVuY3Rpb24odGFzaywgY2FsbGJhY2spIHsKICogICAgIGNvbnNvbGUubG9nKCdoZWxsbyAnICsgdGFzay5uYW1lKTsKICogICAgIGNhbGxiYWNrKCk7CiAqIH0sIDIpOwogKgogKiAvLyBhc3NpZ24gYSBjYWxsYmFjawogKiBxLmRyYWluID0gZnVuY3Rpb24oKSB7CiAqICAgICBjb25zb2xlLmxvZygnYWxsIGl0ZW1zIGhhdmUgYmVlbiBwcm9jZXNzZWQnKTsKICogfTsKICoKICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIHF1ZXVlCiAqIHEucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpOwogKiB9KTsKICogcS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpOwogKiB9KTsKICoKICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIHF1ZXVlIChiYXRjaC13aXNlKQogKiBxLnB1c2goW3tuYW1lOiAnYmF6J30se25hbWU6ICdiYXknfSx7bmFtZTogJ2JheCd9XSwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBpdGVtJyk7CiAqIH0pOwogKgogKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlCiAqIHEudW5zaGlmdCh7bmFtZTogJ2Jhcid9LCBmdW5jdGlvbiAoZXJyKSB7CiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTsKICogfSk7CiAqLwp2YXIgcXVldWUkMSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7CiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpOwogICAgcmV0dXJuIHF1ZXVlKGZ1bmN0aW9uIChpdGVtcywgY2IpIHsKICAgICAgICBfd29ya2VyKGl0ZW1zWzBdLCBjYik7CiAgICB9LCBjb25jdXJyZW5jeSwgMSk7Cn07CgovKioKICogVGhlIHNhbWUgYXMgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IG9ubHkgdGFza3MgYXJlIGFzc2lnbmVkIGEgcHJpb3JpdHkgYW5kCiAqIGNvbXBsZXRlZCBpbiBhc2NlbmRpbmcgcHJpb3JpdHkgb3JkZXIuCiAqCiAqIEBuYW1lIHByaW9yaXR5UXVldWUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGEgcXVldWVkIHRhc2suCiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0bwogKiBgcS5wdXNoKClgLgogKiBJbnZva2VkIHdpdGggKHRhc2ssIGNhbGxiYWNrKS4KICogQHBhcmFtIHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSBgd29ya2VyYAogKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeSBkZWZhdWx0cyB0bwogKiBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uCiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcHJpb3JpdHlRdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gVGhlcmUgYXJlIHR3bwogKiBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBxdWV1ZWAgYW5kIGBwcmlvcml0eVF1ZXVlYCBvYmplY3RzOgogKiAqIGBwdXNoKHRhc2ssIHByaW9yaXR5LCBbY2FsbGJhY2tdKWAgLSBgcHJpb3JpdHlgIHNob3VsZCBiZSBhIG51bWJlci4gSWYgYW4KICogICBhcnJheSBvZiBgdGFza3NgIGlzIGdpdmVuLCBhbGwgdGFza3Mgd2lsbCBiZSBhc3NpZ25lZCB0aGUgc2FtZSBwcmlvcml0eS4KICogKiBUaGUgYHVuc2hpZnRgIG1ldGhvZCB3YXMgcmVtb3ZlZC4KICovCnZhciBwcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24od29ya2VyLCBjb25jdXJyZW5jeSkgewogICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZQogICAgdmFyIHEgPSBxdWV1ZSQxKHdvcmtlciwgY29uY3VycmVuY3kpOwoKICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5CiAgICBxLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHsKICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgY2FsbGJhY2sgPSBub29wOwogICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpOwogICAgICAgIH0KICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlOwogICAgICAgIGlmICghaXNBcnJheShkYXRhKSkgewogICAgICAgICAgICBkYXRhID0gW2RhdGFdOwogICAgICAgIH0KICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3MKICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcS5kcmFpbigpOwogICAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDsKICAgICAgICB2YXIgbmV4dE5vZGUgPSBxLl90YXNrcy5oZWFkOwogICAgICAgIHdoaWxlIChuZXh0Tm9kZSAmJiBwcmlvcml0eSA+PSBuZXh0Tm9kZS5wcmlvcml0eSkgewogICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHQ7CiAgICAgICAgfQoKICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBpdGVtID0gewogICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXSwKICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSwKICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjawogICAgICAgICAgICB9OwoKICAgICAgICAgICAgaWYgKG5leHROb2RlKSB7CiAgICAgICAgICAgICAgICBxLl90YXNrcy5pbnNlcnRCZWZvcmUobmV4dE5vZGUsIGl0ZW0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpOwogICAgfTsKCiAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvbgogICAgZGVsZXRlIHEudW5zaGlmdDsKCiAgICByZXR1cm4gcTsKfTsKCi8qKgogKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZQogKiBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBPbmNlIGFueSBvZiB0aGUgYHRhc2tzYCBjb21wbGV0ZSBvciBwYXNzIGFuCiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQuIEl0J3MKICogZXF1aXZhbGVudCB0byBgUHJvbWlzZS5yYWNlKClgLgogKgogKiBAbmFtZSByYWNlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBjb250YWluaW5nIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259CiAqIHRvIHJ1bi4gRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFueSBvZiB0aGUgZnVuY3Rpb25zIGhhdmUKICogY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYW4gZXJyb3Igb3IgcmVzdWx0IGZyb20gdGhlIGZpcnN0IGZ1bmN0aW9uIHRoYXQKICogY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnJhY2UoWwogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiBdLAogKiAvLyBtYWluIGNhbGxiYWNrCiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyB0aGUgcmVzdWx0IHdpbGwgYmUgZXF1YWwgdG8gJ3R3bycgYXMgaXQgZmluaXNoZXMgZWFybGllcgogKiB9KTsKICovCmZ1bmN0aW9uIHJhY2UodGFza3MsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICBpZiAoIWlzQXJyYXkodGFza3MpKSByZXR1cm4gY2FsbGJhY2sobmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gcmFjZSBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTsKICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTsKICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgd3JhcEFzeW5jKHRhc2tzW2ldKShjYWxsYmFjayk7CiAgICB9Cn0KCi8qKgogKiBTYW1lIGFzIFtgcmVkdWNlYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX0sIG9ubHkgb3BlcmF0ZXMgb24gYGFycmF5YCBpbiByZXZlcnNlIG9yZGVyLgogKgogKiBAbmFtZSByZWR1Y2VSaWdodAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5yZWR1Y2Vde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWR1Y2V9CiAqIEBhbGlhcyBmb2xkcgogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZQogKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi4KICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4KICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlCiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuCiAqIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHQpLgogKi8KZnVuY3Rpb24gcmVkdWNlUmlnaHQgKGFycmF5LCBtZW1vLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciByZXZlcnNlZCA9IHNsaWNlKGFycmF5KS5yZXZlcnNlKCk7CiAgICByZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBXcmFwcyB0aGUgYXN5bmMgZnVuY3Rpb24gaW4gYW5vdGhlciBmdW5jdGlvbiB0aGF0IGFsd2F5cyBjb21wbGV0ZXMgd2l0aCBhCiAqIHJlc3VsdCBvYmplY3QsIGV2ZW4gd2hlbiBpdCBlcnJvcnMuCiAqCiAqIFRoZSByZXN1bHQgb2JqZWN0IGhhcyBlaXRoZXIgdGhlIHByb3BlcnR5IGBlcnJvcmAgb3IgYHZhbHVlYC4KICoKICogQG5hbWUgcmVmbGVjdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHlvdSB3YW50IHRvIHdyYXAKICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcGFzc2VzIG51bGwgdG8gaXQncyBjYWxsYmFjayBhcwogKiB0aGUgZXJyb3IuIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIHdpbGwgYmUgYW4gYG9iamVjdGAgd2l0aAogKiBlaXRoZXIgYW4gYGVycm9yYCBvciBhIGB2YWx1ZWAgcHJvcGVydHkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnBhcmFsbGVsKFsKICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTsKICogICAgIH0pLAogKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uCiAqICAgICAgICAgY2FsbGJhY2soJ2JhZCBzdHVmZiBoYXBwZW5lZCcpOwogKiAgICAgfSksCiAqICAgICBhc3luYy5yZWZsZWN0KGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgIH0pCiAqIF0sCiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrCiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gdmFsdWVzCiAqICAgICAvLyByZXN1bHRzWzBdLnZhbHVlID0gJ29uZScKICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSAnYmFkIHN0dWZmIGhhcHBlbmVkJwogKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nCiAqIH0pOwogKi8KZnVuY3Rpb24gcmVmbGVjdChmbikgewogICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7CiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiByZWZsZWN0T24oYXJncywgcmVmbGVjdENhbGxiYWNrKSB7CiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCBjYkFyZykgewogICAgICAgICAgICBpZiAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIHJlZmxlY3RDYWxsYmFjayhudWxsLCB7IGVycm9yOiBlcnJvciB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhciB2YWx1ZTsKICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIpIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNiQXJnOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZWZsZWN0Q2FsbGJhY2sobnVsbCwgeyB2YWx1ZTogdmFsdWUgfSk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKCiAgICAgICAgcmV0dXJuIF9mbi5hcHBseSh0aGlzLCBhcmdzKTsKICAgIH0pOwp9CgpmdW5jdGlvbiByZWplY3QkMShlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBfZmlsdGVyKGVhY2hmbiwgYXJyLCBmdW5jdGlvbih2YWx1ZSwgY2IpIHsKICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24oZXJyLCB2KSB7CiAgICAgICAgICAgIGNiKGVyciwgIXYpOwogICAgICAgIH0pOwogICAgfSwgY2FsbGJhY2spOwp9CgovKioKICogVGhlIG9wcG9zaXRlIG9mIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0uIFJlbW92ZXMgdmFsdWVzIHRoYXQgcGFzcyBhbiBgYXN5bmNgIHRydXRoIHRlc3QuCiAqCiAqIEBuYW1lIHJlamVjdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIGByZXN1bHRgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5yZWplY3QoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7CiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIG5vdyBlcXVhbHMgYW4gYXJyYXkgb2YgbWlzc2luZyBmaWxlcwogKiAgICAgY3JlYXRlRmlsZXMocmVzdWx0cyk7CiAqIH0pOwogKi8KdmFyIHJlamVjdCA9IGRvUGFyYWxsZWwocmVqZWN0JDEpOwoKLyoqCiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB3aXRoIGByZWZsZWN0YC4KICoKICogQG5hbWUgcmVmbGVjdEFsbAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5yZWZsZWN0XXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0KICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtBcnJheXxPYmplY3R8SXRlcmFibGV9IHRhc2tzIC0gVGhlIGNvbGxlY3Rpb24gb2YKICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gd3JhcCBpbiBgYXN5bmMucmVmbGVjdGAuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBhc3luYyBmdW5jdGlvbnMsIGVhY2ggd3JhcHBlZCBpbgogKiBgYXN5bmMucmVmbGVjdGAKICogQGV4YW1wbGUKICoKICogbGV0IHRhc2tzID0gWwogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdiYWQgc3R1ZmYgaGFwcGVuZWQnKSk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogXTsKICoKICogYXN5bmMucGFyYWxsZWwoYXN5bmMucmVmbGVjdEFsbCh0YXNrcyksCiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrCiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gdmFsdWVzCiAqICAgICAvLyByZXN1bHRzWzBdLnZhbHVlID0gJ29uZScKICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykKICogICAgIC8vIHJlc3VsdHNbMl0udmFsdWUgPSAndHdvJwogKiB9KTsKICoKICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheQogKiBsZXQgdGFza3MgPSB7CiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgICAgIH0sIDIwMCk7CiAqICAgICB9LAogKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKCd0d28nKTsKICogICAgIH0sCiAqICAgICB0aHJlZTogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiB9OwogKgogKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyB2YWx1ZXMKICogICAgIC8vIHJlc3VsdHMub25lLnZhbHVlID0gJ29uZScKICogICAgIC8vIHJlc3VsdHMudHdvLmVycm9yID0gJ3R3bycKICogICAgIC8vIHJlc3VsdHMudGhyZWUudmFsdWUgPSAndGhyZWUnCiAqIH0pOwogKi8KZnVuY3Rpb24gcmVmbGVjdEFsbCh0YXNrcykgewogICAgdmFyIHJlc3VsdHM7CiAgICBpZiAoaXNBcnJheSh0YXNrcykpIHsKICAgICAgICByZXN1bHRzID0gYXJyYXlNYXAodGFza3MsIHJlZmxlY3QpOwogICAgfSBlbHNlIHsKICAgICAgICByZXN1bHRzID0ge307CiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24odGFzaywga2V5KSB7CiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlZmxlY3QuY2FsbCh0aGlzLCB0YXNrKTsKICAgICAgICB9KTsKICAgIH0KICAgIHJldHVybiByZXN1bHRzOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2ByZWplY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgcmVqZWN0TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmVqZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIGByZXN1bHRgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIHJlamVjdExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KHJlamVjdCQxKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHJlamVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgcmVqZWN0U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnJlamVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgcmVqZWN0U2VyaWVzID0gZG9MaW1pdChyZWplY3RMaW1pdCwgMSk7CgovKioKICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAyLjQuMAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi4KICogQGV4YW1wbGUKICoKICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpOwogKgogKiBjb25zb2xlLmxvZyhvYmplY3RzKTsKICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dCiAqCiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pOwogKiAvLyA9PiB0cnVlCiAqLwpmdW5jdGlvbiBjb25zdGFudCQxKHZhbHVlKSB7CiAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHZhbHVlOwogIH07Cn0KCi8qKgogKiBBdHRlbXB0cyB0byBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gYHRhc2tgIG5vIG1vcmUgdGhhbiBgdGltZXNgIHRpbWVzCiAqIGJlZm9yZSByZXR1cm5pbmcgYW4gZXJyb3IuIElmIHRoZSB0YXNrIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmUKICogcGFzc2VkIHRoZSByZXN1bHQgb2YgdGhlIHN1Y2Nlc3NmdWwgdGFzay4gSWYgYWxsIGF0dGVtcHRzIGZhaWwsIHRoZSBjYWxsYmFjawogKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC4KICoKICogQG5hbWUgcmV0cnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAc2VlIFthc3luYy5yZXRyeWFibGVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeWFibGV9CiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdHMgPSB7dGltZXM6IDUsIGludGVydmFsOiAwfXwgNV0gLSBDYW4gYmUgZWl0aGVyIGFuCiAqIG9iamVjdCB3aXRoIGB0aW1lc2AgYW5kIGBpbnRlcnZhbGAgb3IgYSBudW1iZXIuCiAqICogYHRpbWVzYCAtIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gbWFrZSBiZWZvcmUgZ2l2aW5nIHVwLiAgVGhlIGRlZmF1bHQKICogICBpcyBgNWAuCiAqICogYGludGVydmFsYCAtIFRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiByZXRyaWVzLCBpbiBtaWxsaXNlY29uZHMuICBUaGUKICogICBkZWZhdWx0IGlzIGAwYC4gVGhlIGludGVydmFsIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uIG9mIHRoZQogKiAgIHJldHJ5IGNvdW50IChzZWUgZXhhbXBsZSkuCiAqICogYGVycm9yRmlsdGVyYCAtIEFuIG9wdGlvbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBvbgogKiAgIGVycm9uZW91cyByZXN1bHQuIElmIGl0IHJldHVybnMgYHRydWVgIHRoZSByZXRyeSBhdHRlbXB0cyB3aWxsIGNvbnRpbnVlOwogKiAgIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAgdGhlIHJldHJ5IGZsb3cgaXMgYWJvcnRlZCB3aXRoIHRoZSBjdXJyZW50CiAqICAgYXR0ZW1wdCdzIGVycm9yIGFuZCByZXN1bHQgYmVpbmcgcmV0dXJuZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrLgogKiAgIEludm9rZWQgd2l0aCAoZXJyKS4KICogKiBJZiBgb3B0c2AgaXMgYSBudW1iZXIsIHRoZSBudW1iZXIgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnksCiAqICAgd2l0aCB0aGUgZGVmYXVsdCBpbnRlcnZhbCBvZiBgMGAuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIHJldHJ5LgogKiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZQogKiB0YXNrIGhhcyBzdWNjZWVkZWQsIG9yIGFmdGVyIHRoZSBmaW5hbCBmYWlsZWQgYXR0ZW1wdC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgCiAqIGFuZCBgcmVzdWx0YCBhcmd1bWVudHMgb2YgdGhlIGxhc3QgYXR0ZW1wdCBhdCBjb21wbGV0aW5nIHRoZSBgdGFza2AuIEludm9rZWQKICogd2l0aCAoZXJyLCByZXN1bHRzKS4KICoKICogQGV4YW1wbGUKICoKICogLy8gVGhlIGByZXRyeWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYSBzdGFuZC1hbG9uZSBjb250cm9sIGZsb3cgYnkgcGFzc2luZwogKiAvLyBhIGNhbGxiYWNrLCBhcyBzaG93biBiZWxvdzoKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMKICogYXN5bmMucmV0cnkoMywgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdAogKiB9KTsKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMsIHdhaXRpbmcgMjAwIG1zIGJldHdlZW4gZWFjaCByZXRyeQogKiBhc3luYy5yZXRyeSh7dGltZXM6IDMsIGludGVydmFsOiAyMDB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMTAgdGltZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmCiAqIC8vIChpLmUuIGludGVydmFscyBvZiAxMDAsIDIwMCwgNDAwLCA4MDAsIDE2MDAsIC4uLiBtaWxsaXNlY29uZHMpCiAqIGFzeW5jLnJldHJ5KHsKICogICB0aW1lczogMTAsCiAqICAgaW50ZXJ2YWw6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHsKICogICAgIHJldHVybiA1MCAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpOwogKiAgIH0KICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdAogKiB9KTsKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIHRoZSBkZWZhdWx0IDUgdGltZXMgbm8gZGVsYXkgYmV0d2VlbiBlYWNoIHJldHJ5CiAqIGFzeW5jLnJldHJ5KGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHQKICogfSk7CiAqCiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCBvbmx5IHdoZW4gZXJyb3IgY29uZGl0aW9uIHNhdGlzZmllcywgYWxsIG90aGVyCiAqIC8vIGVycm9ycyB3aWxsIGFib3J0IHRoZSByZXRyeSBjb250cm9sIGZsb3cgYW5kIHJldHVybiB0byBmaW5hbCBjYWxsYmFjawogKiBhc3luYy5yZXRyeSh7CiAqICAgZXJyb3JGaWx0ZXI6IGZ1bmN0aW9uKGVycikgewogKiAgICAgcmV0dXJuIGVyci5tZXNzYWdlID09PSAnVGVtcG9yYXJ5IGVycm9yJzsgLy8gb25seSByZXRyeSBvbiBhIHNwZWNpZmljIGVycm9yCiAqICAgfQogKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyBJdCBjYW4gYWxzbyBiZSBlbWJlZGRlZCB3aXRoaW4gb3RoZXIgY29udHJvbCBmbG93IGZ1bmN0aW9ucyB0byByZXRyeQogKiAvLyBpbmRpdmlkdWFsIG1ldGhvZHMgdGhhdCBhcmUgbm90IGFzIHJlbGlhYmxlLCBsaWtlIHRoaXM6CiAqIGFzeW5jLmF1dG8oewogKiAgICAgdXNlcnM6IGFwaS5nZXRVc2Vycy5iaW5kKGFwaSksCiAqICAgICBwYXltZW50czogYXN5bmMucmV0cnlhYmxlKDMsIGFwaS5nZXRQYXltZW50cy5iaW5kKGFwaSkpCiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdHMKICogfSk7CiAqCiAqLwpmdW5jdGlvbiByZXRyeShvcHRzLCB0YXNrLCBjYWxsYmFjaykgewogICAgdmFyIERFRkFVTFRfVElNRVMgPSA1OwogICAgdmFyIERFRkFVTFRfSU5URVJWQUwgPSAwOwoKICAgIHZhciBvcHRpb25zID0gewogICAgICAgIHRpbWVzOiBERUZBVUxUX1RJTUVTLAogICAgICAgIGludGVydmFsRnVuYzogY29uc3RhbnQkMShERUZBVUxUX0lOVEVSVkFMKQogICAgfTsKCiAgICBmdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCkgewogICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgYWNjLnRpbWVzID0gK3QudGltZXMgfHwgREVGQVVMVF9USU1FUzsKCiAgICAgICAgICAgIGFjYy5pbnRlcnZhbEZ1bmMgPSB0eXBlb2YgdC5pbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/CiAgICAgICAgICAgICAgICB0LmludGVydmFsIDoKICAgICAgICAgICAgICAgIGNvbnN0YW50JDEoK3QuaW50ZXJ2YWwgfHwgREVGQVVMVF9JTlRFUlZBTCk7CgogICAgICAgICAgICBhY2MuZXJyb3JGaWx0ZXIgPSB0LmVycm9yRmlsdGVyOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0ID09PSAnc3RyaW5nJykgewogICAgICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5Iik7CiAgICAgICAgfQogICAgfQoKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBub29wOwogICAgICAgIHRhc2sgPSBvcHRzOwogICAgfSBlbHNlIHsKICAgICAgICBwYXJzZVRpbWVzKG9wdGlvbnMsIG9wdHMpOwogICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIH0KCiAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeSIpOwogICAgfQoKICAgIHZhciBfdGFzayA9IHdyYXBBc3luYyh0YXNrKTsKCiAgICB2YXIgYXR0ZW1wdCA9IDE7CiAgICBmdW5jdGlvbiByZXRyeUF0dGVtcHQoKSB7CiAgICAgICAgX3Rhc2soZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJgogICAgICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zLmVycm9yRmlsdGVyICE9ICdmdW5jdGlvbicgfHwKICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yRmlsdGVyKGVycikpKSB7CiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgfQoKICAgIHJldHJ5QXR0ZW1wdCgpOwp9CgovKioKICogQSBjbG9zZSByZWxhdGl2ZSBvZiBbYHJldHJ5YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fS4gIFRoaXMgbWV0aG9kCiAqIHdyYXBzIGEgdGFzayBhbmQgbWFrZXMgaXQgcmV0cnlhYmxlLCByYXRoZXIgdGhhbiBpbW1lZGlhdGVseSBjYWxsaW5nIGl0CiAqIHdpdGggcmV0cmllcy4KICoKICogQG5hbWUgcmV0cnlhYmxlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnJldHJ5XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIG9wdGlvbmFsCiAqIG9wdGlvbnMsIGV4YWN0bHkgdGhlIHNhbWUgYXMgZnJvbSBgcmV0cnlgCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gdG8gd3JhcC4KICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgd3JhcHBlci4KICogSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjaykuCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbiwgd2hpY2ggd2hlbiBpbnZva2VkLCB3aWxsCiAqIHJldHJ5IG9uIGFuIGVycm9yLCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gYG9wdHNgLgogKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWNjZXB0IHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgYHRhc2tgLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5hdXRvKHsKICogICAgIGRlcDE6IGFzeW5jLnJldHJ5YWJsZSgzLCBnZXRGcm9tRmxha3lTZXJ2aWNlKSwKICogICAgIHByb2Nlc3M6IFsiZGVwMSIsIGFzeW5jLnJldHJ5YWJsZSgzLCBmdW5jdGlvbiAocmVzdWx0cywgY2IpIHsKICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpOwogKiAgICAgfSldCiAqIH0sIGNhbGxiYWNrKTsKICovCnZhciByZXRyeWFibGUgPSBmdW5jdGlvbiAob3B0cywgdGFzaykgewogICAgaWYgKCF0YXNrKSB7CiAgICAgICAgdGFzayA9IG9wdHM7CiAgICAgICAgb3B0cyA9IG51bGw7CiAgICB9CiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7CiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHsKICAgICAgICBmdW5jdGlvbiB0YXNrRm4oY2IpIHsKICAgICAgICAgICAgX3Rhc2suYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2IpKTsKICAgICAgICB9CgogICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTsKICAgICAgICBlbHNlIHJldHJ5KHRhc2tGbiwgY2FsbGJhY2spOwoKICAgIH0pOwp9OwoKLyoqCiAqIFJ1biB0aGUgZnVuY3Rpb25zIGluIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gaW4gc2VyaWVzLCBlYWNoIG9uZSBydW5uaW5nIG9uY2UKICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBmdW5jdGlvbnMgaW4gdGhlIHNlcmllcyBwYXNzIGFuCiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgbm8gbW9yZSBmdW5jdGlvbnMgYXJlIHJ1biwgYW5kIGBjYWxsYmFja2AgaXMKICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBlcnJvci4gT3RoZXJ3aXNlLCBgY2FsbGJhY2tgCiAqIHJlY2VpdmVzIGFuIGFycmF5IG9mIHJlc3VsdHMgd2hlbiBgdGFza3NgIGhhdmUgY29tcGxldGVkLgogKgogKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsCiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2AKICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmcKICogIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMuc2VyaWVzfS4KICoKICogKipOb3RlKiogdGhhdCB3aGlsZSBtYW55IGltcGxlbWVudGF0aW9ucyBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygb2JqZWN0CiAqIHByb3BlcnRpZXMsIHRoZSBbRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC42KQogKiBleHBsaWNpdGx5IHN0YXRlcyB0aGF0CiAqCiAqID4gVGhlIG1lY2hhbmljcyBhbmQgb3JkZXIgb2YgZW51bWVyYXRpbmcgdGhlIHByb3BlcnRpZXMgaXMgbm90IHNwZWNpZmllZC4KICoKICogU28gaWYgeW91IHJlbHkgb24gdGhlIG9yZGVyIGluIHdoaWNoIHlvdXIgc2VyaWVzIG9mIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQsCiAqIGFuZCB3YW50IHRoaXMgdG8gd29yayBvbiBhbGwgcGxhdGZvcm1zLCBjb25zaWRlciB1c2luZyBhbiBhcnJheS4KICoKICogQG5hbWUgc2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcKICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy4KICogRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGUKICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpCiAqIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgYHRhc2tgIGNhbGxiYWNrcy4gSW52b2tlZAogKiB3aXRoIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqIGFzeW5jLnNlcmllcyhbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgIH0KICogXSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBlcXVhbCB0byBbJ29uZScsICd0d28nXQogKiB9KTsKICoKICogYXN5bmMuc2VyaWVzKHsKICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpOwogKiAgICAgICAgIH0sIDEwMCk7CiAqICAgICB9CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgZXF1YWwgdG86IHtvbmU6IDEsIHR3bzogMn0KICogfSk7CiAqLwpmdW5jdGlvbiBzZXJpZXModGFza3MsIGNhbGxiYWNrKSB7CiAgICBfcGFyYWxsZWwoZWFjaE9mU2VyaWVzLCB0YXNrcywgY2FsbGJhY2spOwp9CgovKioKICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC4KICogSWYgYW55IGl0ZXJhdGVlIGNhbGwgcmV0dXJucyBgdHJ1ZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkKICogY2FsbGVkLgogKgogKiBAbmFtZSBzb21lCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBhbnkKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLgogKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jCiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuc29tZShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHsKICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycikKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbGVzIGV4aXN0cwogKiB9KTsKICovCnZhciBzb21lID0gZG9QYXJhbGxlbChfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIGlkZW50aXR5KSk7CgovKioKICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBzb21lTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9CiAqIEBhbGlhcyBhbnlMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueQogKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYwogKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgc29tZUxpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgaWRlbnRpdHkpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBzb21lU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnNvbWVde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfQogKiBAYWxpYXMgYW55U2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBzZXJpZXMuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMKICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KdmFyIHNvbWVTZXJpZXMgPSBkb0xpbWl0KHNvbWVMaW1pdCwgMSk7CgovKioKICogU29ydHMgYSBsaXN0IGJ5IHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBgY29sbGAgdmFsdWUgdGhyb3VnaCBhbiBhc3luYwogKiBgaXRlcmF0ZWVgLgogKgogKiBAbmFtZSBzb3J0QnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgdmFsdWUgdG8gdXNlIGFzIHRoZSBzb3J0IGNyaXRlcmlhIGFzCiAqIGl0cyBgcmVzdWx0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgdGhlIGl0ZW1zCiAqIGZyb20gdGhlIG9yaWdpbmFsIGBjb2xsYCBzb3J0ZWQgYnkgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgYGl0ZXJhdGVlYAogKiBjYWxscy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5zb3J0QnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHsKICogICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0cykgewogKiAgICAgICAgIGNhbGxiYWNrKGVyciwgc3RhdHMubXRpbWUpOwogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieQogKiAgICAgLy8gbW9kaWZpZWQgZGF0ZQogKiB9KTsKICoKICogLy8gQnkgbW9kaWZ5aW5nIHRoZSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhlCiAqIC8vIHNvcnRpbmcgb3JkZXIgY2FuIGJlIGluZmx1ZW5jZWQ6CiAqCiAqIC8vIGFzY2VuZGluZyBvcmRlcgogKiBhc3luYy5zb3J0QnkoWzEsOSwzLDVdLCBmdW5jdGlvbih4LCBjYWxsYmFjaykgewogKiAgICAgY2FsbGJhY2sobnVsbCwgeCk7CiAqIH0sIGZ1bmN0aW9uKGVycixyZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBjYWxsYmFjawogKiB9KTsKICoKICogLy8gZGVzY2VuZGluZyBvcmRlcgogKiBhc3luYy5zb3J0QnkoWzEsOSwzLDVdLCBmdW5jdGlvbih4LCBjYWxsYmFjaykgewogKiAgICAgY2FsbGJhY2sobnVsbCwgeCotMSk7ICAgIC8vPC0geCotMSBpbnN0ZWFkIG9mIHgsIHR1cm5zIHRoZSBvcmRlciBhcm91bmQKICogfSwgZnVuY3Rpb24oZXJyLHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrCiAqIH0pOwogKi8KZnVuY3Rpb24gc29ydEJ5IChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgbWFwKGNvbGwsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykgewogICAgICAgIF9pdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkgewogICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoY29tcGFyYXRvciksIGJhc2VQcm9wZXJ0eSgndmFsdWUnKSkpOwogICAgfSk7CgogICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkgewogICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhOwogICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDsKICAgIH0KfQoKLyoqCiAqIFNldHMgYSB0aW1lIGxpbWl0IG9uIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGNhbGwKICogaXRzIGNhbGxiYWNrIHdpdGhpbiB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcywgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhCiAqIHRpbWVvdXQgZXJyb3IuIFRoZSBjb2RlIHByb3BlcnR5IGZvciB0aGUgZXJyb3Igb2JqZWN0IHdpbGwgYmUgYCdFVElNRURPVVQnYC4KICoKICogQG5hbWUgdGltZW91dAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGFzeW5jRm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gbGltaXQgaW4gdGltZS4KICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIFRoZSBzcGVjaWZpZWQgdGltZSBsaW1pdC4KICogQHBhcmFtIHsqfSBbaW5mb10gLSBBbnkgdmFyaWFibGUgeW91IHdhbnQgYXR0YWNoZWQgKGBzdHJpbmdgLCBgb2JqZWN0YCwgZXRjKQogKiB0byB0aW1lb3V0IEVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLi4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBhbnkKICogb2YgdGhlIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuCiAqIEludm9rZSB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB5b3Ugd291bGQgYGFzeW5jRnVuY2AuCiAqIEBleGFtcGxlCiAqCiAqIGZ1bmN0aW9uIG15RnVuY3Rpb24oZm9vLCBjYWxsYmFjaykgewogKiAgICAgZG9Bc3luY1Rhc2soZm9vLCBmdW5jdGlvbihlcnIsIGRhdGEpIHsKICogICAgICAgICAvLyBoYW5kbGUgZXJyb3JzCiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAqCiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi4KICoKICogICAgICAgICAvLyByZXR1cm4gcHJvY2Vzc2VkIGRhdGEKICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7CiAqICAgICB9KTsKICogfQogKgogKiB2YXIgd3JhcHBlZCA9IGFzeW5jLnRpbWVvdXQobXlGdW5jdGlvbiwgMTAwMCk7CiAqCiAqIC8vIGNhbGwgYHdyYXBwZWRgIGFzIHlvdSB3b3VsZCBgbXlGdW5jdGlvbmAKICogd3JhcHBlZCh7IGJhcjogJ2JhcicgfSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7CiAqICAgICAvLyBpZiBgbXlGdW5jdGlvbmAgdGFrZXMgPCAxMDAwIG1zIHRvIGV4ZWN1dGUsIGBlcnJgCiAqICAgICAvLyBhbmQgYGRhdGFgIHdpbGwgaGF2ZSB0aGVpciBleHBlY3RlZCB2YWx1ZXMKICoKICogICAgIC8vIGVsc2UgYGVycmAgd2lsbCBiZSBhbiBFcnJvciB3aXRoIHRoZSBjb2RlICdFVElNRURPVVQnCiAqIH0pOwogKi8KZnVuY3Rpb24gdGltZW91dChhc3luY0ZuLCBtaWxsaXNlY29uZHMsIGluZm8pIHsKICAgIHZhciBmbiA9IHdyYXBBc3luYyhhc3luY0ZuKTsKCiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgdGltZWRPdXQgPSBmYWxzZTsKICAgICAgICB2YXIgdGltZXI7CgogICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHsKICAgICAgICAgICAgdmFyIG5hbWUgPSBhc3luY0ZuLm5hbWUgfHwgJ2Fub255bW91cyc7CiAgICAgICAgICAgIHZhciBlcnJvciAgPSBuZXcgRXJyb3IoJ0NhbGxiYWNrIGZ1bmN0aW9uICInICsgbmFtZSArICciIHRpbWVkIG91dC4nKTsKICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdFVElNRURPVVQnOwogICAgICAgICAgICBpZiAoaW5mbykgewogICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IGluZm87CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlOwogICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7CiAgICAgICAgfQoKICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAoIXRpbWVkT3V0KSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgICAvLyBzZXR1cCB0aW1lciBhbmQgY2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgIHRpbWVyID0gc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIG1pbGxpc2Vjb25kcyk7CiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7CiAgICB9KTsKfQoKLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqLwp2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbDsKdmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4OwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndAogKiBjb2VyY2UgYXJndW1lbnRzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS4KICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS4KICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuCiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuCiAqLwpmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLAogICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpOwoKICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0OwogICAgc3RhcnQgKz0gc3RlcDsKICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgdGltZXNMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy50aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLgogKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS4KICovCmZ1bmN0aW9uIHRpbWVMaW1pdChjb3VudCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBtYXBMaW1pdChiYXNlUmFuZ2UoMCwgY291bnQsIDEpLCBsaW1pdCwgX2l0ZXJhdGVlLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBDYWxscyB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbiBgbmAgdGltZXMsIGFuZCBhY2N1bXVsYXRlcyByZXN1bHRzIGluIHRoZSBzYW1lCiAqIG1hbm5lciB5b3Ugd291bGQgdXNlIHdpdGggW21hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uCiAqCiAqIEBuYW1lIHRpbWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy4KICogSW52b2tlZCB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXggYW5kIGEgY2FsbGJhY2s6IChuLCBuZXh0KS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LgogKiBAZXhhbXBsZQogKgogKiAvLyBQcmV0ZW5kIHRoaXMgaXMgc29tZSBjb21wbGljYXRlZCBhc3luYyBmYWN0b3J5CiAqIHZhciBjcmVhdGVVc2VyID0gZnVuY3Rpb24oaWQsIGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCB7CiAqICAgICAgICAgaWQ6ICd1c2VyJyArIGlkCiAqICAgICB9KTsKICogfTsKICoKICogLy8gZ2VuZXJhdGUgNSB1c2VycwogKiBhc3luYy50aW1lcyg1LCBmdW5jdGlvbihuLCBuZXh0KSB7CiAqICAgICBjcmVhdGVVc2VyKG4sIGZ1bmN0aW9uKGVyciwgdXNlcikgewogKiAgICAgICAgIG5leHQoZXJyLCB1c2VyKTsKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHVzZXJzKSB7CiAqICAgICAvLyB3ZSBzaG91bGQgbm93IGhhdmUgNSB1c2VycwogKiB9KTsKICovCnZhciB0aW1lcyA9IGRvTGltaXQodGltZUxpbWl0LCBJbmZpbml0eSk7CgovKioKICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgdGltZXNTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc30KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy4KICogSW52b2tlZCB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXggYW5kIGEgY2FsbGJhY2s6IChuLCBuZXh0KS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LgogKi8KdmFyIHRpbWVzU2VyaWVzID0gZG9MaW1pdCh0aW1lTGltaXQsIDEpOwoKLyoqCiAqIEEgcmVsYXRpdmUgb2YgYHJlZHVjZWAuICBUYWtlcyBhbiBPYmplY3Qgb3IgQXJyYXksIGFuZCBpdGVyYXRlcyBvdmVyIGVhY2gKICogZWxlbWVudCBpbiBzZXJpZXMsIGVhY2ggc3RlcCBwb3RlbnRpYWxseSBtdXRhdGluZyBhbiBgYWNjdW11bGF0b3JgIHZhbHVlLgogKiBUaGUgdHlwZSBvZiB0aGUgYWNjdW11bGF0b3IgZGVmYXVsdHMgdG8gdGhlIHR5cGUgb2YgY29sbGVjdGlvbiBwYXNzZWQgaW4uCiAqCiAqIEBuYW1lIHRyYW5zZm9ybQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0uICBJZiBvbWl0dGVkLAogKiBpdCB3aWxsIGRlZmF1bHQgdG8gYW4gZW1wdHkgT2JqZWN0IG9yIEFycmF5LCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYGNvbGxgCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZQogKiBjb2xsZWN0aW9uIHRoYXQgcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGFjY3VtdWxhdG9yLgogKiBJbnZva2VkIHdpdGggKGFjY3VtdWxhdG9yLCBpdGVtLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSB0cmFuc2Zvcm1lZCBhY2N1bXVsYXRvci4KICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnRyYW5zZm9ybShbMSwyLDNdLCBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4LCBjYWxsYmFjaykgewogKiAgICAgLy8gcG9pbnRsZXNzIGFzeW5jOgogKiAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsKICogICAgICAgICBhY2MucHVzaChpdGVtICogMikKICogICAgICAgICBjYWxsYmFjayhudWxsKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgaXMgbm93IGVxdWFsIHRvIFsyLCA0LCA2XQogKiB9KTsKICoKICogQGV4YW1wbGUKICoKICogYXN5bmMudHJhbnNmb3JtKHthOiAxLCBiOiAyLCBjOiAzfSwgZnVuY3Rpb24gKG9iaiwgdmFsLCBrZXksIGNhbGxiYWNrKSB7CiAqICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgewogKiAgICAgICAgIG9ialtrZXldID0gdmFsICogMjsKICogICAgICAgICBjYWxsYmFjaygpOwogKiAgICAgfSkKICogfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgaXMgZXF1YWwgdG8ge2E6IDIsIGI6IDQsIGM6IDZ9CiAqIH0pCiAqLwpmdW5jdGlvbiB0cmFuc2Zvcm0gKGNvbGwsIGFjY3VtdWxhdG9yLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDMpIHsKICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdGVlOwogICAgICAgIGl0ZXJhdGVlID0gYWNjdW11bGF0b3I7CiAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FycmF5KGNvbGwpID8gW10gOiB7fTsKICAgIH0KICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwoKICAgIGVhY2hPZihjb2xsLCBmdW5jdGlvbih2LCBrLCBjYikgewogICAgICAgIF9pdGVyYXRlZShhY2N1bXVsYXRvciwgdiwgaywgY2IpOwogICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgY2FsbGJhY2soZXJyLCBhY2N1bXVsYXRvcik7CiAgICB9KTsKfQoKLyoqCiAqIEl0IHJ1bnMgZWFjaCB0YXNrIGluIHNlcmllcyBidXQgc3RvcHMgd2hlbmV2ZXIgYW55IG9mIHRoZSBmdW5jdGlvbnMgd2VyZQogKiBzdWNjZXNzZnVsLiBJZiBvbmUgb2YgdGhlIHRhc2tzIHdlcmUgc3VjY2Vzc2Z1bCwgdGhlIGBjYWxsYmFja2Agd2lsbCBiZQogKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgdGFza3MgZmFpbCwgdGhlIGNhbGxiYWNrCiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LgogKgogKiBAbmFtZSB0cnlFYWNoCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvCiAqIHJ1biwgZWFjaCBmdW5jdGlvbiBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBpdCBtdXN0IGNhbGwgb24KICogY29tcGxldGlvbiB3aXRoIGFuIGVycm9yIGBlcnJgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYW4gb3B0aW9uYWwgYHJlc3VsdGAKICogdmFsdWUuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBvbmUKICogb2YgdGhlIHRhc2tzIGhhcyBzdWNjZWVkZWQsIG9yIGFsbCBoYXZlIGZhaWxlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFuZAogKiBgcmVzdWx0YCBhcmd1bWVudHMgb2YgdGhlIGxhc3QgYXR0ZW1wdCBhdCBjb21wbGV0aW5nIHRoZSBgdGFza2AuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICogYXN5bmMudHJ5KFsKICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tRmlyc3RXZWJzaXRlKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgd2Vic2l0ZQogKiAgICAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21TZWNvbmRXZWJzaXRlKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gRmlyc3Qgd2Vic2l0ZSBmYWlsZWQsCiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgYmFja3VwIHdlYnNpdGUKICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpOwogKiAgICAgfQogKiBdLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIE5vdyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4KICogfSk7CiAqCiAqLwpmdW5jdGlvbiB0cnlFYWNoKHRhc2tzLCBjYWxsYmFjaykgewogICAgdmFyIGVycm9yID0gbnVsbDsKICAgIHZhciByZXN1bHQ7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICBlYWNoU2VyaWVzKHRhc2tzLCBmdW5jdGlvbih0YXNrLCBjYWxsYmFjaykgewogICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXMvKiwgLi4uYXJncyovKSB7CiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlczsKICAgICAgICAgICAgfQogICAgICAgICAgICBlcnJvciA9IGVycjsKICAgICAgICAgICAgY2FsbGJhY2soIWVycik7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoKSB7CiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7CiAgICB9KTsKfQoKLyoqCiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLAogKiB1bm1lbW9pemVkIGZvcm0uIEhhbmR5IGZvciB0ZXN0aW5nLgogKgogKiBAbmFtZSB1bm1lbW9pemUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWVtb2l6ZV17QGxpbmsgbW9kdWxlOlV0aWxzLm1lbW9pemV9CiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgb3JpZ2luYWwgdW5tZW1vaXplZCBmdW5jdGlvbgogKi8KZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgIH07Cn0KCi8qKgogKiBSZXBlYXRlZGx5IGNhbGwgYGl0ZXJhdGVlYCwgd2hpbGUgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW4KICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLgogKgogKiBAbmFtZSB3aGlsc3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lCiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2AKICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MKICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pOwogKiBAcmV0dXJucyB1bmRlZmluZWQKICogQGV4YW1wbGUKICoKICogdmFyIGNvdW50ID0gMDsKICogYXN5bmMud2hpbHN0KAogKiAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBjb3VudCA8IDU7IH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNvdW50Kys7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY291bnQpOwogKiAgICAgICAgIH0sIDEwMDApOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uIChlcnIsIG4pIHsKICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1CiAqICAgICB9CiAqICk7CiAqLwpmdW5jdGlvbiB3aGlsc3QodGVzdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBpZiAoIXRlc3QoKSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgdmFyIG5leHQgPSBmdW5jdGlvbihlcnIvKiwgLi4uYXJncyovKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgaWYgKHRlc3QoKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7CiAgICB9OwogICAgX2l0ZXJhdGVlKG5leHQpOwp9CgovKioKICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW4KICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgY2FsbGJhY2tgIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkKICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzIGNhbGxiYWNrLgogKgogKiBUaGUgaW52ZXJzZSBvZiBbd2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS4KICoKICogQG5hbWUgdW50aWwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2gKICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoKS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUKICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBwYXNzZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTsKICovCmZ1bmN0aW9uIHVudGlsKHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgd2hpbHN0KGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHNlcmllcywgZWFjaCBwYXNzaW5nIHRoZWlyIHJlc3VsdHMgdG8KICogdGhlIG5leHQgaW4gdGhlIGFycmF5LiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIGB0YXNrc2AgcGFzcyBhbiBlcnJvciB0byB0aGVpcgogKiBvd24gY2FsbGJhY2ssIHRoZSBuZXh0IGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMKICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLgogKgogKiBAbmFtZSB3YXRlcmZhbGwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IG9mIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259CiAqIHRvIHJ1bi4KICogRWFjaCBmdW5jdGlvbiBzaG91bGQgY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIGByZXN1bHRgIHZhbHVlcy4KICogVGhlIGByZXN1bHRgIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMsIGluIG9yZGVyLCB0byB0aGUgbmV4dCB0YXNrLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgd2lsbCBiZSBwYXNzZWQgdGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgdGFzaydzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHsKICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJwogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZScKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpOwogKiAgICAgfQogKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJwogKiB9KTsKICoKICogLy8gT3IsIHdpdGggbmFtZWQgZnVuY3Rpb25zOgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgbXlGaXJzdEZ1bmN0aW9uLAogKiAgICAgbXlTZWNvbmRGdW5jdGlvbiwKICogICAgIG15TGFzdEZ1bmN0aW9uLAogKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJwogKiB9KTsKICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpOwogKiB9CiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHsKICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nCiAqICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTsKICogfQogKiBmdW5jdGlvbiBteUxhc3RGdW5jdGlvbihhcmcxLCBjYWxsYmFjaykgewogKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZScKICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7CiAqIH0KICovCnZhciB3YXRlcmZhbGwgPSBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTsKICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTsKICAgIHZhciB0YXNrSW5kZXggPSAwOwoKICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHsKICAgICAgICB2YXIgdGFzayA9IHdyYXBBc3luYyh0YXNrc1t0YXNrSW5kZXgrK10pOwogICAgICAgIGFyZ3MucHVzaChvbmx5T25jZShuZXh0KSk7CiAgICAgICAgdGFzay5hcHBseShudWxsLCBhcmdzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICBpZiAoZXJyIHx8IHRhc2tJbmRleCA9PT0gdGFza3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICAgIH0KICAgICAgICBuZXh0VGFzayhzbGljZShhcmd1bWVudHMsIDEpKTsKICAgIH0KCiAgICBuZXh0VGFzayhbXSk7Cn07CgovKioKICogQW4gImFzeW5jIGZ1bmN0aW9uIiBpbiB0aGUgY29udGV4dCBvZiBBc3luYyBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gd2l0aAogKiBhIHZhcmlhYmxlIG51bWJlciBvZiBwYXJhbWV0ZXJzLCB3aXRoIHRoZSBmaW5hbCBwYXJhbWV0ZXIgYmVpbmcgYSBjYWxsYmFjay4KICogKGBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgLi4uLCBjYWxsYmFjaykge31gKQogKiBUaGUgZmluYWwgY2FsbGJhY2sgaXMgb2YgdGhlIGZvcm0gYGNhbGxiYWNrKGVyciwgcmVzdWx0cy4uLilgLCB3aGljaCBtdXN0IGJlCiAqIGNhbGxlZCBvbmNlIHRoZSBmdW5jdGlvbiBpcyBjb21wbGV0ZWQuICBUaGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGEKICogRXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIHNpZ25hbCB0aGF0IGFuIGVycm9yIG9jY3VycmVkLgogKiBPdGhlcndpc2UsIGlmIG5vIGVycm9yIG9jY3VycmVkLCBpdCBzaG91bGQgYmUgY2FsbGVkIHdpdGggYG51bGxgIGFzIHRoZSBmaXJzdAogKiBhcmd1bWVudCwgYW5kIGFueSBhZGRpdGlvbmFsIGByZXN1bHRgIGFyZ3VtZW50cyB0aGF0IG1heSBhcHBseSwgdG8gc2lnbmFsCiAqIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi4KICogVGhlIGNhbGxiYWNrIG11c3QgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSwgaWRlYWxseSBvbiBhIGxhdGVyIHRpY2sgb2YgdGhlCiAqIEphdmFTY3JpcHQgZXZlbnQgbG9vcC4KICoKICogVGhpcyB0eXBlIG9mIGZ1bmN0aW9uIGlzIGFsc28gcmVmZXJyZWQgdG8gYXMgYSAiTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiIsCiAqIG9yIGEgImNvbnRpbnVhdGlvbiBwYXNzaW5nLXN0eWxlIGZ1bmN0aW9uIiAoQ1BTKS4gTW9zdCBvZiB0aGUgbWV0aG9kcyBvZiB0aGlzCiAqIGxpYnJhcnkgYXJlIHRoZW1zZWx2ZXMgQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLCBvciBmdW5jdGlvbnMgdGhhdAogKiByZXR1cm4gQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLgogKgogKiBXaGVyZXZlciB3ZSBhY2NlcHQgYSBOb2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9uLCB3ZSBhbHNvIGRpcmVjdGx5IGFjY2VwdCBhbgogKiBbRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0YXRlbWVudHMvYXN5bmNfZnVuY3Rpb259LgogKiBJbiB0aGlzIGNhc2UsIHRoZSBgYXN5bmNgIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHBhc3NlZCBhIGZpbmFsIGNhbGxiYWNrCiAqIGFyZ3VtZW50LCBhbmQgYW55IHRocm93biBlcnJvciB3aWxsIGJlIHVzZWQgYXMgdGhlIGBlcnJgIGFyZ3VtZW50IG9mIHRoZQogKiBpbXBsaWNpdCBjYWxsYmFjaywgYW5kIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBgcmVzdWx0YCB2YWx1ZS4KICogKGkuZS4gYSBgcmVqZWN0ZWRgIG9mIHRoZSByZXR1cm5lZCBQcm9taXNlIGJlY29tZXMgdGhlIGBlcnJgIGNhbGxiYWNrCiAqIGFyZ3VtZW50LCBhbmQgYSBgcmVzb2x2ZWRgIHZhbHVlIGJlY29tZXMgdGhlIGByZXN1bHRgLikKICoKICogTm90ZSwgZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIHdlIGNhbiBvbmx5IGRldGVjdCBuYXRpdmUgYGFzeW5jYAogKiBmdW5jdGlvbnMgYW5kIG5vdCB0cmFuc3BpbGllZCBpbXBsZW1lbnRhdGlvbnMuCiAqIFlvdXIgZW52aXJvbm1lbnQgbXVzdCBoYXZlIGBhc3luY2AvYGF3YWl0YCBzdXBwb3J0IGZvciB0aGlzIHRvIHdvcmsuCiAqIChlLmcuIE5vZGUgPiB2Ny42LCBvciBhIHJlY2VudCB2ZXJzaW9uIG9mIGEgbW9kZXJuIGJyb3dzZXIpLgogKiBJZiB5b3UgYXJlIHVzaW5nIGBhc3luY2AgZnVuY3Rpb25zIHRocm91Z2ggYSB0cmFuc3BpbGVyIChlLmcuIEJhYmVsKSwgeW91CiAqIG11c3Qgc3RpbGwgd3JhcCB0aGUgZnVuY3Rpb24gd2l0aCBbYXN5bmNpZnlde0BsaW5rIG1vZHVsZTpVdGlscy5hc3luY2lmeX0sCiAqIGJlY2F1c2UgdGhlIGBhc3luYyBmdW5jdGlvbmAgd2lsbCBiZSBjb21waWxlZCB0byBhbiBvcmRpbmFyeSBmdW5jdGlvbiB0aGF0CiAqIHJldHVybnMgYSBwcm9taXNlLgogKgogKiBAdHlwZWRlZiB7RnVuY3Rpb259IEFzeW5jRnVuY3Rpb24KICogQHN0YXRpYwogKi8KCi8qKgogKiBBc3luYyBpcyBhIHV0aWxpdHkgbW9kdWxlIHdoaWNoIHByb3ZpZGVzIHN0cmFpZ2h0LWZvcndhcmQsIHBvd2VyZnVsIGZ1bmN0aW9ucwogKiBmb3Igd29ya2luZyB3aXRoIGFzeW5jaHJvbm91cyBKYXZhU2NyaXB0LiBBbHRob3VnaCBvcmlnaW5hbGx5IGRlc2lnbmVkIGZvcgogKiB1c2Ugd2l0aCBbTm9kZS5qc10oaHR0cDovL25vZGVqcy5vcmcpIGFuZCBpbnN0YWxsYWJsZSB2aWEKICogYG5wbSBpbnN0YWxsIC0tc2F2ZSBhc3luY2AsIGl0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuCiAqIEBtb2R1bGUgYXN5bmMKICogQHNlZSBBc3luY0Z1bmN0aW9uCiAqLwoKCi8qKgogKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyBjb2xsZWN0aW9ucywgc3VjaCBhcwogKiBhcnJheXMgYW5kIG9iamVjdHMuCiAqIEBtb2R1bGUgQ29sbGVjdGlvbnMKICovCgovKioKICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBjb250cm9sbGluZyB0aGUgZmxvdyB0aHJvdWdoIGEgc2NyaXB0LgogKiBAbW9kdWxlIENvbnRyb2xGbG93CiAqLwoKLyoqCiAqIEEgY29sbGVjdGlvbiBvZiBgYXN5bmNgIHV0aWxpdHkgZnVuY3Rpb25zLgogKiBAbW9kdWxlIFV0aWxzCiAqLwoKdmFyIGluZGV4ID0gewogICAgYXBwbHlFYWNoOiBhcHBseUVhY2gsCiAgICBhcHBseUVhY2hTZXJpZXM6IGFwcGx5RWFjaFNlcmllcywKICAgIGFwcGx5OiBhcHBseSwKICAgIGFzeW5jaWZ5OiBhc3luY2lmeSwKICAgIGF1dG86IGF1dG8sCiAgICBhdXRvSW5qZWN0OiBhdXRvSW5qZWN0LAogICAgY2FyZ286IGNhcmdvLAogICAgY29tcG9zZTogY29tcG9zZSwKICAgIGNvbmNhdDogY29uY2F0LAogICAgY29uY2F0TGltaXQ6IGNvbmNhdExpbWl0LAogICAgY29uY2F0U2VyaWVzOiBjb25jYXRTZXJpZXMsCiAgICBjb25zdGFudDogY29uc3RhbnQsCiAgICBkZXRlY3Q6IGRldGVjdCwKICAgIGRldGVjdExpbWl0OiBkZXRlY3RMaW1pdCwKICAgIGRldGVjdFNlcmllczogZGV0ZWN0U2VyaWVzLAogICAgZGlyOiBkaXIsCiAgICBkb0R1cmluZzogZG9EdXJpbmcsCiAgICBkb1VudGlsOiBkb1VudGlsLAogICAgZG9XaGlsc3Q6IGRvV2hpbHN0LAogICAgZHVyaW5nOiBkdXJpbmcsCiAgICBlYWNoOiBlYWNoTGltaXQsCiAgICBlYWNoTGltaXQ6IGVhY2hMaW1pdCQxLAogICAgZWFjaE9mOiBlYWNoT2YsCiAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsCiAgICBlYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcywKICAgIGVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsCiAgICBlbnN1cmVBc3luYzogZW5zdXJlQXN5bmMsCiAgICBldmVyeTogZXZlcnksCiAgICBldmVyeUxpbWl0OiBldmVyeUxpbWl0LAogICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzLAogICAgZmlsdGVyOiBmaWx0ZXIsCiAgICBmaWx0ZXJMaW1pdDogZmlsdGVyTGltaXQsCiAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcywKICAgIGZvcmV2ZXI6IGZvcmV2ZXIsCiAgICBncm91cEJ5OiBncm91cEJ5LAogICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQsCiAgICBncm91cEJ5U2VyaWVzOiBncm91cEJ5U2VyaWVzLAogICAgbG9nOiBsb2csCiAgICBtYXA6IG1hcCwKICAgIG1hcExpbWl0OiBtYXBMaW1pdCwKICAgIG1hcFNlcmllczogbWFwU2VyaWVzLAogICAgbWFwVmFsdWVzOiBtYXBWYWx1ZXMsCiAgICBtYXBWYWx1ZXNMaW1pdDogbWFwVmFsdWVzTGltaXQsCiAgICBtYXBWYWx1ZXNTZXJpZXM6IG1hcFZhbHVlc1NlcmllcywKICAgIG1lbW9pemU6IG1lbW9pemUsCiAgICBuZXh0VGljazogbmV4dFRpY2ssCiAgICBwYXJhbGxlbDogcGFyYWxsZWxMaW1pdCwKICAgIHBhcmFsbGVsTGltaXQ6IHBhcmFsbGVsTGltaXQkMSwKICAgIHByaW9yaXR5UXVldWU6IHByaW9yaXR5UXVldWUsCiAgICBxdWV1ZTogcXVldWUkMSwKICAgIHJhY2U6IHJhY2UsCiAgICByZWR1Y2U6IHJlZHVjZSwKICAgIHJlZHVjZVJpZ2h0OiByZWR1Y2VSaWdodCwKICAgIHJlZmxlY3Q6IHJlZmxlY3QsCiAgICByZWZsZWN0QWxsOiByZWZsZWN0QWxsLAogICAgcmVqZWN0OiByZWplY3QsCiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQsCiAgICByZWplY3RTZXJpZXM6IHJlamVjdFNlcmllcywKICAgIHJldHJ5OiByZXRyeSwKICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlLAogICAgc2VxOiBzZXEsCiAgICBzZXJpZXM6IHNlcmllcywKICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsCiAgICBzb21lOiBzb21lLAogICAgc29tZUxpbWl0OiBzb21lTGltaXQsCiAgICBzb21lU2VyaWVzOiBzb21lU2VyaWVzLAogICAgc29ydEJ5OiBzb3J0QnksCiAgICB0aW1lb3V0OiB0aW1lb3V0LAogICAgdGltZXM6IHRpbWVzLAogICAgdGltZXNMaW1pdDogdGltZUxpbWl0LAogICAgdGltZXNTZXJpZXM6IHRpbWVzU2VyaWVzLAogICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sCiAgICB0cnlFYWNoOiB0cnlFYWNoLAogICAgdW5tZW1vaXplOiB1bm1lbW9pemUsCiAgICB1bnRpbDogdW50aWwsCiAgICB3YXRlcmZhbGw6IHdhdGVyZmFsbCwKICAgIHdoaWxzdDogd2hpbHN0LAoKICAgIC8vIGFsaWFzZXMKICAgIGFsbDogZXZlcnksCiAgICBhbnk6IHNvbWUsCiAgICBmb3JFYWNoOiBlYWNoTGltaXQsCiAgICBmb3JFYWNoU2VyaWVzOiBlYWNoU2VyaWVzLAogICAgZm9yRWFjaExpbWl0OiBlYWNoTGltaXQkMSwKICAgIGZvckVhY2hPZjogZWFjaE9mLAogICAgZm9yRWFjaE9mU2VyaWVzOiBlYWNoT2ZTZXJpZXMsCiAgICBmb3JFYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsCiAgICBpbmplY3Q6IHJlZHVjZSwKICAgIGZvbGRsOiByZWR1Y2UsCiAgICBmb2xkcjogcmVkdWNlUmlnaHQsCiAgICBzZWxlY3Q6IGZpbHRlciwKICAgIHNlbGVjdExpbWl0OiBmaWx0ZXJMaW1pdCwKICAgIHNlbGVjdFNlcmllczogZmlsdGVyU2VyaWVzLAogICAgd3JhcFN5bmM6IGFzeW5jaWZ5Cn07CgpleHBvcnRzWydkZWZhdWx0J10gPSBpbmRleDsKZXhwb3J0cy5hcHBseUVhY2ggPSBhcHBseUVhY2g7CmV4cG9ydHMuYXBwbHlFYWNoU2VyaWVzID0gYXBwbHlFYWNoU2VyaWVzOwpleHBvcnRzLmFwcGx5ID0gYXBwbHk7CmV4cG9ydHMuYXN5bmNpZnkgPSBhc3luY2lmeTsKZXhwb3J0cy5hdXRvID0gYXV0bzsKZXhwb3J0cy5hdXRvSW5qZWN0ID0gYXV0b0luamVjdDsKZXhwb3J0cy5jYXJnbyA9IGNhcmdvOwpleHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlOwpleHBvcnRzLmNvbmNhdCA9IGNvbmNhdDsKZXhwb3J0cy5jb25jYXRMaW1pdCA9IGNvbmNhdExpbWl0OwpleHBvcnRzLmNvbmNhdFNlcmllcyA9IGNvbmNhdFNlcmllczsKZXhwb3J0cy5jb25zdGFudCA9IGNvbnN0YW50OwpleHBvcnRzLmRldGVjdCA9IGRldGVjdDsKZXhwb3J0cy5kZXRlY3RMaW1pdCA9IGRldGVjdExpbWl0OwpleHBvcnRzLmRldGVjdFNlcmllcyA9IGRldGVjdFNlcmllczsKZXhwb3J0cy5kaXIgPSBkaXI7CmV4cG9ydHMuZG9EdXJpbmcgPSBkb0R1cmluZzsKZXhwb3J0cy5kb1VudGlsID0gZG9VbnRpbDsKZXhwb3J0cy5kb1doaWxzdCA9IGRvV2hpbHN0OwpleHBvcnRzLmR1cmluZyA9IGR1cmluZzsKZXhwb3J0cy5lYWNoID0gZWFjaExpbWl0OwpleHBvcnRzLmVhY2hMaW1pdCA9IGVhY2hMaW1pdCQxOwpleHBvcnRzLmVhY2hPZiA9IGVhY2hPZjsKZXhwb3J0cy5lYWNoT2ZMaW1pdCA9IGVhY2hPZkxpbWl0OwpleHBvcnRzLmVhY2hPZlNlcmllcyA9IGVhY2hPZlNlcmllczsKZXhwb3J0cy5lYWNoU2VyaWVzID0gZWFjaFNlcmllczsKZXhwb3J0cy5lbnN1cmVBc3luYyA9IGVuc3VyZUFzeW5jOwpleHBvcnRzLmV2ZXJ5ID0gZXZlcnk7CmV4cG9ydHMuZXZlcnlMaW1pdCA9IGV2ZXJ5TGltaXQ7CmV4cG9ydHMuZXZlcnlTZXJpZXMgPSBldmVyeVNlcmllczsKZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7CmV4cG9ydHMuZmlsdGVyTGltaXQgPSBmaWx0ZXJMaW1pdDsKZXhwb3J0cy5maWx0ZXJTZXJpZXMgPSBmaWx0ZXJTZXJpZXM7CmV4cG9ydHMuZm9yZXZlciA9IGZvcmV2ZXI7CmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7CmV4cG9ydHMuZ3JvdXBCeUxpbWl0ID0gZ3JvdXBCeUxpbWl0OwpleHBvcnRzLmdyb3VwQnlTZXJpZXMgPSBncm91cEJ5U2VyaWVzOwpleHBvcnRzLmxvZyA9IGxvZzsKZXhwb3J0cy5tYXAgPSBtYXA7CmV4cG9ydHMubWFwTGltaXQgPSBtYXBMaW1pdDsKZXhwb3J0cy5tYXBTZXJpZXMgPSBtYXBTZXJpZXM7CmV4cG9ydHMubWFwVmFsdWVzID0gbWFwVmFsdWVzOwpleHBvcnRzLm1hcFZhbHVlc0xpbWl0ID0gbWFwVmFsdWVzTGltaXQ7CmV4cG9ydHMubWFwVmFsdWVzU2VyaWVzID0gbWFwVmFsdWVzU2VyaWVzOwpleHBvcnRzLm1lbW9pemUgPSBtZW1vaXplOwpleHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7CmV4cG9ydHMucGFyYWxsZWwgPSBwYXJhbGxlbExpbWl0OwpleHBvcnRzLnBhcmFsbGVsTGltaXQgPSBwYXJhbGxlbExpbWl0JDE7CmV4cG9ydHMucHJpb3JpdHlRdWV1ZSA9IHByaW9yaXR5UXVldWU7CmV4cG9ydHMucXVldWUgPSBxdWV1ZSQxOwpleHBvcnRzLnJhY2UgPSByYWNlOwpleHBvcnRzLnJlZHVjZSA9IHJlZHVjZTsKZXhwb3J0cy5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0OwpleHBvcnRzLnJlZmxlY3QgPSByZWZsZWN0OwpleHBvcnRzLnJlZmxlY3RBbGwgPSByZWZsZWN0QWxsOwpleHBvcnRzLnJlamVjdCA9IHJlamVjdDsKZXhwb3J0cy5yZWplY3RMaW1pdCA9IHJlamVjdExpbWl0OwpleHBvcnRzLnJlamVjdFNlcmllcyA9IHJlamVjdFNlcmllczsKZXhwb3J0cy5yZXRyeSA9IHJldHJ5OwpleHBvcnRzLnJldHJ5YWJsZSA9IHJldHJ5YWJsZTsKZXhwb3J0cy5zZXEgPSBzZXE7CmV4cG9ydHMuc2VyaWVzID0gc2VyaWVzOwpleHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZSQxOwpleHBvcnRzLnNvbWUgPSBzb21lOwpleHBvcnRzLnNvbWVMaW1pdCA9IHNvbWVMaW1pdDsKZXhwb3J0cy5zb21lU2VyaWVzID0gc29tZVNlcmllczsKZXhwb3J0cy5zb3J0QnkgPSBzb3J0Qnk7CmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7CmV4cG9ydHMudGltZXMgPSB0aW1lczsKZXhwb3J0cy50aW1lc0xpbWl0ID0gdGltZUxpbWl0OwpleHBvcnRzLnRpbWVzU2VyaWVzID0gdGltZXNTZXJpZXM7CmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtOwpleHBvcnRzLnRyeUVhY2ggPSB0cnlFYWNoOwpleHBvcnRzLnVubWVtb2l6ZSA9IHVubWVtb2l6ZTsKZXhwb3J0cy51bnRpbCA9IHVudGlsOwpleHBvcnRzLndhdGVyZmFsbCA9IHdhdGVyZmFsbDsKZXhwb3J0cy53aGlsc3QgPSB3aGlsc3Q7CmV4cG9ydHMuYWxsID0gZXZlcnk7CmV4cG9ydHMuYWxsTGltaXQgPSBldmVyeUxpbWl0OwpleHBvcnRzLmFsbFNlcmllcyA9IGV2ZXJ5U2VyaWVzOwpleHBvcnRzLmFueSA9IHNvbWU7CmV4cG9ydHMuYW55TGltaXQgPSBzb21lTGltaXQ7CmV4cG9ydHMuYW55U2VyaWVzID0gc29tZVNlcmllczsKZXhwb3J0cy5maW5kID0gZGV0ZWN0OwpleHBvcnRzLmZpbmRMaW1pdCA9IGRldGVjdExpbWl0OwpleHBvcnRzLmZpbmRTZXJpZXMgPSBkZXRlY3RTZXJpZXM7CmV4cG9ydHMuZm9yRWFjaCA9IGVhY2hMaW1pdDsKZXhwb3J0cy5mb3JFYWNoU2VyaWVzID0gZWFjaFNlcmllczsKZXhwb3J0cy5mb3JFYWNoTGltaXQgPSBlYWNoTGltaXQkMTsKZXhwb3J0cy5mb3JFYWNoT2YgPSBlYWNoT2Y7CmV4cG9ydHMuZm9yRWFjaE9mU2VyaWVzID0gZWFjaE9mU2VyaWVzOwpleHBvcnRzLmZvckVhY2hPZkxpbWl0ID0gZWFjaE9mTGltaXQ7CmV4cG9ydHMuaW5qZWN0ID0gcmVkdWNlOwpleHBvcnRzLmZvbGRsID0gcmVkdWNlOwpleHBvcnRzLmZvbGRyID0gcmVkdWNlUmlnaHQ7CmV4cG9ydHMuc2VsZWN0ID0gZmlsdGVyOwpleHBvcnRzLnNlbGVjdExpbWl0ID0gZmlsdGVyTGltaXQ7CmV4cG9ydHMuc2VsZWN0U2VyaWVzID0gZmlsdGVyU2VyaWVzOwpleHBvcnRzLndyYXBTeW5jID0gYXN5bmNpZnk7CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pOwoKfSkpKTsKCn0pLmNhbGwodGhpcyxfZGVyZXFfKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0seyJfcHJvY2VzcyI6MTl9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24iKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24iOjIxfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlIjoyMn1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Cn0seyJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSI6MjN9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZiI6MjR9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZiI6MjV9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wiKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbCI6MjZ9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IiKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvciI6Mjd9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CgpleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7CiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOwogIH0KfTsKfSx7fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoidXNlIHN0cmljdCI7CgpleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwoKdmFyIF9kZWZpbmVQcm9wZXJ0eSA9IF9kZXJlcV8oIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSIpOwoKdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgewogICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsKICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOwogICAgfQogIH0KCiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsKICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7CiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsKICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICB9Owp9KCk7Cn0seyIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkiOjd9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Cgp2YXIgX3NldFByb3RvdHlwZU9mID0gX2RlcmVxXygiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZiIpOwoKdmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7Cgp2YXIgX2NyZWF0ZSA9IF9kZXJlcV8oIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZSIpOwoKdmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTsKCnZhciBfdHlwZW9mMiA9IF9kZXJlcV8oIi4uL2hlbHBlcnMvdHlwZW9mIik7Cgp2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9CgpleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7CiAgfQoKICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgewogICAgY29uc3RydWN0b3I6IHsKICAgICAgdmFsdWU6IHN1YkNsYXNzLAogICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgfQogIH0pOwogIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOwp9Owp9LHsiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlIjo2LCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mIjo5LCIuLi9oZWxwZXJzL3R5cGVvZiI6MTZ9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Cgp2YXIgX3R5cGVvZjIgPSBfZGVyZXFfKCIuLi9oZWxwZXJzL3R5cGVvZiIpOwoKdmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHsKICBpZiAoIXNlbGYpIHsKICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgfQoKICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpID8gY2FsbCA6IHNlbGY7Cn07Cn0seyIuLi9oZWxwZXJzL3R5cGVvZiI6MTZ9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Cgp2YXIgX2l0ZXJhdG9yID0gX2RlcmVxXygiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IiKTsKCnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpOwoKdmFyIF9zeW1ib2wgPSBfZGVyZXFfKCIuLi9jb3JlLWpzL3N5bWJvbCIpOwoKdmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTsKCnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09ICJmdW5jdGlvbiIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gInN5bWJvbCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSAiZnVuY3Rpb24iICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gInN5bWJvbCIgOiB0eXBlb2Ygb2JqOyB9OwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSAiZnVuY3Rpb24iICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gInN5bWJvbCIgPyBmdW5jdGlvbiAob2JqKSB7CiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKG9iaik7Cn0gOiBmdW5jdGlvbiAob2JqKSB7CiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gImZ1bmN0aW9uIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/ICJzeW1ib2wiIDogdHlwZW9mIG9iaiA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2Yob2JqKTsKfTsKfSx7Ii4uL2NvcmUtanMvc3ltYm9sIjoxMCwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IiOjExfV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCcKCmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGgKZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5CmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXkKCnZhciBsb29rdXAgPSBbXQp2YXIgcmV2TG9va3VwID0gW10KdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheQoKdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycKZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICBsb29rdXBbaV0gPSBjb2RlW2ldCiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpCn0KCnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MgpyZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjMKCmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHsKICB2YXIgbGVuID0gYjY0Lmxlbmd0aAogIGlmIChsZW4gJSA0ID4gMCkgewogICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JykKICB9CgogIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpCiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdAogIC8vIHJlcHJlc2VudCBvbmUgYnl0ZQogIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlcwogIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2UKICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMAp9CgpmdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHsKICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGEKICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpCn0KCmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHsKICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycgogIHZhciBsZW4gPSBiNjQubGVuZ3RoCiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KQoKICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpCgogIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnMKICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW4KCiAgdmFyIEwgPSAwCgogIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHsKICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXQogICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkYKICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkYKICAgIGFycltMKytdID0gdG1wICYgMHhGRgogIH0KCiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikgewogICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCkKICAgIGFycltMKytdID0gdG1wICYgMHhGRgogIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7CiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMikKICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkYKICAgIGFycltMKytdID0gdG1wICYgMHhGRgogIH0KCiAgcmV0dXJuIGFycgp9CgpmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkgewogIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXQp9CgpmdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHsKICB2YXIgdG1wCiAgdmFyIG91dHB1dCA9IFtdCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHsKICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSkKICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKQogIH0KICByZXR1cm4gb3V0cHV0LmpvaW4oJycpCn0KCmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7CiAgdmFyIHRtcAogIHZhciBsZW4gPSB1aW50OC5sZW5ndGgKICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXMKICB2YXIgb3V0cHV0ID0gJycKICB2YXIgcGFydHMgPSBbXQogIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgMwoKICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyCiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkgewogICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSkKICB9CgogIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXMKICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkgewogICAgdG1wID0gdWludDhbbGVuIC0gMV0KICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdCiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXQogICAgb3V0cHV0ICs9ICc9PScKICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHsKICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSkKICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXQogICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0KICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdCiAgICBvdXRwdXQgKz0gJz0nCiAgfQoKICBwYXJ0cy5wdXNoKG91dHB1dCkKCiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpCn0KCn0se31dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKCn0se31dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyCnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTsKCi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdAovLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXMKLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYQovLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLgoKdmFyIGNhY2hlZFNldFRpbWVvdXQ7CnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7CgpmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkgewogICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7Cn0KZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpOwp9CihmdW5jdGlvbiAoKSB7CiAgICB0cnkgewogICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDsKICAgICAgICB9CiAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7CiAgICB9CiAgICB0cnkgewogICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0OwogICAgICAgIH0KICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0OwogICAgfQp9ICgpKQpmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikgewogICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHsKICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnMKICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApOwogICAgfQogICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWQKICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkgewogICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0OwogICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7CiAgICB9CiAgICB0cnkgewogICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3MKICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApOwogICAgfSBjYXRjaChlKXsKICAgICAgICB0cnkgewogICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHkKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApOwogICAgICAgIH0gY2F0Y2goZSl7CiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yCiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTsKICAgICAgICB9CiAgICB9CgoKfQpmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7CiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHsKICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnMKICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7CiAgICB9CiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkCiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHsKICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7CiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpOwogICAgfQogICAgdHJ5IHsKICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzCiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpOwogICAgfSBjYXRjaCAoZSl7CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseQogICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTsKICAgICAgICB9IGNhdGNoIChlKXsKICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuCiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXQKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7CiAgICAgICAgfQogICAgfQoKCgp9CnZhciBxdWV1ZSA9IFtdOwp2YXIgZHJhaW5pbmcgPSBmYWxzZTsKdmFyIGN1cnJlbnRRdWV1ZTsKdmFyIHF1ZXVlSW5kZXggPSAtMTsKCmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHsKICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkgewogICAgICAgIHJldHVybjsKICAgIH0KICAgIGRyYWluaW5nID0gZmFsc2U7CiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkgewogICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7CiAgICB9IGVsc2UgewogICAgICAgIHF1ZXVlSW5kZXggPSAtMTsKICAgIH0KICAgIGlmIChxdWV1ZS5sZW5ndGgpIHsKICAgICAgICBkcmFpblF1ZXVlKCk7CiAgICB9Cn0KCmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7CiAgICBpZiAoZHJhaW5pbmcpIHsKICAgICAgICByZXR1cm47CiAgICB9CiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTsKICAgIGRyYWluaW5nID0gdHJ1ZTsKCiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoOwogICAgd2hpbGUobGVuKSB7CiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7CiAgICAgICAgcXVldWUgPSBbXTsKICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7CiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHsKICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBxdWV1ZUluZGV4ID0gLTE7CiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoOwogICAgfQogICAgY3VycmVudFF1ZXVlID0gbnVsbDsKICAgIGRyYWluaW5nID0gZmFsc2U7CiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7Cn0KCnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7CiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7CiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTsKICAgICAgICB9CiAgICB9CiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpOwogICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHsKICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpOwogICAgfQp9OwoKLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0cwpmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHsKICAgIHRoaXMuZnVuID0gZnVuOwogICAgdGhpcy5hcnJheSA9IGFycmF5Owp9Ckl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpOwp9Owpwcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInOwpwcm9jZXNzLmJyb3dzZXIgPSB0cnVlOwpwcm9jZXNzLmVudiA9IHt9Owpwcm9jZXNzLmFyZ3YgPSBbXTsKcHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzCnByb2Nlc3MudmVyc2lvbnMgPSB7fTsKCmZ1bmN0aW9uIG5vb3AoKSB7fQoKcHJvY2Vzcy5vbiA9IG5vb3A7CnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLm9uY2UgPSBub29wOwpwcm9jZXNzLm9mZiA9IG5vb3A7CnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7CnByb2Nlc3MuZW1pdCA9IG5vb3A7CnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDsKcHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDsKCnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH0KCnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7Cn07Cgpwcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9Owpwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikgewogICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTsKfTsKcHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTsKCn0se31dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLyohCiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwovKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqLwoKJ3VzZSBzdHJpY3QnCgp2YXIgYmFzZTY0ID0gX2RlcmVxXygnYmFzZTY0LWpzJykKdmFyIGllZWU3NTQgPSBfZGVyZXFfKCdpZWVlNzU0JykKCmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyCmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXIKZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwCgp2YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZgpleHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEgKCi8qKgogKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOgogKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KQogKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3QKICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNikKICoKICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLAogKiBPcGVyYSAxMS42KywgaU9TIDQuMisuCiAqCiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZQogKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgCiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnQKICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uCiAqLwpCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KCkKCmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmCiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykgewogIGNvbnNvbGUuZXJyb3IoCiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgKwogICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJwogICkKfQoKZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkgewogIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD8KICB0cnkgewogICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpCiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX0KICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyCiAgfSBjYXRjaCAoZSkgewogICAgcmV0dXJuIGZhbHNlCiAgfQp9CgpmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkgewogIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpCiAgfQogIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlCiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCkKICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZQogIHJldHVybiBidWYKfQoKLyoqCiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpcgogKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mCiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHMKICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQKICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC4KICoKICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLgogKi8KCmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAvLyBDb21tb24gY2FzZS4KICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHsKICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycKICAgICAgKQogICAgfQogICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZykKICB9CiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCn0KCi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3CmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJgogICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHsKICAgIHZhbHVlOiBudWxsLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICB3cml0YWJsZTogZmFsc2UKICB9KQp9CgpCdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24KCmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpCiAgfQoKICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHsKICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKICB9CgogIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCkKICB9CgogIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKQp9CgovKioKICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3IKICogaWYgdmFsdWUgaXMgYSBudW1iZXIuCiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSkKICogQnVmZmVyLmZyb20oYXJyYXkpCiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcikKICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pCiAqKi8KQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCn0KCi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1ZzoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDgKQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZQpCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheQoKZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJykKICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJykKICB9Cn0KCmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykgewogIGFzc2VydFNpemUoc2l6ZSkKICBpZiAoc2l6ZSA8PSAwKSB7CiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpCiAgfQogIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHsKICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzCiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkCiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuCiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJwogICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKQogICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpCiAgfQogIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSkKfQoKLyoqCiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS4KICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKQogKiovCkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykgewogIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykKfQoKZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHsKICBhc3NlcnRTaXplKHNpemUpCiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCkKfQoKLyoqCiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuCiAqICovCkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7CiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpCn0KLyoqCiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLgogKi8KQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7CiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpCn0KCmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHsKICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHsKICAgIGVuY29kaW5nID0gJ3V0ZjgnCiAgfQoKICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImVuY29kaW5nIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJykKICB9CgogIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMAogIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKQoKICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpCgogIGlmIChhY3R1YWwgIT09IGxlbmd0aCkgewogICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsCiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLgogICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpCiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKQogIH0KCiAgcmV0dXJuIGJ1Zgp9CgpmdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkgewogIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDAKICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCkKICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7CiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NQogIH0KICByZXR1cm4gYnVmCn0KCmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkgewogIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wnb2Zmc2V0XCcgaXMgb3V0IG9mIGJvdW5kcycpCiAgfQoKICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCdsZW5ndGhcJyBpcyBvdXQgb2YgYm91bmRzJykKICB9CgogIHZhciBidWYKICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7CiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSkKICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7CiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCkKICB9IGVsc2UgewogICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkKICB9CgogIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlCiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGUKICByZXR1cm4gYnVmCn0KCmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikgewogIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkgewogICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwCiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbikKCiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gYnVmCiAgICB9CgogICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pCiAgICByZXR1cm4gYnVmCiAgfQoKICBpZiAob2JqKSB7CiAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHsKICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMCkKICAgICAgfQogICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopCiAgICB9CgogICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSkKICAgIH0KICB9CgogIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKQp9CgpmdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHsKICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW4KICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLikKICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArCiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKQogIH0KICByZXR1cm4gbGVuZ3RoIHwgMAp9CgpmdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHsKICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEKICAgIGxlbmd0aCA9IDAKICB9CiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKQp9CgpCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikgewogIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUKfQoKQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7CiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpCiAgfQoKICBpZiAoYSA9PT0gYikgcmV0dXJuIDAKCiAgdmFyIHggPSBhLmxlbmd0aAogIHZhciB5ID0gYi5sZW5ndGgKCiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHsKICAgIGlmIChhW2ldICE9PSBiW2ldKSB7CiAgICAgIHggPSBhW2ldCiAgICAgIHkgPSBiW2ldCiAgICAgIGJyZWFrCiAgICB9CiAgfQoKICBpZiAoeCA8IHkpIHJldHVybiAtMQogIGlmICh5IDwgeCkgcmV0dXJuIDEKICByZXR1cm4gMAp9CgpCdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7CiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHsKICAgIGNhc2UgJ2hleCc6CiAgICBjYXNlICd1dGY4JzoKICAgIGNhc2UgJ3V0Zi04JzoKICAgIGNhc2UgJ2FzY2lpJzoKICAgIGNhc2UgJ2xhdGluMSc6CiAgICBjYXNlICdiaW5hcnknOgogICAgY2FzZSAnYmFzZTY0JzoKICAgIGNhc2UgJ3VjczInOgogICAgY2FzZSAndWNzLTInOgogICAgY2FzZSAndXRmMTZsZSc6CiAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgIHJldHVybiB0cnVlCiAgICBkZWZhdWx0OgogICAgICByZXR1cm4gZmFsc2UKICB9Cn0KCkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkgewogIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpCiAgfQoKICBpZiAobGlzdC5sZW5ndGggPT09IDApIHsKICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCkKICB9CgogIHZhciBpCiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7CiAgICBsZW5ndGggPSAwCiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGgKICAgIH0KICB9CgogIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKQogIHZhciBwb3MgPSAwCiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHsKICAgIHZhciBidWYgPSBsaXN0W2ldCiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKQogICAgfQogICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpCiAgICBwb3MgKz0gYnVmLmxlbmd0aAogIH0KICByZXR1cm4gYnVmZmVyCn0KCmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHsKICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHsKICAgIHJldHVybiBzdHJpbmcubGVuZ3RoCiAgfQogIGlmIChpc0FycmF5QnVmZmVyVmlldyhzdHJpbmcpIHx8IGlzQXJyYXlCdWZmZXIoc3RyaW5nKSkgewogICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoCiAgfQogIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgewogICAgc3RyaW5nID0gJycgKyBzdHJpbmcKICB9CgogIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoCiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDAKCiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uCiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2UKICBmb3IgKDs7KSB7CiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gbGVuCiAgICAgIGNhc2UgJ3V0ZjgnOgogICAgICBjYXNlICd1dGYtOCc6CiAgICAgIGNhc2UgdW5kZWZpbmVkOgogICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aAogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiBsZW4gKiAyCiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMQogICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjgKICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlCiAgICB9CiAgfQp9CkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aAoKZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkgewogIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlCgogIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzIiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHkKICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LgoKICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmQKICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuCiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbiwKICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi4KICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHsKICAgIHN0YXJ0ID0gMAogIH0KICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMgogIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuCiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHsKICAgIHJldHVybiAnJwogIH0KCiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICBlbmQgPSB0aGlzLmxlbmd0aAogIH0KCiAgaWYgKGVuZCA8PSAwKSB7CiAgICByZXR1cm4gJycKICB9CgogIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuCiAgZW5kID4+Pj0gMAogIHN0YXJ0ID4+Pj0gMAoKICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICByZXR1cm4gJycKICB9CgogIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnCgogIHdoaWxlICh0cnVlKSB7CiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKQogICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZQogICAgfQogIH0KfQoKLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKQovLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgCi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50Ci8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlcgovLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuCi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NApCdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWUKCmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHsKICB2YXIgaSA9IGJbbl0KICBiW25dID0gYlttXQogIGJbbV0gPSBpCn0KCkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHsKICB2YXIgbGVuID0gdGhpcy5sZW5ndGgKICBpZiAobGVuICUgMiAhPT0gMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJykKICB9CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikgewogICAgc3dhcCh0aGlzLCBpLCBpICsgMSkKICB9CiAgcmV0dXJuIHRoaXMKfQoKQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIGlmIChsZW4gJSA0ICE9PSAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKQogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7CiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKQogICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpCiAgfQogIHJldHVybiB0aGlzCn0KCkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHsKICB2YXIgbGVuID0gdGhpcy5sZW5ndGgKICBpZiAobGVuICUgOCAhPT0gMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJykKICB9CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkgewogICAgc3dhcCh0aGlzLCBpLCBpICsgNykKICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KQogICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpCiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCkKICB9CiAgcmV0dXJuIHRoaXMKfQoKQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHsKICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgKICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJycKICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpCiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpCn0KCkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7CiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKQogIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZQogIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMAp9CgpCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHsKICB2YXIgc3RyID0gJycKICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUwogIGlmICh0aGlzLmxlbmd0aCA+IDApIHsKICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpCiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnCiAgfQogIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nCn0KCkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7CiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpCiAgfQoKICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgewogICAgc3RhcnQgPSAwCiAgfQogIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgewogICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDAKICB9CiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7CiAgICB0aGlzU3RhcnQgPSAwCiAgfQogIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHsKICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aAogIH0KCiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JykKICB9CgogIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHsKICAgIHJldHVybiAwCiAgfQogIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkgewogICAgcmV0dXJuIC0xCiAgfQogIGlmIChzdGFydCA+PSBlbmQpIHsKICAgIHJldHVybiAxCiAgfQoKICBzdGFydCA+Pj49IDAKICBlbmQgPj4+PSAwCiAgdGhpc1N0YXJ0ID4+Pj0gMAogIHRoaXNFbmQgPj4+PSAwCgogIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwCgogIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydAogIHZhciB5ID0gZW5kIC0gc3RhcnQKICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSkKCiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpCiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCkKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7CiAgICAgIHggPSB0aGlzQ29weVtpXQogICAgICB5ID0gdGFyZ2V0Q29weVtpXQogICAgICBicmVhawogICAgfQogIH0KCiAgaWYgKHggPCB5KSByZXR1cm4gLTEKICBpZiAoeSA8IHgpIHJldHVybiAxCiAgcmV0dXJuIDAKfQoKLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLAovLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLgovLwovLyBBcmd1bWVudHM6Ci8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoCi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyCi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMgovLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZwovLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZgpmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2gKICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xCgogIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0CiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykgewogICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0CiAgICBieXRlT2Zmc2V0ID0gMAogIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHsKICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmCiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHsKICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMAogIH0KICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuCiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7CiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCAiZm9vIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyCiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSkKICB9CgogIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyCiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQKICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7CiAgICBpZiAoZGlyKSByZXR1cm4gLTEKICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxCiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkgewogICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDAKICAgIGVsc2UgcmV0dXJuIC0xCiAgfQoKICAvLyBOb3JtYWxpemUgdmFsCiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7CiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKQogIH0KCiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2YKICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHsKICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHMKICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiAtMQogICAgfQogICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikKICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7CiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV0KICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykgewogICAgICBpZiAoZGlyKSB7CiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCkKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCkKICAgICAgfQogICAgfQogICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpCiAgfQoKICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKQp9CgpmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgdmFyIGluZGV4U2l6ZSA9IDEKICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aAogIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoCgogIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7CiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKQogICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHwKICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7CiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikgewogICAgICAgIHJldHVybiAtMQogICAgICB9CiAgICAgIGluZGV4U2l6ZSA9IDIKICAgICAgYXJyTGVuZ3RoIC89IDIKICAgICAgdmFsTGVuZ3RoIC89IDIKICAgICAgYnl0ZU9mZnNldCAvPSAyCiAgICB9CiAgfQoKICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHsKICAgIGlmIChpbmRleFNpemUgPT09IDEpIHsKICAgICAgcmV0dXJuIGJ1ZltpXQogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSkKICAgIH0KICB9CgogIHZhciBpCiAgaWYgKGRpcikgewogICAgdmFyIGZvdW5kSW5kZXggPSAtMQogICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7CiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHsKICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpCiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZQogICAgICB9IGVsc2UgewogICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleAogICAgICAgIGZvdW5kSW5kZXggPSAtMQogICAgICB9CiAgICB9CiAgfSBlbHNlIHsKICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoCiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkgewogICAgICB2YXIgZm91bmQgPSB0cnVlCiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHsKICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7CiAgICAgICAgICBmb3VuZCA9IGZhbHNlCiAgICAgICAgICBicmVhawogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoZm91bmQpIHJldHVybiBpCiAgICB9CiAgfQoKICByZXR1cm4gLTEKfQoKQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTEKfQoKQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKQp9CgpCdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpCn0KCmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwCiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQKICBpZiAoIWxlbmd0aCkgewogICAgbGVuZ3RoID0gcmVtYWluaW5nCiAgfSBlbHNlIHsKICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpCiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7CiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZwogICAgfQogIH0KCiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHMKICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aAogIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKQoKICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewogICAgbGVuZ3RoID0gc3RyTGVuIC8gMgogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KQogICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpCiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQKICB9CiAgcmV0dXJuIGkKfQoKZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCkKfQoKZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKfQoKZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCkKfQoKZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7CiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZykKICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHsKICAgIGVuY29kaW5nID0gJ3V0ZjgnCiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aAogICAgb2Zmc2V0ID0gMAogIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKQogIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHsKICAgIGVuY29kaW5nID0gb2Zmc2V0CiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aAogICAgb2Zmc2V0ID0gMAogIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pCiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7CiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7CiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMAogICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCcKICAgIH0gZWxzZSB7CiAgICAgIGVuY29kaW5nID0gbGVuZ3RoCiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZAogICAgfQogIH0gZWxzZSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCcKICAgICkKICB9CgogIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldAogIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZwoKICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJykKICB9CgogIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnCgogIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlCiAgZm9yICg7OykgewogICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICBjYXNlICdoZXgnOgogICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgY2FzZSAndXRmOCc6CiAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICdhc2NpaSc6CiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlCiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKQogICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZQogICAgfQogIH0KfQoKQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkgewogIHJldHVybiB7CiAgICB0eXBlOiAnQnVmZmVyJywKICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKQogIH0KfQoKZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHsKICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpCiAgfSBlbHNlIHsKICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpCiAgfQp9CgpmdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKICB2YXIgcmVzID0gW10KCiAgdmFyIGkgPSBzdGFydAogIHdoaWxlIChpIDwgZW5kKSB7CiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldCiAgICB2YXIgY29kZVBvaW50ID0gbnVsbAogICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0CiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gMwogICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDIKICAgICAgOiAxCgogICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkgewogICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50CgogICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHsKICAgICAgICBjYXNlIDE6CiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkgewogICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGUKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrCiAgICAgICAgY2FzZSAyOgogICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV0KICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKQogICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHsKICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrCiAgICAgICAgY2FzZSAzOgogICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV0KICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl0KICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkgewogICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRikKICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDQ6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXQogICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM10KICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKQogICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHsKICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHsKICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYQogICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlCiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRAogICAgICBieXRlc1BlclNlcXVlbmNlID0gMQogICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHsKICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSkKICAgICAgY29kZVBvaW50IC09IDB4MTAwMDAKICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKQogICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRgogICAgfQoKICAgIHJlcy5wdXNoKGNvZGVQb2ludCkKICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZQogIH0KCiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpCn0KCi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aAovLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuCi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHkKdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwCgpmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHsKICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGgKICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7CiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKCkKICB9CgogIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZCIuCiAgdmFyIHJlcyA9ICcnCiAgdmFyIGkgPSAwCiAgd2hpbGUgKGkgPCBsZW4pIHsKICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KAogICAgICBTdHJpbmcsCiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkKICAgICkKICB9CiAgcmV0dXJuIHJlcwp9CgpmdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKICB2YXIgcmV0ID0gJycKICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpCgogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKQogIH0KICByZXR1cm4gcmV0Cn0KCmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKICB2YXIgcmV0ID0gJycKICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpCgogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pCiAgfQogIHJldHVybiByZXQKfQoKZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciBsZW4gPSBidWYubGVuZ3RoCgogIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDAKICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuCgogIHZhciBvdXQgPSAnJwogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKQogIH0KICByZXR1cm4gb3V0Cn0KCmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpCiAgdmFyIHJlcyA9ICcnCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikgewogICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSkKICB9CiAgcmV0dXJuIHJlcwp9CgpCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHsKICB2YXIgbGVuID0gdGhpcy5sZW5ndGgKICBzdGFydCA9IH5+c3RhcnQKICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kCgogIGlmIChzdGFydCA8IDApIHsKICAgIHN0YXJ0ICs9IGxlbgogICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwCiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikgewogICAgc3RhcnQgPSBsZW4KICB9CgogIGlmIChlbmQgPCAwKSB7CiAgICBlbmQgKz0gbGVuCiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMAogIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7CiAgICBlbmQgPSBsZW4KICB9CgogIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQKCiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkKICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZQogIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlCiAgcmV0dXJuIG5ld0J1Zgp9CgovKgogKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy4KICovCmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7CiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JykKICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpCgogIHZhciB2YWwgPSB0aGlzW29mZnNldF0KICB2YXIgbXVsID0gMQogIHZhciBpID0gMAogIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bAogIH0KCiAgcmV0dXJuIHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKQogIH0KCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXQogIHZhciBtdWwgPSAxCiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsCiAgfQoKICByZXR1cm4gdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCkKICByZXR1cm4gdGhpc1tvZmZzZXRdCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCkKICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfAogICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8CiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgKwogICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKQoKICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgKwogICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8CiAgICB0aGlzW29mZnNldCArIDNdKQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XQogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsCiAgfQogIG11bCAqPSAweDgwCgogIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpCgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpCgogIHZhciBpID0gYnl0ZUxlbmd0aAogIHZhciBtdWwgPSAxCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXQogIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bAogIH0KICBtdWwgKj0gMHg4MAoKICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKQoKICByZXR1cm4gdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpCiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKQogIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KQogIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCkKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCkKICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAodGhpc1tvZmZzZXRdKSB8CiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8CiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfAogICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8CiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfAogICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfAogICAgKHRoaXNbb2Zmc2V0ICsgM10pCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCkKICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCkKICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KQp9CgpmdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignImJ1ZmZlciIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpCiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJykKICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMQogICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApCiAgfQoKICB2YXIgbXVsID0gMQogIHZhciBpID0gMAogIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRgogIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkYKICB9CgogIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMQogICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApCiAgfQoKICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxCiAgdmFyIG11bCA9IDEKICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkYKICB9CgogIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDEKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpCiAgcmV0dXJuIG9mZnNldCArIDIKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDIKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApCiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpCgogICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpCiAgfQoKICB2YXIgaSA9IDAKICB2YXIgbXVsID0gMQogIHZhciBzdWIgPSAwCiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CiAgICAgIHN1YiA9IDEKICAgIH0KICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkYKICB9CgogIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSkKCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCkKICB9CgogIHZhciBpID0gYnl0ZUxlbmd0aCAtIDEKICB2YXIgbXVsID0gMQogIHZhciBzdWIgPSAwCiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRgogIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHsKICAgICAgc3ViID0gMQogICAgfQogICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCkKICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDEKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHJldHVybiBvZmZzZXQgKyAxCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDIKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpCiAgcmV0dXJuIG9mZnNldCArIDQKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCkKICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEKICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KQogIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KQogIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDQKfQoKZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKQp9CgpmdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KQogIH0KICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCkKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCkKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KQp9CgpmdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KQogIH0KICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCkKICByZXR1cm4gb2Zmc2V0ICsgOAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCkKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KQp9CgovLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpCkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHsKICBpZiAoIXN0YXJ0KSBzdGFydCA9IDAKICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoCiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aAogIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMAogIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydAoKICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmUKICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDAKICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDAKCiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9ucwogIGlmICh0YXJnZXRTdGFydCA8IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJykKICB9CiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKQogIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKQoKICAvLyBBcmUgd2Ugb29iPwogIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGgKICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHsKICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0CiAgfQoKICB2YXIgbGVuID0gZW5kIC0gc3RhcnQKICB2YXIgaQoKICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHsKICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZAogICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF0KICAgIH0KICB9IGVsc2UgaWYgKGxlbiA8IDEwMDApIHsKICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnQKICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkgewogICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XQogICAgfQogIH0gZWxzZSB7CiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCgKICAgICAgdGFyZ2V0LAogICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksCiAgICAgIHRhcmdldFN0YXJ0CiAgICApCiAgfQoKICByZXR1cm4gbGVuCn0KCi8vIFVzYWdlOgovLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSkKLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pCi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKQpCdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7CiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczoKICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7CiAgICAgIGVuY29kaW5nID0gc3RhcnQKICAgICAgc3RhcnQgPSAwCiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoCiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7CiAgICAgIGVuY29kaW5nID0gZW5kCiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoCiAgICB9CiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkgewogICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApCiAgICAgIGlmIChjb2RlIDwgMjU2KSB7CiAgICAgICAgdmFsID0gY29kZQogICAgICB9CiAgICB9CiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKQogICAgfQogICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCiAgICB9CiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykgewogICAgdmFsID0gdmFsICYgMjU1CiAgfQoKICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS4KICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKQogIH0KCiAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgcmV0dXJuIHRoaXMKICB9CgogIHN0YXJ0ID0gc3RhcnQgPj4+IDAKICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwCgogIGlmICghdmFsKSB2YWwgPSAwCgogIHZhciBpCiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7CiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgIHRoaXNbaV0gPSB2YWwKICAgIH0KICB9IGVsc2UgewogICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbCkKICAgICAgPyB2YWwKICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpCiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoCiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkgewogICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXQogICAgfQogIH0KCiAgcmV0dXJuIHRoaXMKfQoKLy8gSEVMUEVSIEZVTkNUSU9OUwovLyA9PT09PT09PT09PT09PT09Cgp2YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nCgpmdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7CiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxuIGFuZCBcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdAogIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpCiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJwogIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnCiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90CiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7CiAgICBzdHIgPSBzdHIgKyAnPScKICB9CiAgcmV0dXJuIHN0cgp9CgpmdW5jdGlvbiB0b0hleCAobikgewogIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KQogIHJldHVybiBuLnRvU3RyaW5nKDE2KQp9CgpmdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykgewogIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHkKICB2YXIgY29kZVBvaW50CiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgKICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGwKICB2YXIgYnl0ZXMgPSBbXQoKICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKQoKICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnQKICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7CiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkCiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkgewogICAgICAgIC8vIG5vIGxlYWQgeWV0CiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikgewogICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbAogICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICAgICAgICBjb250aW51ZQogICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkgewogICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZAogICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICAgICAgICBjb250aW51ZQogICAgICAgIH0KCiAgICAgICAgLy8gdmFsaWQgbGVhZAogICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQKCiAgICAgICAgY29udGludWUKICAgICAgfQoKICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvdwogICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7CiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludAogICAgICAgIGNvbnRpbnVlCiAgICAgIH0KCiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyCiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDAKICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkgewogICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkCiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKQogICAgfQoKICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsCgogICAgLy8gZW5jb2RlIHV0ZjgKICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7CiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVhawogICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCkKICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHsKICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsCiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODAKICAgICAgKQogICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7CiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVhawogICAgICBieXRlcy5wdXNoKAogICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLAogICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwKICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MAogICAgICApCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7CiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhawogICAgICBieXRlcy5wdXNoKAogICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCwKICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsCiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLAogICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwCiAgICAgICkKICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JykKICAgIH0KICB9CgogIHJldHVybiBieXRlcwp9CgpmdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikgewogIHZhciBieXRlQXJyYXkgPSBbXQogIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi4KICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRikKICB9CiAgcmV0dXJuIGJ5dGVBcnJheQp9CgpmdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykgewogIHZhciBjLCBoaSwgbG8KICB2YXIgYnl0ZUFycmF5ID0gW10KICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrCgogICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpCiAgICBoaSA9IGMgPj4gOAogICAgbG8gPSBjICUgMjU2CiAgICBieXRlQXJyYXkucHVzaChsbykKICAgIGJ5dGVBcnJheS5wdXNoKGhpKQogIH0KCiAgcmV0dXJuIGJ5dGVBcnJheQp9CgpmdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHsKICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpCn0KCmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkgewogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWsKICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXQogIH0KICByZXR1cm4gaQp9CgovLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrCi8vIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjYKZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7CiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8CiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiYKICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykKfQoKLy8gTm9kZSAwLjEwIHN1cHBvcnRzIGBBcnJheUJ1ZmZlcmAgYnV0IGxhY2tzIGBBcnJheUJ1ZmZlci5pc1ZpZXdgCmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3IChvYmopIHsKICByZXR1cm4gKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpICYmIEFycmF5QnVmZmVyLmlzVmlldyhvYmopCn0KCmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHsKICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmUKfQoKfSx7ImJhc2U2NC1qcyI6MTcsImllZWU3NTQiOjEwMX1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduOwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOjMzLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduIjo4N31dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpOwp2YXIgJE9iamVjdCA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHsKICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7Cn07Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6MzMsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUiOjg4fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7CnZhciAkT2JqZWN0ID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7CiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7Cn07Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6MzMsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkiOjg5fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6MzMsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mIjo5MH1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mOwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOjMzLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZiI6OTF9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpOwpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpOwpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6MzMsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmciOjkyLCIuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wiOjk0LCIuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IiOjk1LCIuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZSI6OTZ9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpOwpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTsKCn0seyIuLi8uLi9tb2R1bGVzL193a3MtZXh0Ijo4NCwiLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yIjo5MywiLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlIjo5N31dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7CiAgcmV0dXJuIGl0Owp9OwoKfSx7fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTsKCn0se31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTsKICByZXR1cm4gaXQ7Cn07Cgp9LHsiLi9faXMtb2JqZWN0Ijo0OX1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZgovLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlcwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgdG9MZW5ndGggPSBfZGVyZXFfKCcuL190by1sZW5ndGgnKTsKdmFyIHRvQWJzb2x1dGVJbmRleCA9IF9kZXJlcV8oJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7CiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkgewogICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpOwogICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTsKICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7CiAgICB2YXIgdmFsdWU7CiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlCiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkgewogICAgICB2YWx1ZSA9IE9baW5kZXgrK107CiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUKICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTsKICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3QKICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHsKICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7CiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7CiAgfTsKfTsKCn0seyIuL190by1hYnNvbHV0ZS1pbmRleCI6NzYsIi4vX3RvLWlvYmplY3QiOjc4LCIuL190by1sZW5ndGgiOjc5fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZzsKCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTsKfTsKCn0se31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS4xJyB9OwppZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZgoKfSx7fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmcKdmFyIGFGdW5jdGlvbiA9IF9kZXJlcV8oJy4vX2EtZnVuY3Rpb24nKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkgewogIGFGdW5jdGlvbihmbik7CiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuOwogIHN3aXRjaCAobGVuZ3RoKSB7CiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkgewogICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTsKICAgIH07CiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikgewogICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTsKICAgIH07CiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykgewogICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTsKICAgIH07CiAgfQogIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykgewogICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7CiAgfTsKfTsKCn0seyIuL19hLWZ1bmN0aW9uIjoyOH1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNhbGwgbWV0aG9kIG9uICAiICsgaXQpOwogIHJldHVybiBpdDsKfTsKCn0se31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eQptb2R1bGUuZXhwb3J0cyA9ICFfZGVyZXFfKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsKICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNzsKfSk7Cgp9LHsiLi9fZmFpbHMiOjQxfV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKdmFyIGRvY3VtZW50ID0gX2RlcmVxXygnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7Ci8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRQp2YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTsKfTsKCn0seyIuL19nbG9iYWwiOjQyLCIuL19pcy1vYmplY3QiOjQ5fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzCm1vZHVsZS5leHBvcnRzID0gKAogICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnCikuc3BsaXQoJywnKTsKCn0se31dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHMKdmFyIGdldEtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cycpOwp2YXIgZ09QUyA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BzJyk7CnZhciBwSUUgPSBfZGVyZXFfKCcuL19vYmplY3QtcGllJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpOwogIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mOwogIGlmIChnZXRTeW1ib2xzKSB7CiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpOwogICAgdmFyIGlzRW51bSA9IHBJRS5mOwogICAgdmFyIGkgPSAwOwogICAgdmFyIGtleTsKICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTsKICB9IHJldHVybiByZXN1bHQ7Cn07Cgp9LHsiLi9fb2JqZWN0LWdvcHMiOjYzLCIuL19vYmplY3Qta2V5cyI6NjYsIi4vX29iamVjdC1waWUiOjY3fV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZ2xvYmFsID0gX2RlcmVxXygnLi9fZ2xvYmFsJyk7CnZhciBjb3JlID0gX2RlcmVxXygnLi9fY29yZScpOwp2YXIgY3R4ID0gX2RlcmVxXygnLi9fY3R4Jyk7CnZhciBoaWRlID0gX2RlcmVxXygnLi9faGlkZScpOwp2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7Cgp2YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHsKICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjsKICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRzsKICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUzsKICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QOwogIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjsKICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7CiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTsKICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07CiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07CiAgdmFyIGtleSwgb3duLCBvdXQ7CiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTsKICBmb3IgKGtleSBpbiBzb3VyY2UpIHsKICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZQogICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDsKICAgIGlmIChvd24gJiYga2V5IGluIGV4cG9ydHMpIGNvbnRpbnVlOwogICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWQKICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07CiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXMKICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldCiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dAogICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkKICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5CiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7CiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsKICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHsKICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkgewogICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpOwogICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTsKICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7CiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTsKICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTsKICAgICAgcmV0dXJuIEY7CiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHMKICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDsKICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJQogICAgaWYgKElTX1BST1RPKSB7CiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDsKICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSUKICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTsKICAgIH0KICB9Cn07Ci8vIHR5cGUgYml0bWFwCiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkCiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsCiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljCiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG8KJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kCiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcAokZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmUKJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgCm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsKCn0seyIuL19jb3JlIjozMywiLi9fY3R4IjozNCwiLi9fZ2xvYmFsIjo0MiwiLi9faGlkZSI6NDR9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHsKICB0cnkgewogICAgcmV0dXJuICEhZXhlYygpOwogIH0gY2F0Y2ggKGUpIHsKICAgIHJldHVybiB0cnVlOwogIH0KfTsKCn0se31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjgKdmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoCiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMKICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7CmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYKCn0se31dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHsKICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTsKfTsKCn0se31dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGRQID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwJyk7CnZhciBjcmVhdGVEZXNjID0gX2RlcmVxXygnLi9fcHJvcGVydHktZGVzYycpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7CiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTsKfSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHsKICBvYmplY3Rba2V5XSA9IHZhbHVlOwogIHJldHVybiBvYmplY3Q7Cn07Cgp9LHsiLi9fZGVzY3JpcHRvcnMiOjM2LCIuL19vYmplY3QtZHAiOjU4LCIuL19wcm9wZXJ0eS1kZXNjIjo2OX1dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGRvY3VtZW50ID0gX2RlcmVxXygnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7Cm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OwoKfSx7Ii4vX2dsb2JhbCI6NDJ9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gIV9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJykgJiYgIV9kZXJlcV8oJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgewogIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2RlcmVxXygnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7Cn0pOwoKfSx7Ii4vX2Rlc2NyaXB0b3JzIjozNiwiLi9fZG9tLWNyZWF0ZSI6MzcsIi4vX2ZhaWxzIjo0MX1dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3MKdmFyIGNvZiA9IF9kZXJlcV8oJy4vX2NvZicpOwovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zCm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7Cn07Cgp9LHsiLi9fY29mIjozMn1dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudCkKdmFyIGNvZiA9IF9kZXJlcV8oJy4vX2NvZicpOwptb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHsKICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5JzsKfTsKCn0seyIuL19jb2YiOjMyfV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7Cn07Cgp9LHt9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKdmFyIGNyZWF0ZSA9IF9kZXJlcV8oJy4vX29iamVjdC1jcmVhdGUnKTsKdmFyIGRlc2NyaXB0b3IgPSBfZGVyZXFfKCcuL19wcm9wZXJ0eS1kZXNjJyk7CnZhciBzZXRUb1N0cmluZ1RhZyA9IF9kZXJlcV8oJy4vX3NldC10by1zdHJpbmctdGFnJyk7CnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OwoKLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKCkKX2RlcmVxXygnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCBfZGVyZXFfKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkgewogIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pOwogIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpOwp9OwoKfSx7Ii4vX2hpZGUiOjQ0LCIuL19vYmplY3QtY3JlYXRlIjo1NywiLi9fcHJvcGVydHktZGVzYyI6NjksIi4vX3NldC10by1zdHJpbmctdGFnIjo3MiwiLi9fd2tzIjo4NX1dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwp2YXIgTElCUkFSWSA9IF9kZXJlcV8oJy4vX2xpYnJhcnknKTsKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKdmFyIHJlZGVmaW5lID0gX2RlcmVxXygnLi9fcmVkZWZpbmUnKTsKdmFyIGhpZGUgPSBfZGVyZXFfKCcuL19oaWRlJyk7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIEl0ZXJhdG9ycyA9IF9kZXJlcV8oJy4vX2l0ZXJhdG9ycycpOwp2YXIgJGl0ZXJDcmVhdGUgPSBfZGVyZXFfKCcuL19pdGVyLWNyZWF0ZScpOwp2YXIgc2V0VG9TdHJpbmdUYWcgPSBfZGVyZXFfKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpOwp2YXIgZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCcuL19vYmplY3QtZ3BvJyk7CnZhciBJVEVSQVRPUiA9IF9kZXJlcV8oJy4vX3drcycpKCdpdGVyYXRvcicpOwp2YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGAKdmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InOwp2YXIgS0VZUyA9ICdrZXlzJzsKdmFyIFZBTFVFUyA9ICd2YWx1ZXMnOwoKdmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9OwoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7CiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpOwogIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkgewogICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07CiAgICBzd2l0Y2ggKGtpbmQpIHsKICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTsKICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07CiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9OwogIH07CiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJzsKICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTOwogIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7CiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7CiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07CiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7CiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDsKICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7CiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7CiAgLy8gRml4IG5hdGl2ZQogIGlmICgkYW55TmF0aXZlKSB7CiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7CiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkgewogICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzCiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpOwogICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXMKICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpOwogICAgfQogIH0KICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGCiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykgewogICAgVkFMVUVTX0JVRyA9IHRydWU7CiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTsKICB9CiAgLy8gRGVmaW5lIGl0ZXJhdG9yCiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7CiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpOwogIH0KICAvLyBQbHVnIGZvciBsaWJyYXJ5CiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7CiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzOwogIGlmIChERUZBVUxUKSB7CiAgICBtZXRob2RzID0gewogICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLAogICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSwKICAgICAgZW50cmllczogJGVudHJpZXMKICAgIH07CiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7CiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7CiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpOwogIH0KICByZXR1cm4gbWV0aG9kczsKfTsKCn0seyIuL19leHBvcnQiOjQwLCIuL19oYXMiOjQzLCIuL19oaWRlIjo0NCwiLi9faXRlci1jcmVhdGUiOjUwLCIuL19pdGVyYXRvcnMiOjUzLCIuL19saWJyYXJ5Ijo1NCwiLi9fb2JqZWN0LWdwbyI6NjQsIi4vX3JlZGVmaW5lIjo3MCwiLi9fc2V0LXRvLXN0cmluZy10YWciOjcyLCIuL193a3MiOjg1fV0sNTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkgewogIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07Cn07Cgp9LHt9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0ge307Cgp9LHt9XSw1NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsKCn0se31dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIE1FVEEgPSBfZGVyZXFfKCcuL191aWQnKSgnbWV0YScpOwp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgc2V0RGVzYyA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmY7CnZhciBpZCA9IDA7CnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHsKICByZXR1cm4gdHJ1ZTsKfTsKdmFyIEZSRUVaRSA9ICFfZGVyZXFfKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsKICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpOwp9KTsKdmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHsKICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7CiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSUQKICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzCiAgfSB9KTsKfTsKdmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkgewogIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXgKICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDsKICBpZiAoIWhhcyhpdCwgTUVUQSkpIHsKICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0CiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7CiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YQogICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7CiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YQogICAgc2V0TWV0YShpdCk7CiAgLy8gcmV0dXJuIG9iamVjdCBJRAogIH0gcmV0dXJuIGl0W01FVEFdLmk7Cn07CnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHsKICBpZiAoIWhhcyhpdCwgTUVUQSkpIHsKICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0CiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlOwogICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGEKICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7CiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YQogICAgc2V0TWV0YShpdCk7CiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHMKICB9IHJldHVybiBpdFtNRVRBXS53Owp9OwovLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmcKdmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7CiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7CiAgcmV0dXJuIGl0Owp9Owp2YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0gewogIEtFWTogTUVUQSwKICBORUVEOiBmYWxzZSwKICBmYXN0S2V5OiBmYXN0S2V5LAogIGdldFdlYWs6IGdldFdlYWssCiAgb25GcmVlemU6IG9uRnJlZXplCn07Cgp9LHsiLi9fZmFpbHMiOjQxLCIuL19oYXMiOjQzLCIuL19pcy1vYmplY3QiOjQ5LCIuL19vYmplY3QtZHAiOjU4LCIuL191aWQiOjgyfV0sNTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Ci8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLikKdmFyIGdldEtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cycpOwp2YXIgZ09QUyA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BzJyk7CnZhciBwSUUgPSBfZGVyZXFfKCcuL19vYmplY3QtcGllJyk7CnZhciB0b09iamVjdCA9IF9kZXJlcV8oJy4vX3RvLW9iamVjdCcpOwp2YXIgSU9iamVjdCA9IF9kZXJlcV8oJy4vX2lvYmplY3QnKTsKdmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduOwoKLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpCm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgX2RlcmVxXygnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7CiAgdmFyIEEgPSB7fTsKICB2YXIgQiA9IHt9OwogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZgogIHZhciBTID0gU3ltYm9sKCk7CiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnOwogIEFbU10gPSA3OwogIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pOwogIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLOwp9KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzCiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpOwogIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDsKICB2YXIgaW5kZXggPSAxOwogIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mOwogIHZhciBpc0VudW0gPSBwSUUuZjsKICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7CiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTsKICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTsKICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDsKICAgIHZhciBqID0gMDsKICAgIHZhciBrZXk7CiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTsKICB9IHJldHVybiBUOwp9IDogJGFzc2lnbjsKCn0seyIuL19mYWlscyI6NDEsIi4vX2lvYmplY3QiOjQ3LCIuL19vYmplY3QtZ29wcyI6NjMsIi4vX29iamVjdC1rZXlzIjo2NiwiLi9fb2JqZWN0LXBpZSI6NjcsIi4vX3RvLW9iamVjdCI6ODB9XSw1NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKQp2YXIgYW5PYmplY3QgPSBfZGVyZXFfKCcuL19hbi1vYmplY3QnKTsKdmFyIGRQcyA9IF9kZXJlcV8oJy4vX29iamVjdC1kcHMnKTsKdmFyIGVudW1CdWdLZXlzID0gX2RlcmVxXygnLi9fZW51bS1idWcta2V5cycpOwp2YXIgSUVfUFJPVE8gPSBfZGVyZXFfKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7CnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTsKdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnOwoKLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZQp2YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHsKICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1ZwogIHZhciBpZnJhbWUgPSBfZGVyZXFfKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpOwogIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoOwogIHZhciBsdCA9ICc8JzsKICB2YXIgZ3QgPSAnPic7CiAgdmFyIGlmcmFtZURvY3VtZW50OwogIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOwogIF9kZXJlcV8oJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpOwogIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmwKICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0OwogIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTsKICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50OwogIGlmcmFtZURvY3VtZW50Lm9wZW4oKTsKICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7CiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTsKICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjsKICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTsKICByZXR1cm4gY3JlYXRlRGljdCgpOwp9OwoKbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7CiAgdmFyIHJlc3VsdDsKICBpZiAoTyAhPT0gbnVsbCkgewogICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pOwogICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7CiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDsKICAgIC8vIGFkZCAiX19wcm90b19fIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsCiAgICByZXN1bHRbSUVfUFJPVE9dID0gTzsKICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpOwogIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTsKfTsKCn0seyIuL19hbi1vYmplY3QiOjMwLCIuL19kb20tY3JlYXRlIjozNywiLi9fZW51bS1idWcta2V5cyI6MzgsIi4vX2h0bWwiOjQ1LCIuL19vYmplY3QtZHBzIjo1OSwiLi9fc2hhcmVkLWtleSI6NzN9XSw1ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgSUU4X0RPTV9ERUZJTkUgPSBfZGVyZXFfKCcuL19pZTgtZG9tLWRlZmluZScpOwp2YXIgdG9QcmltaXRpdmUgPSBfZGVyZXFfKCcuL190by1wcmltaXRpdmUnKTsKdmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5OwoKZXhwb3J0cy5mID0gX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHsKICBhbk9iamVjdChPKTsKICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7CiAgYW5PYmplY3QoQXR0cmlidXRlcyk7CiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkgewogICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpOwogIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfQogIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7CiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7CiAgcmV0dXJuIE87Cn07Cgp9LHsiLi9fYW4tb2JqZWN0IjozMCwiLi9fZGVzY3JpcHRvcnMiOjM2LCIuL19pZTgtZG9tLWRlZmluZSI6NDYsIi4vX3RvLXByaW1pdGl2ZSI6ODF9XSw1OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBkUCA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpOwp2YXIgYW5PYmplY3QgPSBfZGVyZXFfKCcuL19hbi1vYmplY3QnKTsKdmFyIGdldEtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cycpOwoKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHsKICBhbk9iamVjdChPKTsKICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7CiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoOwogIHZhciBpID0gMDsKICB2YXIgUDsKICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTsKICByZXR1cm4gTzsKfTsKCn0seyIuL19hbi1vYmplY3QiOjMwLCIuL19kZXNjcmlwdG9ycyI6MzYsIi4vX29iamVjdC1kcCI6NTgsIi4vX29iamVjdC1rZXlzIjo2Nn1dLDYwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHBJRSA9IF9kZXJlcV8oJy4vX29iamVjdC1waWUnKTsKdmFyIGNyZWF0ZURlc2MgPSBfZGVyZXFfKCcuL19wcm9wZXJ0eS1kZXNjJyk7CnZhciB0b0lPYmplY3QgPSBfZGVyZXFfKCcuL190by1pb2JqZWN0Jyk7CnZhciB0b1ByaW1pdGl2ZSA9IF9kZXJlcV8oJy4vX3RvLXByaW1pdGl2ZScpOwp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciBJRThfRE9NX0RFRklORSA9IF9kZXJlcV8oJy4vX2llOC1kb20tZGVmaW5lJyk7CnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsKCmV4cG9ydHMuZiA9IF9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHsKICBPID0gdG9JT2JqZWN0KE8pOwogIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTsKICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7CiAgICByZXR1cm4gZ09QRChPLCBQKTsKICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH0KICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7Cn07Cgp9LHsiLi9fZGVzY3JpcHRvcnMiOjM2LCIuL19oYXMiOjQzLCIuL19pZTgtZG9tLWRlZmluZSI6NDYsIi4vX29iamVjdC1waWUiOjY3LCIuL19wcm9wZXJ0eS1kZXNjIjo2OSwiLi9fdG8taW9iamVjdCI6NzgsIi4vX3RvLXByaW1pdGl2ZSI6ODF9XSw2MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3cKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKdmFyIGdPUE4gPSBfZGVyZXFfKCcuL19vYmplY3QtZ29wbicpLmY7CnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nOwoKdmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMKICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTsKCnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkgewogIHRyeSB7CiAgICByZXR1cm4gZ09QTihpdCk7CiAgfSBjYXRjaCAoZSkgewogICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7CiAgfQp9OwoKbW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHsKICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpOwp9OwoKfSx7Ii4vX29iamVjdC1nb3BuIjo2MiwiLi9fdG8taW9iamVjdCI6Nzh9XSw2MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTykKdmFyICRrZXlzID0gX2RlcmVxXygnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTsKdmFyIGhpZGRlbktleXMgPSBfZGVyZXFfKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7CgpleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHsKICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7Cn07Cgp9LHsiLi9fZW51bS1idWcta2V5cyI6MzgsIi4vX29iamVjdC1rZXlzLWludGVybmFsIjo2NX1dLDYzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczsKCn0se31dLDY0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTykKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgdG9PYmplY3QgPSBfZGVyZXFfKCcuL190by1vYmplY3QnKTsKdmFyIElFX1BST1RPID0gX2RlcmVxXygnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpOwp2YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlOwoKbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHsKICBPID0gdG9PYmplY3QoTyk7CiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTsKICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3RvcikgewogICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlOwogIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7Cn07Cgp9LHsiLi9faGFzIjo0MywiLi9fc2hhcmVkLWtleSI6NzMsIi4vX3RvLW9iamVjdCI6ODB9XSw2NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKdmFyIGFycmF5SW5kZXhPZiA9IF9kZXJlcV8oJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpOwp2YXIgSUVfUFJPVE8gPSBfZGVyZXFfKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7CiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTsKICB2YXIgaSA9IDA7CiAgdmFyIHJlc3VsdCA9IFtdOwogIHZhciBrZXk7CiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTsKICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzCiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHsKICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn07Cgp9LHsiLi9fYXJyYXktaW5jbHVkZXMiOjMxLCIuL19oYXMiOjQzLCIuL19zaGFyZWQta2V5Ijo3MywiLi9fdG8taW9iamVjdCI6Nzh9XSw2NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKQp2YXIgJGtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpOwp2YXIgZW51bUJ1Z0tleXMgPSBfZGVyZXFfKCcuL19lbnVtLWJ1Zy1rZXlzJyk7Cgptb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykgewogIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7Cn07Cgp9LHsiLi9fZW51bS1idWcta2V5cyI6MzgsIi4vX29iamVjdC1rZXlzLWludGVybmFsIjo2NX1dLDY3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7Cgp9LHt9XSw2ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlcwp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwp2YXIgY29yZSA9IF9kZXJlcV8oJy4vX2NvcmUnKTsKdmFyIGZhaWxzID0gX2RlcmVxXygnLi9fZmFpbHMnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7CiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldOwogIHZhciBleHAgPSB7fTsKICBleHBbS0VZXSA9IGV4ZWMoZm4pOwogICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApOwp9OwoKfSx7Ii4vX2NvcmUiOjMzLCIuL19leHBvcnQiOjQwLCIuL19mYWlscyI6NDF9XSw2OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHsKICByZXR1cm4gewogICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSwKICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSwKICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLAogICAgdmFsdWU6IHZhbHVlCiAgfTsKfTsKCn0se31dLDcwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL19oaWRlJyk7Cgp9LHsiLi9faGlkZSI6NDR9XSw3MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLgovKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqLwp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKdmFyIGFuT2JqZWN0ID0gX2RlcmVxXygnLi9fYW4tb2JqZWN0Jyk7CnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykgewogIGFuT2JqZWN0KE8pOwogIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyAiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlISIpOwp9Owptb2R1bGUuZXhwb3J0cyA9IHsKICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lCiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkgewogICAgICB0cnkgewogICAgICAgIHNldCA9IF9kZXJlcV8oJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIF9kZXJlcV8oJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTsKICAgICAgICBzZXQodGVzdCwgW10pOwogICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpOwogICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfQogICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHsKICAgICAgICBjaGVjayhPLCBwcm90byk7CiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvOwogICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTsKICAgICAgICByZXR1cm4gTzsKICAgICAgfTsKICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksCiAgY2hlY2s6IGNoZWNrCn07Cgp9LHsiLi9fYW4tb2JqZWN0IjozMCwiLi9fY3R4IjozNCwiLi9faXMtb2JqZWN0Ijo0OSwiLi9fb2JqZWN0LWdvcGQiOjYwfV0sNzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZGVmID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwJykuZjsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgVEFHID0gX2RlcmVxXygnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7CiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTsKfTsKCn0seyIuL19oYXMiOjQzLCIuL19vYmplY3QtZHAiOjU4LCIuL193a3MiOjg1fV0sNzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgc2hhcmVkID0gX2RlcmVxXygnLi9fc2hhcmVkJykoJ2tleXMnKTsKdmFyIHVpZCA9IF9kZXJlcV8oJy4vX3VpZCcpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHsKICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpOwp9OwoKfSx7Ii4vX3NoYXJlZCI6NzQsIi4vX3VpZCI6ODJ9XSw3NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBnbG9iYWwgPSBfZGVyZXFfKCcuL19nbG9iYWwnKTsKdmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nOwp2YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkgewogIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pOwp9OwoKfSx7Ii4vX2dsb2JhbCI6NDJ9XSw3NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB0b0ludGVnZXIgPSBfZGVyZXFfKCcuL190by1pbnRlZ2VyJyk7CnZhciBkZWZpbmVkID0gX2RlcmVxXygnLi9fZGVmaW5lZCcpOwovLyB0cnVlICAtPiBTdHJpbmcjYXQKLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykgewogIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7CiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTsKICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7CiAgICB2YXIgbCA9IHMubGVuZ3RoOwogICAgdmFyIGEsIGI7CiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7CiAgICBhID0gcy5jaGFyQ29kZUF0KGkpOwogICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmYKICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGEKICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7CiAgfTsKfTsKCn0seyIuL19kZWZpbmVkIjozNSwiLi9fdG8taW50ZWdlciI6Nzd9XSw3NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB0b0ludGVnZXIgPSBfZGVyZXFfKCcuL190by1pbnRlZ2VyJyk7CnZhciBtYXggPSBNYXRoLm1heDsKdmFyIG1pbiA9IE1hdGgubWluOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7CiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpOwogIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpOwp9OwoKfSx7Ii4vX3RvLWludGVnZXIiOjc3fV0sNzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjEuNCBUb0ludGVnZXIKdmFyIGNlaWwgPSBNYXRoLmNlaWw7CnZhciBmbG9vciA9IE1hdGguZmxvb3I7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7Cn07Cgp9LHt9XSw3ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5ncwp2YXIgSU9iamVjdCA9IF9kZXJlcV8oJy4vX2lvYmplY3QnKTsKdmFyIGRlZmluZWQgPSBfZGVyZXFfKCcuL19kZWZpbmVkJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpOwp9OwoKfSx7Ii4vX2RlZmluZWQiOjM1LCIuL19pb2JqZWN0Ijo0N31dLDc5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gNy4xLjE1IFRvTGVuZ3RoCnZhciB0b0ludGVnZXIgPSBfZGVyZXFfKCcuL190by1pbnRlZ2VyJyk7CnZhciBtaW4gPSBNYXRoLm1pbjsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MQp9OwoKfSx7Ii4vX3RvLWludGVnZXIiOjc3fV0sODA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpCnZhciBkZWZpbmVkID0gX2RlcmVxXygnLi9fZGVmaW5lZCcpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpOwp9OwoKfSx7Ii4vX2RlZmluZWQiOjM1fV0sODE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSkKdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7Ci8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlCi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7CiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDsKICB2YXIgZm4sIHZhbDsKICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDsKICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDsKICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7CiAgdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKTsKfTsKCn0seyIuL19pcy1vYmplY3QiOjQ5fV0sODI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaWQgPSAwOwp2YXIgcHggPSBNYXRoLnJhbmRvbSgpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHsKICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpOwp9OwoKfSx7fV0sODM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZ2xvYmFsID0gX2RlcmVxXygnLi9fZ2xvYmFsJyk7CnZhciBjb3JlID0gX2RlcmVxXygnLi9fY29yZScpOwp2YXIgTElCUkFSWSA9IF9kZXJlcV8oJy4vX2xpYnJhcnknKTsKdmFyIHdrc0V4dCA9IF9kZXJlcV8oJy4vX3drcy1leHQnKTsKdmFyIGRlZmluZVByb3BlcnR5ID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwJykuZjsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkgewogIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7CiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pOwp9OwoKfSx7Ii4vX2NvcmUiOjMzLCIuL19nbG9iYWwiOjQyLCIuL19saWJyYXJ5Ijo1NCwiLi9fb2JqZWN0LWRwIjo1OCwiLi9fd2tzLWV4dCI6ODR9XSw4NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmV4cG9ydHMuZiA9IF9kZXJlcV8oJy4vX3drcycpOwoKfSx7Ii4vX3drcyI6ODV9XSw4NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBzdG9yZSA9IF9kZXJlcV8oJy4vX3NoYXJlZCcpKCd3a3MnKTsKdmFyIHVpZCA9IF9kZXJlcV8oJy4vX3VpZCcpOwp2YXIgU3ltYm9sID0gX2RlcmVxXygnLi9fZ2xvYmFsJykuU3ltYm9sOwp2YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJzsKCnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHsKICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID0KICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7Cn07CgokZXhwb3J0cy5zdG9yZSA9IHN0b3JlOwoKfSx7Ii4vX2dsb2JhbCI6NDIsIi4vX3NoYXJlZCI6NzQsIi4vX3VpZCI6ODJ9XSw4NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKdmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfZGVyZXFfKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTsKdmFyIHN0ZXAgPSBfZGVyZXFfKCcuL19pdGVyLXN0ZXAnKTsKdmFyIEl0ZXJhdG9ycyA9IF9kZXJlcV8oJy4vX2l0ZXJhdG9ycycpOwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwoKLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKQovLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKQovLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpCi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKQptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkgewogIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXQKICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleAogIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kCi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKQp9LCBmdW5jdGlvbiAoKSB7CiAgdmFyIE8gPSB0aGlzLl90OwogIHZhciBraW5kID0gdGhpcy5fazsKICB2YXIgaW5kZXggPSB0aGlzLl9pKys7CiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7CiAgICB0aGlzLl90ID0gdW5kZWZpbmVkOwogICAgcmV0dXJuIHN0ZXAoMSk7CiAgfQogIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpOwogIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7CiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pOwp9LCAndmFsdWVzJyk7CgovLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpCkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7CgphZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7CmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpOwphZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7Cgp9LHsiLi9fYWRkLXRvLXVuc2NvcGFibGVzIjoyOSwiLi9faXRlci1kZWZpbmUiOjUxLCIuL19pdGVyLXN0ZXAiOjUyLCIuL19pdGVyYXRvcnMiOjUzLCIuL190by1pb2JqZWN0Ijo3OH1dLDg3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSkKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKCiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IF9kZXJlcV8oJy4vX29iamVjdC1hc3NpZ24nKSB9KTsKCn0seyIuL19leHBvcnQiOjQwLCIuL19vYmplY3QtYXNzaWduIjo1Nn1dLDg4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pCiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IF9kZXJlcV8oJy4vX29iamVjdC1jcmVhdGUnKSB9KTsKCn0seyIuL19leHBvcnQiOjQwLCIuL19vYmplY3QtY3JlYXRlIjo1N31dLDg5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykKJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmYgfSk7Cgp9LHsiLi9fZGVzY3JpcHRvcnMiOjM2LCIuL19leHBvcnQiOjQwLCIuL19vYmplY3QtZHAiOjU4fV0sOTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTykKdmFyIHRvT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8tb2JqZWN0Jyk7CnZhciAkZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCcuL19vYmplY3QtZ3BvJyk7CgpfZGVyZXFfKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkgewogIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkgewogICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpOwogIH07Cn0pOwoKfSx7Ii4vX29iamVjdC1ncG8iOjY0LCIuL19vYmplY3Qtc2FwIjo2OCwiLi9fdG8tb2JqZWN0Ijo4MH1dLDkxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bykKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiBfZGVyZXFfKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7Cgp9LHsiLi9fZXhwb3J0Ijo0MCwiLi9fc2V0LXByb3RvIjo3MX1dLDkyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKYXJndW1lbnRzWzRdWzE4XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykKfSx7ImR1cCI6MTh9XSw5MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKdmFyICRhdCA9IF9kZXJlcV8oJy4vX3N0cmluZy1hdCcpKHRydWUpOwoKLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKQpfZGVyZXFfKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkgewogIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXQKICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleAovLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpCn0sIGZ1bmN0aW9uICgpIHsKICB2YXIgTyA9IHRoaXMuX3Q7CiAgdmFyIGluZGV4ID0gdGhpcy5faTsKICB2YXIgcG9pbnQ7CiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07CiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpOwogIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoOwogIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTsKfSk7Cgp9LHsiLi9faXRlci1kZWZpbmUiOjUxLCIuL19zdHJpbmctYXQiOjc1fV0sOTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Ci8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW0KdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciBERVNDUklQVE9SUyA9IF9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJyk7CnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CnZhciByZWRlZmluZSA9IF9kZXJlcV8oJy4vX3JlZGVmaW5lJyk7CnZhciBNRVRBID0gX2RlcmVxXygnLi9fbWV0YScpLktFWTsKdmFyICRmYWlscyA9IF9kZXJlcV8oJy4vX2ZhaWxzJyk7CnZhciBzaGFyZWQgPSBfZGVyZXFfKCcuL19zaGFyZWQnKTsKdmFyIHNldFRvU3RyaW5nVGFnID0gX2RlcmVxXygnLi9fc2V0LXRvLXN0cmluZy10YWcnKTsKdmFyIHVpZCA9IF9kZXJlcV8oJy4vX3VpZCcpOwp2YXIgd2tzID0gX2RlcmVxXygnLi9fd2tzJyk7CnZhciB3a3NFeHQgPSBfZGVyZXFfKCcuL193a3MtZXh0Jyk7CnZhciB3a3NEZWZpbmUgPSBfZGVyZXFfKCcuL193a3MtZGVmaW5lJyk7CnZhciBlbnVtS2V5cyA9IF9kZXJlcV8oJy4vX2VudW0ta2V5cycpOwp2YXIgaXNBcnJheSA9IF9kZXJlcV8oJy4vX2lzLWFycmF5Jyk7CnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgdG9QcmltaXRpdmUgPSBfZGVyZXFfKCcuL190by1wcmltaXRpdmUnKTsKdmFyIGNyZWF0ZURlc2MgPSBfZGVyZXFfKCcuL19wcm9wZXJ0eS1kZXNjJyk7CnZhciBfY3JlYXRlID0gX2RlcmVxXygnLi9fb2JqZWN0LWNyZWF0ZScpOwp2YXIgZ09QTkV4dCA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BuLWV4dCcpOwp2YXIgJEdPUEQgPSBfZGVyZXFfKCcuL19vYmplY3QtZ29wZCcpOwp2YXIgJERQID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwJyk7CnZhciAka2V5cyA9IF9kZXJlcV8oJy4vX29iamVjdC1rZXlzJyk7CnZhciBnT1BEID0gJEdPUEQuZjsKdmFyIGRQID0gJERQLmY7CnZhciBnT1BOID0gZ09QTkV4dC5mOwp2YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7CnZhciAkSlNPTiA9IGdsb2JhbC5KU09OOwp2YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTsKdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnOwp2YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7CnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7CnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsKdmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTsKdmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTsKdmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpOwp2YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTsKdmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nOwp2YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0OwovLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzMKdmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7CgovLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODcKdmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkgewogIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHsKICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH0KICB9KSkuYSAhPSA3Owp9KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7CiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7CiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07CiAgZFAoaXQsIGtleSwgRCk7CiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7Cn0gOiBkUDsKCnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykgewogIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7CiAgc3ltLl9rID0gdGFnOwogIHJldHVybiBzeW07Cn07Cgp2YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJzsKfSA6IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7Cn07Cgp2YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkgewogIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7CiAgYW5PYmplY3QoaXQpOwogIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7CiAgYW5PYmplY3QoRCk7CiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7CiAgICBpZiAoIUQuZW51bWVyYWJsZSkgewogICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpOwogICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlOwogICAgfSBlbHNlIHsKICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlOwogICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pOwogICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTsKICB9IHJldHVybiBkUChpdCwga2V5LCBEKTsKfTsKdmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkgewogIGFuT2JqZWN0KGl0KTsKICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpOwogIHZhciBpID0gMDsKICB2YXIgbCA9IGtleXMubGVuZ3RoOwogIHZhciBrZXk7CiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTsKICByZXR1cm4gaXQ7Cn07CnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7CiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApOwp9Owp2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7CiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTsKICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTsKICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7Cn07CnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHsKICBpdCA9IHRvSU9iamVjdChpdCk7CiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTsKICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47CiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpOwogIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7CiAgcmV0dXJuIEQ7Cn07CnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHsKICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpOwogIHZhciByZXN1bHQgPSBbXTsKICB2YXIgaSA9IDA7CiAgdmFyIGtleTsKICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgewogICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTsKICB9IHJldHVybiByZXN1bHQ7Cn07CnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7CiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvOwogIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTsKICB2YXIgcmVzdWx0ID0gW107CiAgdmFyIGkgPSAwOwogIHZhciBrZXk7CiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHsKICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7CiAgfSByZXR1cm4gcmVzdWx0Owp9OwoKLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pCmlmICghVVNFX05BVElWRSkgewogICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7CiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpOwogICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7CiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTsKICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7CiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7CiAgICB9OwogICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pOwogICAgcmV0dXJuIHdyYXAodGFnKTsKICB9OwogIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICByZXR1cm4gdGhpcy5fazsKICB9KTsKCiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7CiAgX2RlcmVxXygnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7CiAgX2RlcmVxXygnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7CiAgX2RlcmVxXygnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9sczsKCiAgaWYgKERFU0NSSVBUT1JTICYmICFfZGVyZXFfKCcuL19saWJyYXJ5JykpIHsKICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpOwogIH0KCiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkgewogICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTsKICB9Owp9CgokZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTsKCmZvciAodmFyIGVzNlN5bWJvbHMgPSAoCiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTQKICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnCikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7Cgpmb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pOwoKJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHsKICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSkKICAnZm9yJzogZnVuY3Rpb24gKGtleSkgewogICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKQogICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV0KICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpOwogIH0sCiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pCiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7CiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTsKICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTsKICB9LAogIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LAogIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfQp9KTsKCiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7CiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKQogIGNyZWF0ZTogJGNyZWF0ZSwKICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykKICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LAogIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpCiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsCiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKQogIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvciwKICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKQogIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLAogIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykKICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMKfSk7CgovLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSkKJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHsKICB2YXIgUyA9ICRTeW1ib2woKTsKICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fQogIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbAogIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzCiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nOwp9KSksICdKU09OJywgewogIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7CiAgICBpZiAoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZAogICAgdmFyIGFyZ3MgPSBbaXRdOwogICAgdmFyIGkgPSAxOwogICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7CiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7CiAgICByZXBsYWNlciA9IGFyZ3NbMV07CiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpICRyZXBsYWNlciA9IHJlcGxhY2VyOwogICAgaWYgKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsKICAgICAgaWYgKCRyZXBsYWNlcikgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTsKICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTsKICAgIH07CiAgICBhcmdzWzFdID0gcmVwbGFjZXI7CiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7CiAgfQp9KTsKCi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludCkKJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgX2RlcmVxXygnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7Ci8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10Kc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpOwovLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddCnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7Ci8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddCnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOwoKfSx7Ii4vX2FuLW9iamVjdCI6MzAsIi4vX2Rlc2NyaXB0b3JzIjozNiwiLi9fZW51bS1rZXlzIjozOSwiLi9fZXhwb3J0Ijo0MCwiLi9fZmFpbHMiOjQxLCIuL19nbG9iYWwiOjQyLCIuL19oYXMiOjQzLCIuL19oaWRlIjo0NCwiLi9faXMtYXJyYXkiOjQ4LCIuL19saWJyYXJ5Ijo1NCwiLi9fbWV0YSI6NTUsIi4vX29iamVjdC1jcmVhdGUiOjU3LCIuL19vYmplY3QtZHAiOjU4LCIuL19vYmplY3QtZ29wZCI6NjAsIi4vX29iamVjdC1nb3BuIjo2MiwiLi9fb2JqZWN0LWdvcG4tZXh0Ijo2MSwiLi9fb2JqZWN0LWdvcHMiOjYzLCIuL19vYmplY3Qta2V5cyI6NjYsIi4vX29iamVjdC1waWUiOjY3LCIuL19wcm9wZXJ0eS1kZXNjIjo2OSwiLi9fcmVkZWZpbmUiOjcwLCIuL19zZXQtdG8tc3RyaW5nLXRhZyI6NzIsIi4vX3NoYXJlZCI6NzQsIi4vX3RvLWlvYmplY3QiOjc4LCIuL190by1wcmltaXRpdmUiOjgxLCIuL191aWQiOjgyLCIuL193a3MiOjg1LCIuL193a3MtZGVmaW5lIjo4MywiLi9fd2tzLWV4dCI6ODR9XSw5NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpOwoKfSx7Ii4vX3drcy1kZWZpbmUiOjgzfV0sOTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTsKCn0seyIuL193a3MtZGVmaW5lIjo4M31dLDk3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi9lczYuYXJyYXkuaXRlcmF0b3InKTsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgaGlkZSA9IF9kZXJlcV8oJy4vX2hpZGUnKTsKdmFyIEl0ZXJhdG9ycyA9IF9kZXJlcV8oJy4vX2l0ZXJhdG9ycycpOwp2YXIgVE9fU1RSSU5HX1RBRyA9IF9kZXJlcV8oJy4vX3drcycpKCd0b1N0cmluZ1RhZycpOwoKdmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICsKICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICsKICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICsKICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArCiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTsKCmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7CiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07CiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07CiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTsKICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTsKICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7Cn0KCn0seyIuL19nbG9iYWwiOjQyLCIuL19oaWRlIjo0NCwiLi9faXRlcmF0b3JzIjo1MywiLi9fd2tzIjo4NSwiLi9lczYuYXJyYXkuaXRlcmF0b3IiOjg2fV0sOTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKEJ1ZmZlcil7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYAovLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC4KCmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7CiAgaWYgKEFycmF5LmlzQXJyYXkpIHsKICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7CiAgfQogIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nOwp9CmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7CgpmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJzsKfQpleHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjsKCmZ1bmN0aW9uIGlzTnVsbChhcmcpIHsKICByZXR1cm4gYXJnID09PSBudWxsOwp9CmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsOwoKZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PSBudWxsOwp9CmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDsKCmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJzsKfQpleHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7CgpmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7Cn0KZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nOwoKZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnOwp9CmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDsKCmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT09IHZvaWQgMDsKfQpleHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7CgpmdW5jdGlvbiBpc1JlZ0V4cChyZSkgewogIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOwp9CmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDsKCmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7Cn0KZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0OwoKZnVuY3Rpb24gaXNEYXRlKGQpIHsKICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJzsKfQpleHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTsKCmZ1bmN0aW9uIGlzRXJyb3IoZSkgewogIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTsKfQpleHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yOwoKZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJzsKfQpleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uOwoKZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2wKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7Cn0KZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlOwoKZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjsKCmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHsKICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pOwp9Cgp9KS5jYWxsKHRoaXMseyJpc0J1ZmZlciI6X2RlcmVxXygiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzIil9KQp9LHsiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzIjoxMDN9XSw5OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBvbmNlID0gX2RlcmVxXygnb25jZScpOwoKdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9OwoKdmFyIGlzUmVxdWVzdCA9IGZ1bmN0aW9uKHN0cmVhbSkgewoJcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJzsKfTsKCnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkgewoJcmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gMwp9OwoKdmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHsKCWlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpOwoJaWYgKCFvcHRzKSBvcHRzID0ge307CgoJY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwoKCXZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKCXZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKCXZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgKG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZSk7Cgl2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpOwoKCXZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkgewoJCWlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpOwoJfTsKCgl2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHsKCQl3cml0YWJsZSA9IGZhbHNlOwoJCWlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTsKCX07CgoJdmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7CgkJcmVhZGFibGUgPSBmYWxzZTsKCQlpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7Cgl9OwoKCXZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkgewoJCWNhbGxiYWNrLmNhbGwoc3RyZWFtLCBleGl0Q29kZSA/IG5ldyBFcnJvcignZXhpdGVkIHdpdGggZXJyb3IgY29kZTogJyArIGV4aXRDb2RlKSA6IG51bGwpOwoJfTsKCgl2YXIgb25jbG9zZSA9IGZ1bmN0aW9uKCkgewoJCWlmIChyZWFkYWJsZSAmJiAhKHJzICYmIHJzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTsKCQlpZiAod3JpdGFibGUgJiYgISh3cyAmJiB3cy5lbmRlZCkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7Cgl9OwoKCXZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHsKCQlzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7Cgl9OwoKCWlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgewoJCXN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7CgkJc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpOwoJCWlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTsKCQllbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7Cgl9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3cykgeyAvLyBsZWdhY3kgc3RyZWFtcwoJCXN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpOwoJCXN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7Cgl9CgoJaWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7CgoJc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7CglzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCWlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIGNhbGxiYWNrKTsKCXN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTsKCglyZXR1cm4gZnVuY3Rpb24oKSB7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTsKCQlpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25leGl0KTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY2FsbGJhY2spOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTsKCX07Cn07Cgptb2R1bGUuZXhwb3J0cyA9IGVvczsKCn0seyJvbmNlIjoxMTV9XSwxMDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgpmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7CiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9OwogIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7Cn0KbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7CgovLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLngKRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDsKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkOwoKLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlCi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuCkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7CgovLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3MKLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuCkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikgewogIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpCiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpOwogIHRoaXMuX21heExpc3RlbmVycyA9IG47CiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7CiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVyczsKCiAgaWYgKCF0aGlzLl9ldmVudHMpCiAgICB0aGlzLl9ldmVudHMgPSB7fTsKCiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LgogIGlmICh0eXBlID09PSAnZXJyb3InKSB7CiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fAogICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkgewogICAgICBlciA9IGFyZ3VtZW50c1sxXTsKICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnQKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyCiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkICJlcnJvciIgZXZlbnQuICgnICsgZXIgKyAnKScpOwogICAgICAgIGVyci5jb250ZXh0ID0gZXI7CiAgICAgICAgdGhyb3cgZXJyOwogICAgICB9CiAgICB9CiAgfQoKICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdOwoKICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpCiAgICByZXR1cm4gZmFsc2U7CgogIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7CiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHsKICAgICAgLy8gZmFzdCBjYXNlcwogICAgICBjYXNlIDE6CiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDI6CiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMzoKICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pOwogICAgICAgIGJyZWFrOwogICAgICAvLyBzbG93ZXIKICAgICAgZGVmYXVsdDoKICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfQogIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHsKICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpOwogICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsKICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykKICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpOwogIH0KCiAgcmV0dXJuIHRydWU7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHsKICB2YXIgbTsKCiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkKICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgogIGlmICghdGhpcy5fZXZlbnRzKQogICAgdGhpcy5fZXZlbnRzID0ge307CgogIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09ICJuZXdMaXN0ZW5lciIhIEJlZm9yZQogIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0ICJuZXdMaXN0ZW5lciIuCiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcikKICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLAogICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID8KICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTsKCiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pCiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC4KICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyOwogIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpCiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7CiAgZWxzZQogICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07CgogIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrCiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHsKICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkgewogICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzOwogICAgfSBlbHNlIHsKICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzOwogICAgfQoKICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7CiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlOwogICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICsKICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICsKICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJywKICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTsKICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMAogICAgICAgIGNvbnNvbGUudHJhY2UoKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7CiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkKICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgogIHZhciBmaXJlZCA9IGZhbHNlOwoKICBmdW5jdGlvbiBnKCkgewogICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTsKCiAgICBpZiAoIWZpcmVkKSB7CiAgICAgIGZpcmVkID0gdHJ1ZTsKICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH0KICB9CgogIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjsKICB0aGlzLm9uKHR5cGUsIGcpOwoKICByZXR1cm4gdGhpczsKfTsKCi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikgewogIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpOwoKICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKQogICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKCiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkKICAgIHJldHVybiB0aGlzOwoKICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdOwogIGxlbmd0aCA9IGxpc3QubGVuZ3RoOwogIHBvc2l0aW9uID0gLTE7CgogIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fAogICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHsKICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07CiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKQogICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpOwoKICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7CiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7CiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fAogICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7CiAgICAgICAgcG9zaXRpb24gPSBpOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CgogICAgaWYgKHBvc2l0aW9uIDwgMCkKICAgICAgcmV0dXJuIHRoaXM7CgogICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7CiAgICAgIGxpc3QubGVuZ3RoID0gMDsKICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTsKICAgIH0gZWxzZSB7CiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTsKICAgIH0KCiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKQogICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpOwogIH0KCiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHsKICB2YXIga2V5LCBsaXN0ZW5lcnM7CgogIGlmICghdGhpcy5fZXZlbnRzKQogICAgcmV0dXJuIHRoaXM7CgogIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXQKICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApCiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9OwogICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKQogICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHMKICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgewogICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7CiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlOwogICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpOwogICAgfQogICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7CiAgICB0aGlzLl9ldmVudHMgPSB7fTsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdOwoKICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7CiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7CiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHsKICAgIC8vIExJRk8gb3JkZXIKICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKQogICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pOwogIH0KICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdOwoKICByZXR1cm4gdGhpczsKfTsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkgewogIHZhciByZXQ7CiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkKICAgIHJldCA9IFtdOwogIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSkKICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dOwogIGVsc2UKICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpOwogIHJldHVybiByZXQ7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7CiAgaWYgKHRoaXMuX2V2ZW50cykgewogICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07CgogICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpCiAgICAgIHJldHVybiAxOwogICAgZWxzZSBpZiAoZXZsaXN0ZW5lcikKICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoOwogIH0KICByZXR1cm4gMDsKfTsKCkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkgewogIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7Cn07CgpmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nOwp9CgpmdW5jdGlvbiBpc051bWJlcihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7Cn0KCmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7Cn0KCmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT09IHZvaWQgMDsKfQoKfSx7fV0sMTAxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICB2YXIgZSwgbQogIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxCiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEKICB2YXIgZUJpYXMgPSBlTWF4ID4+IDEKICB2YXIgbkJpdHMgPSAtNwogIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAKICB2YXIgZCA9IGlzTEUgPyAtMSA6IDEKICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXQoKICBpICs9IGQKCiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSkKICBzID4+PSAoLW5CaXRzKQogIG5CaXRzICs9IGVMZW4KICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKQogIGUgPj49ICgtbkJpdHMpCiAgbkJpdHMgKz0gbUxlbgogIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9CgogIGlmIChlID09PSAwKSB7CiAgICBlID0gMSAtIGVCaWFzCiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7CiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSkKICB9IGVsc2UgewogICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKQogICAgZSA9IGUgLSBlQmlhcwogIH0KICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKQp9CgpleHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgdmFyIGUsIG0sIGMKICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMQogIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxCiAgdmFyIGVCaWFzID0gZU1heCA+PiAxCiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKQogIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSkKICB2YXIgZCA9IGlzTEUgPyAxIDogLTEKICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMAoKICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKQoKICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkgewogICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwCiAgICBlID0gZU1heAogIH0gZWxzZSB7CiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMikKICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHsKICAgICAgZS0tCiAgICAgIGMgKj0gMgogICAgfQogICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgIHZhbHVlICs9IHJ0IC8gYwogICAgfSBlbHNlIHsKICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpCiAgICB9CiAgICBpZiAodmFsdWUgKiBjID49IDIpIHsKICAgICAgZSsrCiAgICAgIGMgLz0gMgogICAgfQoKICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkgewogICAgICBtID0gMAogICAgICBlID0gZU1heAogICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbikKICAgICAgZSA9IGUgKyBlQmlhcwogICAgfSBlbHNlIHsKICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pCiAgICAgIGUgPSAwCiAgICB9CiAgfQoKICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fQoKICBlID0gKGUgPDwgbUxlbikgfCBtCiAgZUxlbiArPSBtTGVuCiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fQoKICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjgKfQoKfSx7fV0sMTAyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7CiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGUKICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3RvcikgewogICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3IKICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7CiAgICAgIGNvbnN0cnVjdG9yOiB7CiAgICAgICAgdmFsdWU6IGN0b3IsCiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgIH0KICAgIH0pOwogIH07Cn0gZWxzZSB7CiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnMKICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3RvcikgewogICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3IKICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9CiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlCiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpCiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3IKICB9Cn0KCn0se31dLDEwMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8qIQogKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyCiAqCiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+CiAqIEBsaWNlbnNlICBNSVQKICovCgovLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nCi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7CiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcikKfQoKZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikgewogIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopCn0KCi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuCmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7CiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpCn0KCn0se31dLDEwNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nOwoKbW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHsKICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7Cn07Cgp9LHt9XSwxMDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoidXNlIHN0cmljdCI7CgovLyB1aW50MzIgKHR3bydzIGNvbXBsZW1lbnQpIG1heAovLyBtb3JlIGNvbnNlcnZhdGl2ZSB0aGFuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSCnZhciBNQVggPSA0Mjk0OTY3Mjk1Owp2YXIgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTsKCm1vZHVsZS5leHBvcnRzID0gZ2V0VW5pcXVlSWQ7CgpmdW5jdGlvbiBnZXRVbmlxdWVJZCgpIHsKICBpZENvdW50ZXIgPSAoaWRDb3VudGVyICsgMSkgJSBNQVg7CiAgcmV0dXJuIGlkQ291bnRlcjsKfQoKfSx7fV0sMTA2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwoKdmFyIGdldFVuaXF1ZUlkID0gX2RlcmVxXygnLi9nZXRVbmlxdWVJZCcpOwoKbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZTsKCmZ1bmN0aW9uIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkgewogIHJldHVybiBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQsIGVuZCkgewogICAgdmFyIG9yaWdpbmFsSWQgPSByZXEuaWQ7CiAgICB2YXIgbmV3SWQgPSBnZXRVbmlxdWVJZCgpOwogICAgcmVxLmlkID0gbmV3SWQ7CiAgICByZXMuaWQgPSBuZXdJZDsKICAgIG5leHQoZnVuY3Rpb24gKGRvbmUpIHsKICAgICAgcmVxLmlkID0gb3JpZ2luYWxJZDsKICAgICAgcmVzLmlkID0gb3JpZ2luYWxJZDsKICAgICAgZG9uZSgpOwogICAgfSk7CiAgfTsKfQoKfSx7Ii4vZ2V0VW5pcXVlSWQiOjEwNX1dLDEwNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7Cgp2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7Cgp2YXIgX2NyZWF0ZUNsYXNzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpOwoKdmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBhc3luYyA9IF9kZXJlcV8oJ2FzeW5jJyk7CnZhciBKc29uUnBjRXJyb3IgPSBfZGVyZXFfKCdqc29uLXJwYy1lcnJvcicpOwoKdmFyIFJwY0VuZ2luZSA9IGZ1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBScGNFbmdpbmUoKSB7CiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBScGNFbmdpbmUpOwoKICAgIHRoaXMuX21pZGRsZXdhcmUgPSBbXTsKICB9CgogIC8vCiAgLy8gUHVibGljCiAgLy8KCiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoUnBjRW5naW5lLCBbewogICAga2V5OiAncHVzaCcsCiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChtaWRkbGV3YXJlKSB7CiAgICAgIHRoaXMuX21pZGRsZXdhcmUucHVzaChtaWRkbGV3YXJlKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICdoYW5kbGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZShyZXEsIGNiKSB7CiAgICAgIC8vIGJhdGNoIHJlcXVlc3Qgc3VwcG9ydAogICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEpKSB7CiAgICAgICAgYXN5bmMubWFwKHJlcSwgdGhpcy5faGFuZGxlLmJpbmQodGhpcyksIGNiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLl9oYW5kbGUocmVxLCBjYik7CiAgICAgIH0KICAgIH0KCiAgICAvLwogICAgLy8gUHJpdmF0ZQogICAgLy8KCiAgfSwgewogICAga2V5OiAnX2hhbmRsZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZShyZXEsIGNiKSB7CiAgICAgIC8vIGNyZWF0ZSByZXNwb25zZSBvYmoKICAgICAgdmFyIHJlcyA9IHsKICAgICAgICBpZDogcmVxLmlkLAogICAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjCiAgICAgICAgLy8gcHJvY2VzcyBhbGwgbWlkZGxld2FyZQogICAgICB9O3RoaXMuX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIGZ1bmN0aW9uIChlcnIsIGlzQ29tcGxldGUpIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAvLyBwcmVwYXJlIGVycm9yIG1lc3NhZ2UKICAgICAgICAgIHJlcy5lcnJvciA9IG5ldyBKc29uUnBjRXJyb3IuSW50ZXJuYWxFcnJvcihlcnIpOwogICAgICAgICAgLy8gcmV0dXJuIGVycm9yLWZpcnN0IGFuZCByZXMgd2l0aCBlcnIKICAgICAgICAgIHJldHVybiBjYihlcnIsIHJlcyk7CiAgICAgICAgfQogICAgICAgIC8vIGZhaWwgaWYgbm90IGNvbXBsZXRlZAogICAgICAgIGlmICghaXNDb21wbGV0ZSkgewogICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUnBjRW5naW5lIC0gbm90aGluZyBlbmRlZCByZXF1ZXN0JykpOwogICAgICAgIH0KICAgICAgICAvLyByZXR1cm4gcmVzcG9uc2UKICAgICAgICBjYihudWxsLCByZXMpOwogICAgICB9KTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICdfcnVuTWlkZGxld2FyZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIGNiKSB7CiAgICAgIHZhciBzZWxmID0gdGhpczsKICAgICAgLy8gZm9yIGNsaW1iaW5nIGJhY2sgdXAgdGhlIHN0YWNrCiAgICAgIHZhciByZXR1cm5IYW5kbGVycyA9IFtdOwogICAgICAvLyBmbGFnIGZvciBzdGFjayByZXR1cm4KICAgICAgdmFyIGlzQ29tcGxldGUgPSBmYWxzZTsKCiAgICAgIC8vIGZsb3cKICAgICAgYXN5bmMuc2VyaWVzKFtydW5BbGxNaWRkbGV3YXJlLCBydW5SZXR1cm5IYW5kbGVyc10sIGNvbXBsZXRlUmVxdWVzdCk7CgogICAgICAvLyBkb3duIHN0YWNrIG9mIG1pZGRsZXdhcmUsIGNhbGwgYW5kIGNvbGxlY3Qgb3B0aW9uYWwgcmV0dXJuSGFuZGxlcnMKICAgICAgZnVuY3Rpb24gcnVuQWxsTWlkZGxld2FyZShjYikgewogICAgICAgIGFzeW5jLm1hcFNlcmllcyhzZWxmLl9taWRkbGV3YXJlLCBlYWNoTWlkZGxld2FyZSwgY2IpOwogICAgICB9CgogICAgICAvLyBjbGltYnMgdGhlIHN0YWNrIGNhbGxpbmcgcmV0dXJuIGhhbmRsZXJzCiAgICAgIGZ1bmN0aW9uIHJ1blJldHVybkhhbmRsZXJzKGNiKSB7CiAgICAgICAgdmFyIGJhY2tTdGFjayA9IHJldHVybkhhbmRsZXJzLmZpbHRlcihCb29sZWFuKS5yZXZlcnNlKCk7CiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhiYWNrU3RhY2ssIGZ1bmN0aW9uIChoYW5kbGVyLCBuZXh0KSB7CiAgICAgICAgICByZXR1cm4gaGFuZGxlcihuZXh0KTsKICAgICAgICB9LCBjb21wbGV0ZVJlcXVlc3QpOwogICAgICB9CgogICAgICAvLyBydW5zIGFuIGluZGl2aWR1YWwgbWlkZGxld2FyZQogICAgICBmdW5jdGlvbiBlYWNoTWlkZGxld2FyZShtaWRkbGV3YXJlLCBjYikgewogICAgICAgIC8vIHNraXAgbWlkZGxld2FyZSBpZiBjb21wbGV0ZWQKICAgICAgICBpZiAoaXNDb21wbGV0ZSkgcmV0dXJuIGNiKCk7CiAgICAgICAgLy8gcnVuIGluZGl2aWR1YWwgbWlkZGxld2FyZQogICAgICAgIG1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCk7CgogICAgICAgIGZ1bmN0aW9uIG5leHQocmV0dXJuSGFuZGxlcikgewogICAgICAgICAgLy8gYWRkIHJldHVybiBoYW5kbGVyCiAgICAgICAgICByZXR1cm5IYW5kbGVycy5wdXNoKHJldHVybkhhbmRsZXIpOwogICAgICAgICAgY2IoKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZW5kKGVycikgewogICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7CiAgICAgICAgICAvLyBtYXJrIGFzIGNvbXBsZXRlZAogICAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7CiAgICAgICAgICBjYigpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgLy8gcmV0dXJucywgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBpdCBlbmRlZAogICAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoZXJyKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7CiAgICAgICAgY2IobnVsbCwgaXNDb21wbGV0ZSk7CiAgICAgIH0KICAgIH0KICB9XSk7CiAgcmV0dXJuIFJwY0VuZ2luZTsKfSgpOwoKbW9kdWxlLmV4cG9ydHMgPSBScGNFbmdpbmU7Cgp9LHsiYXN5bmMiOjQsImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjayI6MTIsImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyI6MTMsImpzb24tcnBjLWVycm9yIjoxMDh9XSwxMDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliL2Vycm9ycycpOwp9LHsiLi9saWIvZXJyb3JzIjoxMDl9XSwxMDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwoKdmFyIEpzb25ScGNFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvZGUsIGRhdGEpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSnNvblJwY0Vycm9yKSkgewogICAgcmV0dXJuIG5ldyBKc29uUnBjRXJyb3IobWVzc2FnZSwgY29kZSwgZGF0YSk7CiAgfQoKICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogIHRoaXMuY29kZSA9IGNvZGU7CgogIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgIHRoaXMuZGF0YSA9IGRhdGE7CiAgfQp9OwoKaW5oZXJpdHMoSnNvblJwY0Vycm9yLCBFcnJvcik7Cgp2YXIgUGFyc2VFcnJvciA9IGZ1bmN0aW9uKCkgewogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXJzZUVycm9yKSkgewogICAgcmV0dXJuIG5ldyBQYXJzZUVycm9yKCk7CiAgfQoKICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnUGFyc2UgZXJyb3InLCAtMzI3MDApOwp9OwoKaW5oZXJpdHMoUGFyc2VFcnJvciwgSnNvblJwY0Vycm9yKTsKCnZhciBJbnZhbGlkUmVxdWVzdCA9IGZ1bmN0aW9uKCkgewogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnZhbGlkUmVxdWVzdCkpIHsKICAgIHJldHVybiBuZXcgSW52YWxpZFJlcXVlc3QoKTsKICB9CgogIEpzb25ScGNFcnJvci5jYWxsKHRoaXMsICdJbnZhbGlkIFJlcXVlc3QnLCAtMzI2MDApOwp9OwoKaW5oZXJpdHMoSW52YWxpZFJlcXVlc3QsIEpzb25ScGNFcnJvcik7Cgp2YXIgTWV0aG9kTm90Rm91bmQgPSBmdW5jdGlvbigpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWV0aG9kTm90Rm91bmQpKSB7CiAgICByZXR1cm4gbmV3IE1ldGhvZE5vdEZvdW5kKCk7CiAgfQoKICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnTWV0aG9kIG5vdCBmb3VuZCcsIC0zMjYwMSk7Cn07Cgppbmhlcml0cyhNZXRob2ROb3RGb3VuZCwgSnNvblJwY0Vycm9yKTsKCnZhciBJbnZhbGlkUGFyYW1zID0gZnVuY3Rpb24oKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEludmFsaWRQYXJhbXMpKSB7CiAgICByZXR1cm4gbmV3IEludmFsaWRQYXJhbXMoKTsKICB9CgogIEpzb25ScGNFcnJvci5jYWxsKHRoaXMsICdJbnZhbGlkIHBhcmFtcycsIC0zMjYwMik7Cn07Cgppbmhlcml0cyhJbnZhbGlkUGFyYW1zLCBKc29uUnBjRXJyb3IpOwoKdmFyIEludGVybmFsRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsKICB2YXIgbWVzc2FnZTsKCiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEludGVybmFsRXJyb3IpKSB7CiAgICByZXR1cm4gbmV3IEludGVybmFsRXJyb3IoZXJyKTsKICB9CgogIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHsKICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTsKICB9IGVsc2UgewogICAgbWVzc2FnZSA9ICdJbnRlcm5hbCBlcnJvcic7CiAgfQoKICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCAtMzI2MDMpOwp9OwoKaW5oZXJpdHMoSW50ZXJuYWxFcnJvciwgSnNvblJwY0Vycm9yKTsKCnZhciBTZXJ2ZXJFcnJvciA9IGZ1bmN0aW9uKGNvZGUpIHsKICBpZiAoY29kZSA8IC0zMjA5OSB8fCBjb2RlID4gLTMyMDAwKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXJyb3IgY29kZScpOwogIH0KCiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlcnZlckVycm9yKSkgewogICAgcmV0dXJuIG5ldyBTZXJ2ZXJFcnJvcihjb2RlKTsKICB9CgogIEpzb25ScGNFcnJvci5jYWxsKHRoaXMsICdTZXJ2ZXIgZXJyb3InLCBjb2RlKTsKfTsKCmluaGVyaXRzKFNlcnZlckVycm9yLCBKc29uUnBjRXJyb3IpOwoKSnNvblJwY0Vycm9yLlBhcnNlRXJyb3IgPSBQYXJzZUVycm9yOwpKc29uUnBjRXJyb3IuSW52YWxpZFJlcXVlc3QgPSBJbnZhbGlkUmVxdWVzdDsKSnNvblJwY0Vycm9yLk1ldGhvZE5vdEZvdW5kID0gTWV0aG9kTm90Rm91bmQ7Ckpzb25ScGNFcnJvci5JbnZhbGlkUGFyYW1zID0gSW52YWxpZFBhcmFtczsKSnNvblJwY0Vycm9yLkludGVybmFsRXJyb3IgPSBJbnRlcm5hbEVycm9yOwpKc29uUnBjRXJyb3IuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjsKCm1vZHVsZS5leHBvcnRzID0gSnNvblJwY0Vycm9yOwoKCgp9LHsiaW5oZXJpdHMiOjEwMn1dLDExMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmNvbnN0IER1cGxleFN0cmVhbSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleAoKbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlCgpmdW5jdGlvbiBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCkgewogIGNvbnN0IGlkTWFwID0ge30KICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4U3RyZWFtKHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZCwgd3JpdGUgfSkKCiAgY29uc3QgbWlkZGxld2FyZSA9IChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7CiAgICAvLyB3cml0ZSByZXEgdG8gc3RyZWFtCiAgICBzdHJlYW0ucHVzaChyZXEpCiAgICAvLyByZWdpc3RlciByZXF1ZXN0IG9uIGlkIG1hcAogICAgaWRNYXBbcmVxLmlkXSA9IHsgcmVxLCByZXMsIG5leHQsIGVuZCB9CiAgfQoKICBtaWRkbGV3YXJlLnN0cmVhbSA9IHN0cmVhbQogIAogIHJldHVybiBtaWRkbGV3YXJlCgogIGZ1bmN0aW9uIHJlYWQgKCkgewogICAgcmV0dXJuIGZhbHNlCiAgfQoKICBmdW5jdGlvbiB3cml0ZSAocmVzLCBlbmNvZGluZywgY2IpIHsKICAgIC8vIGNvbnNvbGUubG9nKHJlcywgZW5jb2RpbmcsIGNiKQogICAgY29uc3QgY29udGV4dCA9IGlkTWFwW3Jlcy5pZF0KICAgIGlmICghY29udGV4dCkgY2IobmV3IEVycm9yKGBTdHJlYW1NaWRkbGV3YXJlIC0gVW5rbm93biByZXNwb25zZSBpZCAke3Jlcy5pZH1gKSkKICAgIGRlbGV0ZSBpZE1hcFtyZXMuaWRdCiAgICAvLyBjb3B5IHdob2xlIHJlcyBvbnRvIG9yaWdpbmFsIHJlcwogICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LnJlcywgcmVzKQogICAgLy8gcnVuIGNhbGxiYWNrIG9uIGVtcHR5IHN0YWNrLAogICAgLy8gcHJldmVudCBpbnRlcm5hbCBzdHJlYW0taGFuZGxlciBmcm9tIGNhdGNoaW5nIGVycm9ycwogICAgc2V0VGltZW91dChjb250ZXh0LmVuZCkKICAgIC8vIGNvbnRpbnVlIHByb2Nlc3Npbmcgc3RyZWFtCiAgICBjYigpCiAgfQoKfQp9LHsicmVhZGFibGUtc3RyZWFtIjoxMjl9XSwxMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovKgoqIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsCioKKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5CiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLgoqLwooZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHsKICAgICJ1c2Ugc3RyaWN0IjsKICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHsKICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7CiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7CiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7CiAgICB9IGVsc2UgewogICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpOwogICAgfQp9KHRoaXMsIGZ1bmN0aW9uICgpIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplCiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307CiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9ICJ1bmRlZmluZWQiOwoKICAgIHZhciBsb2dNZXRob2RzID0gWwogICAgICAgICJ0cmFjZSIsCiAgICAgICAgImRlYnVnIiwKICAgICAgICAiaW5mbyIsCiAgICAgICAgIndhcm4iLAogICAgICAgICJlcnJvciIKICAgIF07CgogICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNgogICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHsKICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdOwogICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZwogICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTsKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CgogICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52CiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMKICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgewogICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7CiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJzsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMKICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTsKICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBub29wOwogICAgICAgIH0KICAgIH0KCiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5CgogICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7CiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi8KICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldOwogICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgPwogICAgICAgICAgICAgICAgbm9vcCA6CiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpOwogICAgICAgIH0KCiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1ZwogICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZzsKICAgIH0KCiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuCiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kcwogICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkgewogICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkgewogICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpOwogICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgfTsKICAgIH0KCiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZAogICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi4KICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7CiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi8KICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fAogICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9CgogICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkgewogICAgICB2YXIgc2VsZiA9IHRoaXM7CiAgICAgIHZhciBjdXJyZW50TGV2ZWw7CiAgICAgIHZhciBzdG9yYWdlS2V5ID0gImxvZ2xldmVsIjsKICAgICAgaWYgKG5hbWUpIHsKICAgICAgICBzdG9yYWdlS2V5ICs9ICI6IiArIG5hbWU7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHsKICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7CgogICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjsKCiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZQogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lOwogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge30KCiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2sKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9CiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyAiPSIgKyBsZXZlbE5hbWUgKyAiOyI7CiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkgewogICAgICAgICAgdmFyIHN0b3JlZExldmVsOwoKICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07CiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CgogICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmcKICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTsKICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoCiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyAiPSIpOwogICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge30KICAgICAgICAgIH0KCiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLgogICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsOwogICAgICB9CgogICAgICAvKgogICAgICAgKgogICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHMKICAgICAgICoKICAgICAgICovCgogICAgICBzZWxmLmxldmVscyA9IHsgIlRSQUNFIjogMCwgIkRFQlVHIjogMSwgIklORk8iOiAyLCAiV0FSTiI6IDMsCiAgICAgICAgICAiRVJST1IiOiA0LCAiU0lMRU5UIjogNX07CgogICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5OwoKICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7CiAgICAgIH07CgogICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7CiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSAic3RyaW5nIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICJudW1iZXIiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7CiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7CiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlCiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiAiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmciOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhyb3cgImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6ICIgKyBsZXZlbDsKICAgICAgICAgIH0KICAgICAgfTsKCiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7CiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHsKICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7CiAgICAgICAgICB9CiAgICAgIH07CgogICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHsKICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpOwogICAgICB9OwoKICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkgewogICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpOwogICAgICB9OwoKICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbAogICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTsKICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7CiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/ICJXQVJOIiA6IGRlZmF1bHRMZXZlbDsKICAgICAgfQogICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpOwogICAgfQoKICAgIC8qCiAgICAgKgogICAgICogVG9wLWxldmVsIEFQSQogICAgICoKICAgICAqLwoKICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpOwoKICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9OwogICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkgewogICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gInN0cmluZyIgfHwgbmFtZSA9PT0gIiIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci4iKTsKICAgICAgICB9CgogICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTsKICAgICAgICBpZiAoIWxvZ2dlcikgewogICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKAogICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBsb2dnZXI7CiAgICB9OwoKICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZQogICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkOwogICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiYKICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikgewogICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZzsKICAgICAgICB9CgogICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyOwogICAgfTsKCiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjsKfSkpOwoKfSx7fV0sMTEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKY29uc3QgeyBEdXBsZXggfSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpCmNvbnN0IGVuZE9mU3RyZWFtID0gX2RlcmVxXygnZW5kLW9mLXN0cmVhbScpCmNvbnN0IG9uY2UgPSBfZGVyZXFfKCdvbmNlJykKY29uc3Qgbm9vcCA9ICgpID0+IHt9Cgpjb25zdCBJR05PUkVfU1VCU1RSRUFNID0ge30KCgpjbGFzcyBPYmplY3RNdWx0aXBsZXggZXh0ZW5kcyBEdXBsZXggewoKICBjb25zdHJ1Y3Rvcihfb3B0cyA9IHt9KSB7CiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgX29wdHMsIHsKICAgICAgb2JqZWN0TW9kZTogdHJ1ZSwKICAgIH0pCiAgICBzdXBlcihvcHRzKQoKICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fQogIH0KCiAgY3JlYXRlU3RyZWFtIChuYW1lKSB7CiAgICAvLyB2YWxpZGF0ZSBuYW1lCiAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eScpCiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBTdWJzdHJlYW0gZm9yIG5hbWUgIiR7bmFtZX0iIGFscmVhZHkgZXhpc3RzJykKCiAgICAvLyBjcmVhdGUgc3Vic3RyZWFtCiAgICBjb25zdCBzdWJzdHJlYW0gPSBuZXcgU3Vic3RyZWFtKHsgcGFyZW50OiB0aGlzLCBuYW1lOiBuYW1lIH0pCiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gc3Vic3RyZWFtCgogICAgLy8gbGlzdGVuIGZvciBwYXJlbnQgc3RyZWFtIHRvIGVuZAogICAgYW55U3RyZWFtRW5kKHRoaXMsIChlcnIpID0+IHsKICAgICAgc3Vic3RyZWFtLmRlc3Ryb3koZXJyKQogICAgfSkKCiAgICByZXR1cm4gc3Vic3RyZWFtCiAgfQoKICAvLyBpZ25vcmUgc3RyZWFtcyAoZG9udCBkaXNwbGF5IG9ycGhhbmVkIGRhdGEgd2FybmluZykKICBpZ25vcmVTdHJlYW0gKG5hbWUpIHsKICAgIC8vIHZhbGlkYXRlIG5hbWUKICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5JykKICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSAiJHtuYW1lfSIgYWxyZWFkeSBleGlzdHMnKQogICAgLy8gc2V0CiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gSUdOT1JFX1NVQlNUUkVBTQogIH0KCiAgLy8gc3RyZWFtIHBsdW1iaW5nCgogIF9yZWFkICgpIHt9CgogIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7CiAgICAvLyBwYXJzZSBtZXNzYWdlCiAgICBjb25zdCBuYW1lID0gY2h1bmsubmFtZQogICAgY29uc3QgZGF0YSA9IGNodW5rLmRhdGEKICAgIGlmICghbmFtZSkgewogICAgICBjb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG1hbGZvcm1lZCBjaHVuayB3aXRob3V0IG5hbWUgIiR7Y2h1bmt9ImApCiAgICAgIHJldHVybiBjYWxsYmFjaygpCiAgICB9CgogICAgLy8gZ2V0IGNvcnJlc3BvbmRpbmcgc3Vic3RyZWFtCiAgICBjb25zdCBzdWJzdHJlYW0gPSB0aGlzLl9zdWJzdHJlYW1zW25hbWVdCiAgICBpZiAoIXN1YnN0cmVhbSkgewogICAgICBjb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG9ycGhhbmVkIGRhdGEgZm9yIHN0cmVhbSAiJHtuYW1lfSJgKQogICAgICByZXR1cm4gY2FsbGJhY2soKQogICAgfQoKICAgIC8vIHB1c2ggZGF0YSBpbnRvIHN1YnN0cmVhbQogICAgaWYgKHN1YnN0cmVhbSAhPT0gSUdOT1JFX1NVQlNUUkVBTSkgewogICAgICBzdWJzdHJlYW0ucHVzaChkYXRhKQogICAgfQoKICAgIGNhbGxiYWNrKCkKICB9Cgp9CgoKY2xhc3MgU3Vic3RyZWFtIGV4dGVuZHMgRHVwbGV4IHsKCiAgY29uc3RydWN0b3IgKHsgcGFyZW50LCBuYW1lIH0pIHsKICAgIHN1cGVyKHsKICAgICAgb2JqZWN0TW9kZTogdHJ1ZSwKICAgIH0pCgogICAgdGhpcy5fcGFyZW50ID0gcGFyZW50CiAgICB0aGlzLl9uYW1lID0gbmFtZQogIH0KCiAgX3JlYWQgKCkge30KCiAgX3dyaXRlIChjaHVuaywgZW5jLCBjYWxsYmFjaykgewogICAgdGhpcy5fcGFyZW50LnB1c2goewogICAgICBuYW1lOiB0aGlzLl9uYW1lLAogICAgICBkYXRhOiBjaHVuaywKICAgIH0pCiAgICBjYWxsYmFjaygpCiAgfQoKfQoKbW9kdWxlLmV4cG9ydHMgPSBPYmplY3RNdWx0aXBsZXgKCi8vIHV0aWwKCmZ1bmN0aW9uIGFueVN0cmVhbUVuZChzdHJlYW0sIF9jYikgewogIGNvbnN0IGNiID0gb25jZShfY2IpCiAgZW5kT2ZTdHJlYW0oc3RyZWFtLCB7IHJlYWRhYmxlOiBmYWxzZSB9LCBjYikKICBlbmRPZlN0cmVhbShzdHJlYW0sIHsgd3JpdGFibGU6IGZhbHNlIH0sIGNiKQp9Cn0seyJlbmQtb2Ytc3RyZWFtIjo5OSwib25jZSI6MTE1LCJyZWFkYWJsZS1zdHJlYW0iOjEyOX1dLDExMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfYXNzaWduID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24nKTsKCnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7Cgp2YXIgX3R5cGVvZjIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mJyk7Cgp2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTsKCnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTsKCnZhciBfY3JlYXRlQ2xhc3MyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7Cgp2YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7Cgp2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTsKCnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7Cgp2YXIgX2luaGVyaXRzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpOwoKdmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBleHRlbmQgPSBfZGVyZXFfKCd4dGVuZCcpOwp2YXIgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnZXZlbnRzJyk7Cgp2YXIgT2JzZXJ2YWJsZVN0b3JlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHsKICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShPYnNlcnZhYmxlU3RvcmUsIF9FdmVudEVtaXR0ZXIpOwoKICBmdW5jdGlvbiBPYnNlcnZhYmxlU3RvcmUoKSB7CiAgICB2YXIgaW5pdFN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE9ic2VydmFibGVTdG9yZSk7CgogICAgLy8gc2V0IGluaXQgc3RhdGUKICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKE9ic2VydmFibGVTdG9yZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoT2JzZXJ2YWJsZVN0b3JlKSkuY2FsbCh0aGlzKSk7CgogICAgX3RoaXMuX3N0YXRlID0gaW5pdFN0YXRlOwogICAgcmV0dXJuIF90aGlzOwogIH0KCiAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgZ2V0U3RhdGUKCgogICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE9ic2VydmFibGVTdG9yZSwgW3sKICAgIGtleTogJ2dldFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7CiAgICB9CgogICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGUKCiAgfSwgewogICAga2V5OiAncHV0U3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHB1dFN0YXRlKG5ld1N0YXRlKSB7CiAgICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKTsKICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXdTdGF0ZSk7CiAgICB9CiAgfSwgewogICAga2V5OiAndXBkYXRlU3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHBhcnRpYWxTdGF0ZSkgewogICAgICAvLyBpZiBub24tbnVsbCBvYmplY3QsIG1lcmdlCiAgICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkocGFydGlhbFN0YXRlKSkgPT09ICdvYmplY3QnKSB7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpOwogICAgICAgIHZhciBuZXdTdGF0ZSA9ICgwLCBfYXNzaWduMi5kZWZhdWx0KSh7fSwgc3RhdGUsIHBhcnRpYWxTdGF0ZSk7CiAgICAgICAgdGhpcy5wdXRTdGF0ZShuZXdTdGF0ZSk7CiAgICAgICAgLy8gaWYgbm90IG9iamVjdCwgdXNlIG5ldyB2YWx1ZQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTsKICAgICAgfQogICAgfQoKICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzCgogIH0sIHsKICAgIGtleTogJ3N1YnNjcmliZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKGhhbmRsZXIpIHsKICAgICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlcik7CiAgICB9CgogICAgLy8gdW5zdWJzY3JpYmUgdG8gY2hhbmdlcwoKICB9LCB7CiAgICBrZXk6ICd1bnN1YnNjcmliZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoaGFuZGxlcikgewogICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTsKICAgIH0KCiAgICAvLwogICAgLy8gcHJpdmF0ZQogICAgLy8KCiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2UKCiAgfSwgewogICAga2V5OiAnX2dldFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhdGUoKSB7CiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTsKICAgIH0KCiAgICAvLyB3cml0ZSB0byBwZXJzaXN0ZW5jZQoKICB9LCB7CiAgICBrZXk6ICdfcHV0U3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9wdXRTdGF0ZShuZXdTdGF0ZSkgewogICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlOwogICAgfQogIH1dKTsKICByZXR1cm4gT2JzZXJ2YWJsZVN0b3JlOwp9KEV2ZW50RW1pdHRlcik7Cgptb2R1bGUuZXhwb3J0cyA9IE9ic2VydmFibGVTdG9yZTsKCn0seyJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbiI6NSwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIjo4LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2siOjEyLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MiOjEzLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMiOjE0LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiI6MTUsImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YiOjE2LCJldmVudHMiOjEwMCwieHRlbmQiOjE0MX1dLDExNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTsKCnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTsKCnZhciBfY3JlYXRlQ2xhc3MyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7Cgp2YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7Cgp2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTsKCnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7Cgp2YXIgX2luaGVyaXRzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpOwoKdmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBEdXBsZXhTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKS5EdXBsZXg7Cgptb2R1bGUuZXhwb3J0cyA9IGFzU3RyZWFtOwoKZnVuY3Rpb24gYXNTdHJlYW0ob2JzU3RvcmUpIHsKICByZXR1cm4gbmV3IE9ic1N0b3JlU3RyZWFtKG9ic1N0b3JlKTsKfQoKLy8KLy8KLy8KLy8KCnZhciBPYnNTdG9yZVN0cmVhbSA9IGZ1bmN0aW9uIChfRHVwbGV4U3RyZWFtKSB7CiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoT2JzU3RvcmVTdHJlYW0sIF9EdXBsZXhTdHJlYW0pOwoKICBmdW5jdGlvbiBPYnNTdG9yZVN0cmVhbShvYnNTdG9yZSkgewogICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgT2JzU3RvcmVTdHJlYW0pOwoKICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXMKICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKE9ic1N0b3JlU3RyZWFtLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShPYnNTdG9yZVN0cmVhbSkpLmNhbGwodGhpcywgewogICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zCiAgICAgIG9iamVjdE1vZGU6IHRydWUKICAgIH0pKTsKCiAgICBfdGhpcy5yZXN1bWUoKTsKICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzCiAgICBfdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlOwogICAgX3RoaXMub2JzU3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkgewogICAgICByZXR1cm4gX3RoaXMucHVzaChzdGF0ZSk7CiAgICB9KTsKICAgIHJldHVybiBfdGhpczsKICB9CgogIC8vIGVtaXQgY3VycmVudCBzdGF0ZSBvbiBuZXcgZGVzdGluYXRpb24KCgogICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE9ic1N0b3JlU3RyZWFtLCBbewogICAga2V5OiAncGlwZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gcGlwZShkZXN0LCBvcHRpb25zKSB7CiAgICAgIHZhciByZXN1bHQgPSBEdXBsZXhTdHJlYW0ucHJvdG90eXBlLnBpcGUuY2FsbCh0aGlzLCBkZXN0LCBvcHRpb25zKTsKICAgICAgZGVzdC53cml0ZSh0aGlzLm9ic1N0b3JlLmdldFN0YXRlKCkpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICAgIC8vIHdyaXRlIGZyb20gaW5jb21taW5nIHN0cmVhbSB0byBzdGF0ZQoKICB9LCB7CiAgICBrZXk6ICdfd3JpdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7CiAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspOwogICAgICBjYWxsYmFjaygpOwogICAgfQoKICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXQKCiAgfSwgewogICAga2V5OiAnX3JlYWQnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkKHNpemUpIHt9CiAgfV0pOwogIHJldHVybiBPYnNTdG9yZVN0cmVhbTsKfShEdXBsZXhTdHJlYW0pOwoKfSx7ImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZiI6OCwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrIjoxMiwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzIjoxMywiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzIjoxNCwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iOjE1LCJzdHJlYW0iOjEzM31dLDExNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB3cmFwcHkgPSBfZGVyZXFfKCd3cmFwcHknKQptb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKQptb2R1bGUuZXhwb3J0cy5zdHJpY3QgPSB3cmFwcHkob25jZVN0cmljdCkKCm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHsKICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBvbmNlKHRoaXMpCiAgICB9LAogICAgY29uZmlndXJhYmxlOiB0cnVlCiAgfSkKCiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2VTdHJpY3QnLCB7CiAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gb25jZVN0cmljdCh0aGlzKQogICAgfSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogIH0pCn0pCgpmdW5jdGlvbiBvbmNlIChmbikgewogIHZhciBmID0gZnVuY3Rpb24gKCkgewogICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZQogICAgZi5jYWxsZWQgPSB0cnVlCiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKICB9CiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCmZ1bmN0aW9uIG9uY2VTdHJpY3QgKGZuKSB7CiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7CiAgICBpZiAoZi5jYWxsZWQpCiAgICAgIHRocm93IG5ldyBFcnJvcihmLm9uY2VFcnJvcikKICAgIGYuY2FsbGVkID0gdHJ1ZQogICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpCiAgfQogIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCcKICBmLm9uY2VFcnJvciA9IG5hbWUgKyAiIHNob3VsZG4ndCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UiCiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCn0seyJ3cmFwcHkiOjE0MH1dLDExNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmNvbnN0IER1cGxleFN0cmVhbSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleApjb25zdCBpbmhlcml0cyA9IF9kZXJlcV8oJ3V0aWwnKS5pbmhlcml0cwoKbW9kdWxlLmV4cG9ydHMgPSBQb3N0TWVzc2FnZVN0cmVhbQoKaW5oZXJpdHMoUG9zdE1lc3NhZ2VTdHJlYW0sIER1cGxleFN0cmVhbSkKCmZ1bmN0aW9uIFBvc3RNZXNzYWdlU3RyZWFtIChvcHRzKSB7CiAgRHVwbGV4U3RyZWFtLmNhbGwodGhpcywgewogICAgb2JqZWN0TW9kZTogdHJ1ZSwKICB9KQoKICB0aGlzLl9uYW1lID0gb3B0cy5uYW1lCiAgdGhpcy5fdGFyZ2V0ID0gb3B0cy50YXJnZXQKICB0aGlzLl90YXJnZXRXaW5kb3cgPSBvcHRzLnRhcmdldFdpbmRvdyB8fCB3aW5kb3cKICB0aGlzLl9vcmlnaW4gPSAob3B0cy50YXJnZXRXaW5kb3cgPyAnKicgOiBsb2NhdGlvbi5vcmlnaW4pCgogIC8vIGluaXRpYWxpemF0aW9uIGZsYWdzCiAgdGhpcy5faW5pdCA9IGZhbHNlCiAgdGhpcy5faGF2ZVN5biA9IGZhbHNlCgogIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyksIGZhbHNlKQogIC8vIHNlbmQgc3luY29yaXphdGlvbiBtZXNzYWdlCiAgdGhpcy5fd3JpdGUoJ1NZTicsIG51bGwsIG5vb3ApCiAgdGhpcy5jb3JrKCkKfQoKLy8gcHJpdmF0ZQpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkgewogIHZhciBtc2cgPSBldmVudC5kYXRhCgogIC8vIHZhbGlkYXRlIG1lc3NhZ2UKICBpZiAodGhpcy5fb3JpZ2luICE9PSAnKicgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl9vcmlnaW4pIHJldHVybgogIGlmIChldmVudC5zb3VyY2UgIT09IHRoaXMuX3RhcmdldFdpbmRvdykgcmV0dXJuCiAgaWYgKHR5cGVvZiBtc2cgIT09ICdvYmplY3QnKSByZXR1cm4KICBpZiAobXNnLnRhcmdldCAhPT0gdGhpcy5fbmFtZSkgcmV0dXJuCiAgaWYgKCFtc2cuZGF0YSkgcmV0dXJuCgogIGlmICghdGhpcy5faW5pdCkgewogICAgaWYgKG1zZy5kYXRhID09PSAnU1lOJykgewogICAgICB0aGlzLl9oYXZlU3luID0gdHJ1ZQogICAgICB0aGlzLl93cml0ZSgnQUNLJywgbnVsbCwgbm9vcCkKICAgIH0gZWxzZSBpZiAobXNnLmRhdGEgPT09ICdBQ0snKSB7CiAgICAgIHRoaXMuX2luaXQgPSB0cnVlCiAgICAgIGlmICghdGhpcy5faGF2ZVN5bikgewogICAgICAgIHRoaXMuX3dyaXRlKCdBQ0snLCBudWxsLCBub29wKQogICAgICB9CiAgICAgIHRoaXMudW5jb3JrKCkKICAgIH0KICB9IGVsc2UgewogICAgLy8gZm9yd2FyZCBtZXNzYWdlCiAgICB0cnkgewogICAgICB0aGlzLnB1c2gobXNnLmRhdGEpCiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycikKICAgIH0KICB9Cn0KCi8vIHN0cmVhbSBwbHVtYmluZwpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBub29wCgpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikgewogIHZhciBtZXNzYWdlID0gewogICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsCiAgICBkYXRhOiBkYXRhLAogIH0KICB0aGlzLl90YXJnZXRXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgdGhpcy5fb3JpZ2luKQogIGNiKCkKfQoKLy8gdXRpbAoKZnVuY3Rpb24gbm9vcCAoKSB7fQoKfSx7InJlYWRhYmxlLXN0cmVhbSI6MTI5LCJ1dGlsIjoxMzh9XSwxMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MpewondXNlIHN0cmljdCc7CgppZiAoIXByb2Nlc3MudmVyc2lvbiB8fAogICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8CiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHsKICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrOwp9IGVsc2UgewogIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljazsKfQoKZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHsKICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciY2FsbGJhY2siIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpOwogIH0KICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsKICB2YXIgYXJncywgaTsKICBzd2l0Y2ggKGxlbikgewogIGNhc2UgMDoKICBjYXNlIDE6CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7CiAgY2FzZSAyOgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkgewogICAgICBmbi5jYWxsKG51bGwsIGFyZzEpOwogICAgfSk7CiAgY2FzZSAzOgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkgewogICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpOwogICAgfSk7CiAgY2FzZSA0OgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7CiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7CiAgICB9KTsKICBkZWZhdWx0OgogICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsKICAgIGkgPSAwOwogICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkgewogICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07CiAgICB9CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7CiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgfSk7CiAgfQp9Cgp9KS5jYWxsKHRoaXMsX2RlcmVxXygnX3Byb2Nlc3MnKSkKfSx7Il9wcm9jZXNzIjoxOX1dLDExODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBvbmNlID0gX2RlcmVxXygnb25jZScpCnZhciBlb3MgPSBfZGVyZXFfKCdlbmQtb2Ytc3RyZWFtJykKdmFyIGZzID0gX2RlcmVxXygnZnMnKSAvLyB3ZSBvbmx5IG5lZWQgZnMgdG8gZ2V0IHRoZSBSZWFkU3RyZWFtIGFuZCBXcml0ZVN0cmVhbSBwcm90b3R5cGVzCgp2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9Cgp2YXIgaXNGbiA9IGZ1bmN0aW9uIChmbikgewogIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicKfQoKdmFyIGlzRlMgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgaWYgKCFmcykgcmV0dXJuIGZhbHNlIC8vIGJyb3dzZXIKICByZXR1cm4gKHN0cmVhbSBpbnN0YW5jZW9mIChmcy5SZWFkU3RyZWFtIHx8IG5vb3ApIHx8IHN0cmVhbSBpbnN0YW5jZW9mIChmcy5Xcml0ZVN0cmVhbSB8fCBub29wKSkgJiYgaXNGbihzdHJlYW0uY2xvc2UpCn0KCnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgaXNGbihzdHJlYW0uYWJvcnQpCn0KCnZhciBkZXN0cm95ZXIgPSBmdW5jdGlvbiAoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykgewogIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaykKCiAgdmFyIGNsb3NlZCA9IGZhbHNlCiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHsKICAgIGNsb3NlZCA9IHRydWUKICB9KQoKICBlb3Moc3RyZWFtLCB7cmVhZGFibGU6IHJlYWRpbmcsIHdyaXRhYmxlOiB3cml0aW5nfSwgZnVuY3Rpb24gKGVycikgewogICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycikKICAgIGNsb3NlZCA9IHRydWUKICAgIGNhbGxiYWNrKCkKICB9KQoKICB2YXIgZGVzdHJveWVkID0gZmFsc2UKICByZXR1cm4gZnVuY3Rpb24gKGVycikgewogICAgaWYgKGNsb3NlZCkgcmV0dXJuCiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm4KICAgIGRlc3Ryb3llZCA9IHRydWUKCiAgICBpZiAoaXNGUyhzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmNsb3NlKCkgLy8gdXNlIGNsb3NlIGZvciBmcyBzdHJlYW1zIHRvIGF2b2lkIGZkIGxlYWtzCiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKSAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudAoKICAgIGlmIChpc0ZuKHN0cmVhbS5kZXN0cm95KSkgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCkKCiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVycm9yKCdzdHJlYW0gd2FzIGRlc3Ryb3llZCcpKQogIH0KfQoKdmFyIGNhbGwgPSBmdW5jdGlvbiAoZm4pIHsKICBmbigpCn0KCnZhciBwaXBlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7CiAgcmV0dXJuIGZyb20ucGlwZSh0bykKfQoKdmFyIHB1bXAgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0cmVhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpCiAgdmFyIGNhbGxiYWNrID0gaXNGbihzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gfHwgbm9vcCkgJiYgc3RyZWFtcy5wb3AoKSB8fCBub29wCgogIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXQogIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHRocm93IG5ldyBFcnJvcigncHVtcCByZXF1aXJlcyB0d28gc3RyZWFtcyBwZXIgbWluaW11bScpCgogIHZhciBlcnJvcgogIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHsKICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMQogICAgdmFyIHdyaXRpbmcgPSBpID4gMAogICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnIKICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKQogICAgICBpZiAocmVhZGluZykgcmV0dXJuCiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCkKICAgICAgY2FsbGJhY2soZXJyb3IpCiAgICB9KQogIH0pCgogIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKQp9Cgptb2R1bGUuZXhwb3J0cyA9IHB1bXAKCn0seyJlbmQtb2Ytc3RyZWFtIjo5OSwiZnMiOjE4LCJvbmNlIjoxMTV9XSwxMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7Cgp9LHsiLi9saWIvX3N0cmVhbV9kdXBsZXguanMiOjEyMH1dLDEyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuCi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzCi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb20KLy8gV3JpdGFibGUuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIHByb2Nlc3NOZXh0VGljayA9IF9kZXJlcV8oJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7CiAgdmFyIGtleXMgPSBbXTsKICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7CiAgICBrZXlzLnB1c2goa2V5KTsKICB9cmV0dXJuIGtleXM7Cn07Ci8qPC9yZXBsYWNlbWVudD4qLwoKbW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpOwp1dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKLyo8L3JlcGxhY2VtZW50PiovCgp2YXIgUmVhZGFibGUgPSBfZGVyZXFfKCcuL19zdHJlYW1fcmVhZGFibGUnKTsKdmFyIFdyaXRhYmxlID0gX2RlcmVxXygnLi9fc3RyZWFtX3dyaXRhYmxlJyk7Cgp1dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpOwoKdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7CmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykgewogIHZhciBtZXRob2QgPSBrZXlzW3ZdOwogIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTsKfQoKZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7CgogIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7CiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTsKCiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTsKCiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTsKCiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTsKICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTsKCiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7Cn0KCi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXIKZnVuY3Rpb24gb25lbmQoKSB7CiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwKICAvLyB0aGVuIHdlJ3JlIG9rLgogIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOwoKICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uCiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suCiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpOwp9CgpmdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHsKICBzZWxmLmVuZCgpOwp9CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHsKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKICB9LAogIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW0KICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQKICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5CiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogIH0KfSk7CgpEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHsKICB0aGlzLnB1c2gobnVsbCk7CiAgdGhpcy5lbmQoKTsKCiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcnIpOwp9OwoKZnVuY3Rpb24gZm9yRWFjaCh4cywgZikgewogIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICBmKHhzW2ldLCBpKTsKICB9Cn0KfSx7Ii4vX3N0cmVhbV9yZWFkYWJsZSI6MTIyLCIuL19zdHJlYW1fd3JpdGFibGUiOjEyNCwiY29yZS11dGlsLWlzIjo5OCwiaW5oZXJpdHMiOjEwMiwicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOjExN31dLDEyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLgovLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS4KLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy4KCid1c2Ugc3RyaWN0JzsKCm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7Cgp2YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi9fc3RyZWFtX3RyYW5zZm9ybScpOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTsKdXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKdXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTsKCmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpOwoKICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTsKfQoKUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIGNiKG51bGwsIGNodW5rKTsKfTsKfSx7Ii4vX3N0cmVhbV90cmFuc2Zvcm0iOjEyMywiY29yZS11dGlsLWlzIjo5OCwiaW5oZXJpdHMiOjEwMn1dLDEyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIHByb2Nlc3NOZXh0VGljayA9IF9kZXJlcV8oJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKbW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBEdXBsZXg7Ci8qPC9yZXBsYWNlbWVudD4qLwoKUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7Cgp2YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHsKICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoOwp9OwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBTdHJlYW0gPSBfZGVyZXFfKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLy8gVE9ETyhibWV1cmVyKTogQ2hhbmdlIHRoaXMgYmFjayB0byBjb25zdCBvbmNlIGhvbGUgY2hlY2tzIGFyZQovLyBwcm9wZXJseSBvcHRpbWl6ZWQgYXdheSBlYXJseSBpbiBJZ25pdGlvbitUdXJib0Zhbi4KLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwp2YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9OwpmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7CiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTsKfQpmdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikgewogIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5Owp9Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTsKdXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIGRlYnVnVXRpbCA9IF9kZXJlcV8oJ3V0aWwnKTsKdmFyIGRlYnVnID0gdm9pZCAwOwppZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykgewogIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTsKfSBlbHNlIHsKICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9Owp9Ci8qPC9yZXBsYWNlbWVudD4qLwoKdmFyIEJ1ZmZlckxpc3QgPSBfZGVyZXFfKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpOwp2YXIgZGVzdHJveUltcGwgPSBfZGVyZXFfKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpOwp2YXIgU3RyaW5nRGVjb2RlcjsKCnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7Cgp2YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddOwoKZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikgewogIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duCiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uCiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgewogICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7CiAgfSBlbHNlIHsKICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkKICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkcwogICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZQogICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLgogICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07CiAgfQp9CgpmdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkgewogIER1cGxleCA9IER1cGxleCB8fCBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwoKICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0bwogIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5CiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CgogIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOwoKICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlcgogIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXIiCiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyazsKICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0OwogIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtOwoKICAvLyBjYXN0IHRvIGludHMuCiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspOwoKICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZQogIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuCiAgLy8gYXJyYXkuc2hpZnQoKQogIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTsKICB0aGlzLmxlbmd0aCA9IDA7CiAgdGhpcy5waXBlcyA9IG51bGw7CiAgdGhpcy5waXBlc0NvdW50ID0gMDsKICB0aGlzLmZsb3dpbmcgPSBudWxsOwogIHRoaXMuZW5kZWQgPSBmYWxzZTsKICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTsKICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsKCiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZAogIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlCiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsICJsYXRlciIgc2hvdWxkIGdlbmVyYWxseSBhbHNvCiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC4KICB0aGlzLnN5bmMgPSB0cnVlOwoKICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheQogIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLgogIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7CiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7CiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTsKCiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkCiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsKCiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZwogIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS4KICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guCiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7CgogIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzCiAgdGhpcy5hd2FpdERyYWluID0gMDsKCiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZAogIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTsKCiAgdGhpcy5kZWNvZGVyID0gbnVsbDsKICB0aGlzLmVuY29kaW5nID0gbnVsbDsKICBpZiAob3B0aW9ucy5lbmNvZGluZykgewogICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gX2RlcmVxXygnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjsKICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpOwogICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7CiAgfQp9CgpmdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7CiAgRHVwbGV4ID0gRHVwbGV4IHx8IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTsKCiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsKCiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpOwoKICAvLyBsZWdhY3kKICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTsKCiAgaWYgKG9wdGlvbnMpIHsKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkOwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95OwogIH0KCiAgU3RyZWFtLmNhbGwodGhpcyk7Cn0KCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7CiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDsKICB9LAogIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW0KICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQKICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseQogICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkCiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogIH0KfSk7CgpSZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7ClJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95OwpSZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikgewogIHRoaXMucHVzaChudWxsKTsKICBjYihlcnIpOwp9OwoKLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuCi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LAovLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkCi8vIHdyaXRlKCkgc29tZSBtb3JlLgpSZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIHZhciBza2lwQ2h1bmtDaGVjazsKCiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7CiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykgewogICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZzsKICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykgewogICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTsKICAgICAgICBlbmNvZGluZyA9ICcnOwogICAgICB9CiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTsKICAgIH0KICB9IGVsc2UgewogICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlOwogIH0KCiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spOwp9OwoKLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKCkKUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHsKICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpOwp9OwoKZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgaWYgKGNodW5rID09PSBudWxsKSB7CiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpOwogIH0gZWxzZSB7CiAgICB2YXIgZXI7CiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspOwogICAgaWYgKGVyKSB7CiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7CiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHsKICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspOwogICAgICB9CgogICAgICBpZiAoYWRkVG9Gcm9udCkgewogICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpOwogICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7CiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7CiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwogICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHsKICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgfQogIH0KCiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7Cn0KCmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7CiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7CiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTsKICAgIHN0cmVhbS5yZWFkKDApOwogIH0gZWxzZSB7CiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLgogICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTsKCiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTsKICB9CiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTsKfQoKZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykgewogIHZhciBlcjsKICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkgewogICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7CiAgfQogIHJldHVybiBlcjsKfQoKLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS4KLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUKLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsCi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhCi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdAovLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlcgovLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLgpmdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHsKICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApOwp9CgpSZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7Cn07CgovLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4KUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykgewogIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IF9kZXJlcV8oJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7CiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTsKICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jOwogIHJldHVybiB0aGlzOwp9OwoKLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQgp2YXIgTUFYX0hXTSA9IDB4ODAwMDAwOwpmdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7CiAgaWYgKG4gPj0gTUFYX0hXTSkgewogICAgbiA9IE1BWF9IV007CiAgfSBlbHNlIHsKICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpbgogICAgLy8gdGlueSBhbW91bnRzCiAgICBuLS07CiAgICBuIHw9IG4gPj4+IDE7CiAgICBuIHw9IG4gPj4+IDI7CiAgICBuIHw9IG4gPj4+IDQ7CiAgICBuIHw9IG4gPj4+IDg7CiAgICBuIHw9IG4gPj4+IDE2OwogICAgbisrOwogIH0KICByZXR1cm4gbjsKfQoKLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkgewogIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDsKICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7CiAgaWYgKG4gIT09IG4pIHsKICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZQogICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoOwogIH0KICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS4KICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTsKICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOwogIC8vIERvbid0IGhhdmUgZW5vdWdoCiAgaWYgKCFzdGF0ZS5lbmRlZCkgewogICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKICAgIHJldHVybiAwOwogIH0KICByZXR1cm4gc3RhdGUubGVuZ3RoOwp9CgovLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LgpSZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7CiAgZGVidWcoJ3JlYWQnLCBuKTsKICBuID0gcGFyc2VJbnQobiwgMTApOwogIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgdmFyIG5PcmlnID0gbjsKCiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwoKICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlCiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlcgogIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLgogIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7CiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7CiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTsKICAgIHJldHVybiBudWxsOwogIH0KCiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOwoKICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuCiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHsKICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpOwogICAgcmV0dXJuIG51bGw7CiAgfQoKICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlCiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluCiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZAogIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2UKICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlbgogIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLgogIC8vCiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6CiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkbwogIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuCiAgLy8KICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLgogIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpcwogIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhbgogIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmUKICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLgogIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbAogIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXQKICAvLyAncmVhZGFibGUnIGV0Yy4KICAvLwogIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi4KCiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLgogIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7CiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOwoKICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWUKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7CiAgICBkb1JlYWQgPSB0cnVlOwogICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTsKICB9CgogIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5CiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LgogIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7CiAgICBkb1JlYWQgPSBmYWxzZTsKICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTsKICB9IGVsc2UgaWYgKGRvUmVhZCkgewogICAgZGVidWcoJ2RvIHJlYWQnKTsKICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlOwogICAgc3RhdGUuc3luYyA9IHRydWU7CiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LgogICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2QKICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7CiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7CiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLAogICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLgogICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpOwogIH0KCiAgdmFyIHJldDsKICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7CgogIGlmIChyZXQgPT09IG51bGwpIHsKICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICBuID0gMDsKICB9IGVsc2UgewogICAgc3RhdGUubGVuZ3RoIC09IG47CiAgfQoKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3cKICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci4KICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CgogICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLgogICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTsKICB9CgogIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7CgogIHJldHVybiByZXQ7Cn07CgpmdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjsKICBpZiAoc3RhdGUuZGVjb2RlcikgewogICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTsKICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHsKICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspOwogICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CiAgICB9CiAgfQogIHN0YXRlLmVuZGVkID0gdHJ1ZTsKCiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuCiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7Cn0KCi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlcgovLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXIKLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLgpmdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlOwogIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7CiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7CiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlOwogICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pOwogIH0KfQoKZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHsKICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpOwogIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpOwogIGZsb3coc3RyZWFtKTsKfQoKLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCwKLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZAovLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZgovLyBpdCdzIGluIHByb2dyZXNzLgovLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLAovLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LgpmdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7CiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7CiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpOwogIH0KfQoKZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkgewogIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7CiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7CiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTsKICAgIHN0cmVhbS5yZWFkKDApOwogICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKQogICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLgogICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDsKICB9CiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTsKfQoKLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLgovLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLgovLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgImxlbmd0aCIgaXMgc29tZXdoYXQKLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLgpSZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikgewogIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpOwp9OwoKUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHsKICB2YXIgc3JjID0gdGhpczsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwoKICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHsKICAgIGNhc2UgMDoKICAgICAgc3RhdGUucGlwZXMgPSBkZXN0OwogICAgICBicmVhazsKICAgIGNhc2UgMToKICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdOwogICAgICBicmVhazsKICAgIGRlZmF1bHQ6CiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7CiAgICAgIGJyZWFrOwogIH0KICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7CiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTsKCiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjsKCiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTsKICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7CgogIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTsKICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykgewogICAgZGVidWcoJ29udW5waXBlJyk7CiAgICBpZiAocmVhZGFibGUgPT09IHNyYykgewogICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7CiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTsKICAgICAgICBjbGVhbnVwKCk7CiAgICAgIH0KICAgIH0KICB9CgogIGZ1bmN0aW9uIG9uZW5kKCkgewogICAgZGVidWcoJ29uZW5kJyk7CiAgICBkZXN0LmVuZCgpOwogIH0KCiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlcgogIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKQogIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzCiAgLy8gdG9vIHNsb3cuCiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpOwogIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7CgogIHZhciBjbGVhbmVkVXAgPSBmYWxzZTsKICBmdW5jdGlvbiBjbGVhbnVwKCkgewogICAgZGVidWcoJ2NsZWFudXAnKTsKICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW4KICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwogICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpOwogICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTsKCiAgICBjbGVhbmVkVXAgPSB0cnVlOwoKICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXMKICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydAogICAgLy8gZmxvd2luZyBhZ2Fpbi4KICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy4KICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS4KICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTsKICB9CgogIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwCiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2UKICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLgogIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi4KICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlOwogIHNyYy5vbignZGF0YScsIG9uZGF0YSk7CiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7CiAgICBkZWJ1Zygnb25kYXRhJyk7CiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7CiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7CiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikgewogICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGUKICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGUKICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS4KICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uCiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHsKICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pOwogICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7CiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7CiAgICAgIH0KICAgICAgc3JjLnBhdXNlKCk7CiAgICB9CiAgfQoKICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC4KICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuCiAgZnVuY3Rpb24gb25lcnJvcihlcikgewogICAgZGVidWcoJ29uZXJyb3InLCBlcik7CiAgICB1bnBpcGUoKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpOwogIH0KCiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLgogIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsKCiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS4KICBmdW5jdGlvbiBvbmNsb3NlKCkgewogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwogICAgdW5waXBlKCk7CiAgfQogIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTsKICBmdW5jdGlvbiBvbmZpbmlzaCgpIHsKICAgIGRlYnVnKCdvbmZpbmlzaCcpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTsKICAgIHVucGlwZSgpOwogIH0KICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCiAgZnVuY3Rpb24gdW5waXBlKCkgewogICAgZGVidWcoJ3VucGlwZScpOwogICAgc3JjLnVucGlwZShkZXN0KTsKICB9CgogIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvCiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsKCiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LgogIGlmICghc3RhdGUuZmxvd2luZykgewogICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7CiAgICBzcmMucmVzdW1lKCk7CiAgfQoKICByZXR1cm4gZGVzdDsKfTsKCmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykgewogIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7CiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTsKICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07CiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7CiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOwogICAgICBmbG93KHNyYyk7CiAgICB9CiAgfTsKfQoKUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTsKCiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLgogIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsKCiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLgogIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7CiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS4KICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpczsKCiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsKCiAgICAvLyBnb3QgYSBtYXRjaC4KICAgIHN0YXRlLnBpcGVzID0gbnVsbDsKICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwOwogICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlOwogICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuCgogIGlmICghZGVzdCkgewogICAgLy8gcmVtb3ZlIGFsbC4KICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzOwogICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7CiAgICBzdGF0ZS5waXBlcyA9IG51bGw7CiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDsKICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwogICAgfXJldHVybiB0aGlzOwogIH0KCiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS4KICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTsKICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpczsKCiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTsKICBzdGF0ZS5waXBlc0NvdW50IC09IDE7CiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07CgogIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7CgogIHJldHVybiB0aGlzOwp9OwoKLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvcgovLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZwpSZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7CiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pOwoKICBpZiAoZXYgPT09ICdkYXRhJykgewogICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkCiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTsKICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7CiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykgewogICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwogICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHsKICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7CiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gcmVzOwp9OwpSZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247CgpmdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHsKICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7CiAgc2VsZi5yZWFkKDApOwp9CgovLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJCi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS4KUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIGlmICghc3RhdGUuZmxvd2luZykgewogICAgZGVidWcoJ3Jlc3VtZScpOwogICAgc3RhdGUuZmxvd2luZyA9IHRydWU7CiAgICByZXN1bWUodGhpcywgc3RhdGUpOwogIH0KICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHsKICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7CiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7CiAgfQp9CgpmdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoIXN0YXRlLnJlYWRpbmcpIHsKICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICB9CgogIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlOwogIHN0YXRlLmF3YWl0RHJhaW4gPSAwOwogIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTsKICBmbG93KHN0cmVhbSk7CiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApOwp9CgpSZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7CiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7CiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdwYXVzZScpOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7CiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7CiAgfQogIHJldHVybiB0aGlzOwp9OwoKZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTsKICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fQp9CgovLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLgovLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuCi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LgpSZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIHZhciBwYXVzZWQgPSBmYWxzZTsKCiAgdmFyIHNlbGYgPSB0aGlzOwogIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkgewogICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7CiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHsKICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTsKICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTsKICAgIH0KCiAgICBzZWxmLnB1c2gobnVsbCk7CiAgfSk7CgogIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykgewogICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpOwogICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7CgogICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlCiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47CgogICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7CiAgICBpZiAoIXJldCkgewogICAgICBwYXVzZWQgPSB0cnVlOwogICAgICBzdHJlYW0ucGF1c2UoKTsKICAgIH0KICB9KTsKCiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLgogIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLgogIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7CiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHsKICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTsKICAgICAgICB9OwogICAgICB9KGkpOwogICAgfQogIH0KCiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLgogIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7CiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCBzZWxmLmVtaXQuYmluZChzZWxmLCBrUHJveHlFdmVudHNbbl0pKTsKICB9CgogIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGUKICAvLyB1bmRlcmx5aW5nIHN0cmVhbS4KICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7CiAgICBpZiAocGF1c2VkKSB7CiAgICAgIHBhdXNlZCA9IGZhbHNlOwogICAgICBzdHJlYW0ucmVzdW1lKCk7CiAgICB9CiAgfTsKCiAgcmV0dXJuIHNlbGY7Cn07CgovLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuClJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0OwoKLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLgovLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LgovLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwovLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgpmdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkgewogIC8vIG5vdGhpbmcgYnVmZmVyZWQKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDsKCiAgdmFyIHJldDsKICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHsKICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdAogICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpOwogICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7CiAgfSBlbHNlIHsKICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0CiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC4KLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHsKICB2YXIgcmV0OwogIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7CiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncwogICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7CiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pOwogIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7CiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2gKICAgIHJldCA9IGxpc3Quc2hpZnQoKTsKICB9IGVsc2UgewogICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyCiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTsKICB9CiAgcmV0dXJuIHJldDsKfQoKLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YQovLyBjaHVua3MuCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHsKICB2YXIgcCA9IGxpc3QuaGVhZDsKICB2YXIgYyA9IDE7CiAgdmFyIHJldCA9IHAuZGF0YTsKICBuIC09IHJldC5sZW5ndGg7CiAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgIHZhciBzdHIgPSBwLmRhdGE7CiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuOwogICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTsKICAgIG4gLT0gbmI7CiAgICBpZiAobiA9PT0gMCkgewogICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHsKICAgICAgICArK2M7CiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDsKICAgICAgfSBlbHNlIHsKICAgICAgICBsaXN0LmhlYWQgPSBwOwogICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7CiAgICAgIH0KICAgICAgYnJlYWs7CiAgICB9CiAgICArK2M7CiAgfQogIGxpc3QubGVuZ3RoIC09IGM7CiAgcmV0dXJuIHJldDsKfQoKLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLgovLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwovLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgpmdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7CiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTsKICB2YXIgcCA9IGxpc3QuaGVhZDsKICB2YXIgYyA9IDE7CiAgcC5kYXRhLmNvcHkocmV0KTsKICBuIC09IHAuZGF0YS5sZW5ndGg7CiAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgIHZhciBidWYgPSBwLmRhdGE7CiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuOwogICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpOwogICAgbiAtPSBuYjsKICAgIGlmIChuID09PSAwKSB7CiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkgewogICAgICAgICsrYzsKICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsOwogICAgICB9IGVsc2UgewogICAgICAgIGxpc3QuaGVhZCA9IHA7CiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTsKICAgICAgfQogICAgICBicmVhazsKICAgIH0KICAgICsrYzsKICB9CiAgbGlzdC5sZW5ndGggLT0gYzsKICByZXR1cm4gcmV0Owp9CgpmdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CgogIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGEKICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uCiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignImVuZFJlYWRhYmxlKCkiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7CgogIGlmICghc3RhdGUuZW5kRW1pdHRlZCkgewogICAgc3RhdGUuZW5kZWQgPSB0cnVlOwogICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pOwogIH0KfQoKZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7CiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuCiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7CiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTsKICAgIHN0cmVhbS5lbWl0KCdlbmQnKTsKICB9Cn0KCmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHsKICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgZih4c1tpXSwgaSk7CiAgfQp9CgpmdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7CiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7CiAgfQogIHJldHVybiAtMTsKfQp9KS5jYWxsKHRoaXMsX2RlcmVxXygnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHsiLi9fc3RyZWFtX2R1cGxleCI6MTIwLCIuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCI6MTI1LCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveSI6MTI2LCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtIjoxMjcsIl9wcm9jZXNzIjoxOSwiY29yZS11dGlsLWlzIjo5OCwiZXZlbnRzIjoxMDAsImluaGVyaXRzIjoxMDIsImlzYXJyYXkiOjEwNCwicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOjExNywic2FmZS1idWZmZXIiOjEzMiwic3RyaW5nX2RlY29kZXIvIjoxMzQsInV0aWwiOjE4fV0sMTIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkbwovLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhICJmaWx0ZXIiLAovLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZQovLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkCi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLikKLy8KLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYQovLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSwKLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuCi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS4KLy8KLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOgovLwovLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGUKLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKQovLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzCi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWwKLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLgovLwovLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlbgovLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZQovLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGUKLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3QKLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvCi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS4KLy8KLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLAovLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLAovLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nCi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzCi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnkKLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpbgovLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGwKLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJbgovLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGwKLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGQKLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS4KLy8KLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVuawovLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsCi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLgoKJ3VzZSBzdHJpY3QnOwoKbW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07Cgp2YXIgRHVwbGV4ID0gX2RlcmVxXygnLi9fc3RyZWFtX2R1cGxleCcpOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTsKdXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKdXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7CgpmdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHsKICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7CiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7CiAgfTsKCiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7CiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTsKICB0aGlzLndyaXRlY2IgPSBudWxsOwogIHRoaXMud3JpdGVjaHVuayA9IG51bGw7CiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDsKfQoKZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkgewogIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7CiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7CgogIHZhciBjYiA9IHRzLndyaXRlY2I7CgogIGlmICghY2IpIHsKICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTsKICB9CgogIHRzLndyaXRlY2h1bmsgPSBudWxsOwogIHRzLndyaXRlY2IgPSBudWxsOwoKICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpOwoKICBjYihlcik7CgogIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICBycy5yZWFkaW5nID0gZmFsc2U7CiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7CiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7CiAgfQp9CgpmdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykgewogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTsKCiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7CgogIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpOwoKICB2YXIgc3RyZWFtID0gdGhpczsKCiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuCiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoKICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3MKICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlCiAgLy8gc3luYyBndWFyZCBmbGFnLgogIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlOwoKICBpZiAob3B0aW9ucykgewogICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7CiAgfQoKICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuCiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7CiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHsKICAgICAgZG9uZShzdHJlYW0sIGVyLCBkYXRhKTsKICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pOwogIH0pOwp9CgpUcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7CiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlOwogIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpOwp9OwoKLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhCi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy4KLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay4KLy8KLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0Ci8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuCi8vCi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzCi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3UKLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay4KVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTsKfTsKClRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTsKICB0cy53cml0ZWNiID0gY2I7CiAgdHMud3JpdGVjaHVuayA9IGNodW5rOwogIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZzsKICBpZiAoIXRzLnRyYW5zZm9ybWluZykgewogICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspOwogIH0KfTsKCi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuCi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuCi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuClRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikgewogIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlOwoKICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHsKICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7CiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pOwogIH0gZWxzZSB7CiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluCiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC4KICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlOwogIH0KfTsKClRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7CiAgICBjYihlcnIyKTsKICAgIF90aGlzLmVtaXQoJ2Nsb3NlJyk7CiAgfSk7Cn07CgpmdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHsKICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CgogIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7CgogIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnMKICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWQKICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTsKCiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTsKCiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7CgogIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTsKfQp9LHsiLi9fc3RyZWFtX2R1cGxleCI6MTIwLCJjb3JlLXV0aWwtaXMiOjk4LCJpbmhlcml0cyI6MTAyfV0sMTI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLgovLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGwKLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIHByb2Nlc3NOZXh0VGljayA9IF9kZXJlcV8oJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKbW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTsKCi8qIDxyZXBsYWNlbWVudD4gKi8KZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHRoaXMuY2h1bmsgPSBjaHVuazsKICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7CiAgdGhpcy5jYWxsYmFjayA9IGNiOwogIHRoaXMubmV4dCA9IG51bGw7Cn0KCi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdAovLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW0KZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIHRoaXMubmV4dCA9IG51bGw7CiAgdGhpcy5lbnRyeSA9IG51bGw7CiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7CiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpOwogIH07Cn0KLyogPC9yZXBsYWNlbWVudD4gKi8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIER1cGxleDsKLyo8L3JlcGxhY2VtZW50PiovCgpXcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBpbnRlcm5hbFV0aWwgPSB7CiAgZGVwcmVjYXRlOiBfZGVyZXFfKCd1dGlsLWRlcHJlY2F0ZScpCn07Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIFN0cmVhbSA9IF9kZXJlcV8oJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgQnVmZmVyID0gX2RlcmVxXygnc2FmZS1idWZmZXInKS5CdWZmZXI7CnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307CmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHsKICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspOwp9CmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7CiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7Cn0KLyo8L3JlcGxhY2VtZW50PiovCgp2YXIgZGVzdHJveUltcGwgPSBfZGVyZXFfKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpOwoKdXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTsKCmZ1bmN0aW9uIG5vcCgpIHt9CgpmdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkgewogIER1cGxleCA9IER1cGxleCB8fCBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwoKICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW0KICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuCiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CgogIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOwoKICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlCiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWYKICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpCiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyazsKICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0OwogIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtOwoKICAvLyBjYXN0IHRvIGludHMuCiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspOwoKICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkCiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOwoKICAvLyBkcmFpbiBldmVudCBmbGFnLgogIHRoaXMubmVlZERyYWluID0gZmFsc2U7CiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKCkKICB0aGlzLmVuZGluZyA9IGZhbHNlOwogIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWQKICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkCiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOwoKICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWQKICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOwoKICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT8KICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmcKICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLgogIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7CiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOwoKICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nCiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLgogIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC4KICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsKCiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnQKICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nCiAgLy8gc29ja2V0IG9yIGZpbGUuCiAgdGhpcy5sZW5ndGggPSAwOwoKICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLgogIHRoaXMud3JpdGluZyA9IGZhbHNlOwoKICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsCiAgdGhpcy5jb3JrZWQgPSAwOwoKICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSwKICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueQogIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsICJsYXRlciIgc2hvdWxkIGdlbmVyYWxseSBhbHNvCiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuCiAgdGhpcy5zeW5jID0gdHJ1ZTsKCiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaAogIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0CiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uCiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7CgogIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYikKICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHsKICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7CiAgfTsKCiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpCiAgdGhpcy53cml0ZWNiID0gbnVsbDsKCiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLgogIHRoaXMud3JpdGVsZW4gPSAwOwoKICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKCiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3MKICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWQKICB0aGlzLnBlbmRpbmdjYiA9IDA7CgogIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnMKICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtcwogIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsKCiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW4KICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOwoKICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0cwogIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOwoKICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzCiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3bwogIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7Cn0KCldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHsKICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0OwogIHZhciBvdXQgPSBbXTsKICB3aGlsZSAoY3VycmVudCkgewogICAgb3V0LnB1c2goY3VycmVudCk7CiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0OwogIH0KICByZXR1cm4gb3V0Owp9OwoKKGZ1bmN0aW9uICgpIHsKICB0cnkgewogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywgewogICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpOwogICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJykKICAgIH0pOwogIH0gY2F0Y2ggKF8pIHt9Cn0pKCk7CgovLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcywKLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLgp2YXIgcmVhbEhhc0luc3RhbmNlOwppZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7CiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHsKICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7CiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTsKCiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTsKICAgIH0KICB9KTsKfSBlbHNlIHsKICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpczsKICB9Owp9CgpmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7CiAgRHVwbGV4ID0gRHVwbGV4IHx8IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTsKCiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uCiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgCiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLgoKICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGUKICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3IKICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uCiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgewogICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTsKICB9CgogIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTsKCiAgLy8gbGVnYWN5LgogIHRoaXMud3JpdGFibGUgPSB0cnVlOwoKICBpZiAob3B0aW9ucykgewogICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7CiAgfQoKICBTdHJlYW0uY2FsbCh0aGlzKTsKfQoKLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLgpXcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHsKICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpOwp9OwoKZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7CiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTsKICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYgogIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTsKfQoKLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhcgovLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkCi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS4KZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHsKICB2YXIgdmFsaWQgPSB0cnVlOwogIHZhciBlciA9IGZhbHNlOwoKICBpZiAoY2h1bmsgPT09IG51bGwpIHsKICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTsKICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkgewogICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7CiAgfQogIGlmIChlcikgewogICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwogICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7CiAgICB2YWxpZCA9IGZhbHNlOwogIH0KICByZXR1cm4gdmFsaWQ7Cn0KCldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKICB2YXIgcmV0ID0gZmFsc2U7CiAgdmFyIGlzQnVmID0gX2lzVWludDhBcnJheShjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGU7CgogIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgewogICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTsKICB9CgogIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHsKICAgIGNiID0gZW5jb2Rpbmc7CiAgICBlbmNvZGluZyA9IG51bGw7CiAgfQoKICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZzsKCiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7CgogIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkgewogICAgc3RhdGUucGVuZGluZ2NiKys7CiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgfQoKICByZXR1cm4gcmV0Owp9OwoKV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKCiAgc3RhdGUuY29ya2VkKys7Cn07CgpXcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CgogIGlmIChzdGF0ZS5jb3JrZWQpIHsKICAgIHN0YXRlLmNvcmtlZC0tOwoKICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTsKICB9Cn07CgpXcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7CiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuCiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTsKICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpOwogIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7CiAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7CiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHsKICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTsKICB9CiAgcmV0dXJuIGNodW5rOwp9CgovLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXMKLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGUKLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy4KZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikgewogIGlmICghaXNCdWYpIHsKICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpOwogICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykgewogICAgICBpc0J1ZiA9IHRydWU7CiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7CiAgICAgIGNodW5rID0gbmV3Q2h1bms7CiAgICB9CiAgfQogIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKCiAgc3RhdGUubGVuZ3RoICs9IGxlbjsKCiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7CiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuCiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7CgogIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkgewogICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwogICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHsKICAgICAgY2h1bms6IGNodW5rLAogICAgICBlbmNvZGluZzogZW5jb2RpbmcsCiAgICAgIGlzQnVmOiBpc0J1ZiwKICAgICAgY2FsbGJhY2s6IGNiLAogICAgICBuZXh0OiBudWxsCiAgICB9OwogICAgaWYgKGxhc3QpIHsKICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7CiAgICB9CiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxOwogIH0gZWxzZSB7CiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikgewogIHN0YXRlLndyaXRlbGVuID0gbGVuOwogIHN0YXRlLndyaXRlY2IgPSBjYjsKICBzdGF0ZS53cml0aW5nID0gdHJ1ZTsKICBzdGF0ZS5zeW5jID0gdHJ1ZTsKICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7CiAgc3RhdGUuc3luYyA9IGZhbHNlOwp9CgpmdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7CiAgLS1zdGF0ZS5wZW5kaW5nY2I7CgogIGlmIChzeW5jKSB7CiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5CiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFjawogICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7CiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlbgogICAgLy8gYWZ0ZXIgZXJyb3IKICAgIHByb2Nlc3NOZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7CiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTsKICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICB9IGVsc2UgewogICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmCiAgICAvLyBpdCBpcyBhc3luYwogICAgY2IoZXIpOwogICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0CiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yCiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKICB9Cn0KCmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkgewogIHN0YXRlLndyaXRpbmcgPSBmYWxzZTsKICBzdGF0ZS53cml0ZWNiID0gbnVsbDsKICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47CiAgc3RhdGUud3JpdGVsZW4gPSAwOwp9CgpmdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jOwogIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7CgogIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7CgogIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7CiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldAogICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7CgogICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgewogICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTsKICAgIH0KCiAgICBpZiAoc3luYykgewogICAgICAvKjxyZXBsYWNlbWVudD4qLwogICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7CiAgICAgIC8qPC9yZXBsYWNlbWVudD4qLwogICAgfSBlbHNlIHsKICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpOwogICAgfQogIH0KfQoKZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHsKICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7CiAgc3RhdGUucGVuZGluZ2NiLS07CiAgY2IoKTsKICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKfQoKLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3QKLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVybgovLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLgpmdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkgewogIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7CiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTsKICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpOwogIH0KfQoKLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXQKZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkgewogIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlOwogIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDsKCiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHsKICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KCkKICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7CiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpOwogICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTsKICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5OwoKICAgIHZhciBjb3VudCA9IDA7CiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7CiAgICB3aGlsZSAoZW50cnkpIHsKICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5OwogICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7CiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgY291bnQgKz0gMTsKICAgIH0KICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVyczsKCiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7CgogICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWUKICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZQogICAgc3RhdGUucGVuZGluZ2NiKys7CiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKICAgIGlmIChob2xkZXIubmV4dCkgewogICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDsKICAgICAgaG9sZGVyLm5leHQgPSBudWxsOwogICAgfSBlbHNlIHsKICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpOwogICAgfQogIH0gZWxzZSB7CiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lCiAgICB3aGlsZSAoZW50cnkpIHsKICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7CiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nOwogICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjazsKICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwoKICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTsKICAgICAgZW50cnkgPSBlbnRyeS5uZXh0OwogICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlbgogICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLgogICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5CiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLgogICAgICBpZiAoc3RhdGUud3JpdGluZykgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CgogICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKICB9CgogIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsKICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTsKICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7Cn0KCldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpOwp9OwoKV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsOwoKV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKCiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykgewogICAgY2IgPSBjaHVuazsKICAgIGNodW5rID0gbnVsbDsKICAgIGVuY29kaW5nID0gbnVsbDsKICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykgewogICAgY2IgPSBlbmNvZGluZzsKICAgIGVuY29kaW5nID0gbnVsbDsKICB9CgogIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7CgogIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzCiAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgc3RhdGUuY29ya2VkID0gMTsKICAgIHRoaXMudW5jb3JrKCk7CiAgfQoKICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuCiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpOwp9OwoKZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkgewogIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7Cn0KZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHsKICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHsKICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgaWYgKGVycikgewogICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpOwogICAgfQogICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlOwogICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpOwogICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgfSk7Cn0KZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkgewogICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIHN0YXRlLnBlbmRpbmdjYisrOwogICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7CiAgICAgIHByb2Nlc3NOZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpOwogICAgfSBlbHNlIHsKICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlOwogICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7CiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTsKICBpZiAobmVlZCkgewogICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpOwogICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkgewogICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7CiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTsKICAgIH0KICB9CiAgcmV0dXJuIG5lZWQ7Cn0KCmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7CiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTsKICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKICBpZiAoY2IpIHsKICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7CiAgfQogIHN0YXRlLmVuZGVkID0gdHJ1ZTsKICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTsKfQoKZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikgewogIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7CiAgY29ya1JlcS5lbnRyeSA9IG51bGw7CiAgd2hpbGUgKGVudHJ5KSB7CiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjazsKICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgY2IoZXJyKTsKICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICB9CiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkgewogICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxOwogIH0gZWxzZSB7CiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxOwogIH0KfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHsKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkOwogIH0sCiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsKICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbQogICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldAogICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5CiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7CiAgfQp9KTsKCldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTsKV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7CldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7CiAgdGhpcy5lbmQoKTsKICBjYihlcnIpOwp9Owp9KS5jYWxsKHRoaXMsX2RlcmVxXygnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHsiLi9fc3RyZWFtX2R1cGxleCI6MTIwLCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveSI6MTI2LCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtIjoxMjcsIl9wcm9jZXNzIjoxOSwiY29yZS11dGlsLWlzIjo5OCwiaW5oZXJpdHMiOjEwMiwicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOjExNywic2FmZS1idWZmZXIiOjEzMiwidXRpbC1kZXByZWNhdGUiOjEzNX1dLDEyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgpmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOyB9IH0KCnZhciBCdWZmZXIgPSBfZGVyZXFfKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjsKLyo8L3JlcGxhY2VtZW50PiovCgpmdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHsKICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7Cn0KCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7CgogICAgdGhpcy5oZWFkID0gbnVsbDsKICAgIHRoaXMudGFpbCA9IG51bGw7CiAgICB0aGlzLmxlbmd0aCA9IDA7CiAgfQoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7CiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTsKICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTsKICAgIHRoaXMudGFpbCA9IGVudHJ5OwogICAgKyt0aGlzLmxlbmd0aDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7CiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9OwogICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTsKICAgIHRoaXMuaGVhZCA9IGVudHJ5OwogICAgKyt0aGlzLmxlbmd0aDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkgewogICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47CiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDsKICAgIC0tdGhpcy5sZW5ndGg7CiAgICByZXR1cm4gcmV0OwogIH07CgogIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7CiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsOwogICAgdGhpcy5sZW5ndGggPSAwOwogIH07CgogIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnOwogICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7CiAgICB3aGlsZSAocCA9IHAubmV4dCkgewogICAgICByZXQgKz0gcyArIHAuZGF0YTsKICAgIH1yZXR1cm4gcmV0OwogIH07CgogIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTsKICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7CiAgICB2YXIgcCA9IHRoaXMuaGVhZDsKICAgIHZhciBpID0gMDsKICAgIHdoaWxlIChwKSB7CiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpOwogICAgICBpICs9IHAuZGF0YS5sZW5ndGg7CiAgICAgIHAgPSBwLm5leHQ7CiAgICB9CiAgICByZXR1cm4gcmV0OwogIH07CgogIHJldHVybiBCdWZmZXJMaXN0Owp9KCk7Cn0seyJzYWZlLWJ1ZmZlciI6MTMyfV0sMTI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KCnZhciBwcm9jZXNzTmV4dFRpY2sgPSBfZGVyZXFfKCdwcm9jZXNzLW5leHRpY2stYXJncycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUEkKZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7CiAgdmFyIF90aGlzID0gdGhpczsKCiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDsKICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkOwoKICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHsKICAgIGlmIChjYikgewogICAgICBjYihlcnIpOwogICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHsKICAgICAgcHJvY2Vzc05leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpOwogICAgfQogICAgcmV0dXJuOwogIH0KCiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyCiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzCgogIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7CiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7CiAgfQoKICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsCiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTsKICB9CgogIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHsKICAgIGlmICghY2IgJiYgZXJyKSB7CiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7CiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoY2IpIHsKICAgICAgY2IoZXJyKTsKICAgIH0KICB9KTsKfQoKZnVuY3Rpb24gdW5kZXN0cm95KCkgewogIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7CiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7CiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTsKICB9CgogIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlOwogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlOwogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7CiAgfQp9CgpmdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHsKICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTsKfQoKbW9kdWxlLmV4cG9ydHMgPSB7CiAgZGVzdHJveTogZGVzdHJveSwKICB1bmRlc3Ryb3k6IHVuZGVzdHJveQp9Owp9LHsicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOjExN31dLDEyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyOwoKfSx7ImV2ZW50cyI6MTAwfV0sMTI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2gKCn0seyIuL3JlYWRhYmxlIjoxMjl9XSwxMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7CmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0czsKZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7CmV4cG9ydHMuV3JpdGFibGUgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7CmV4cG9ydHMuRHVwbGV4ID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTsKZXhwb3J0cy5UcmFuc2Zvcm0gPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpOwpleHBvcnRzLlBhc3NUaHJvdWdoID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpOwoKfSx7Ii4vbGliL19zdHJlYW1fZHVwbGV4LmpzIjoxMjAsIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiOjEyMSwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyI6MTIyLCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyI6MTIzLCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIjoxMjR9XSwxMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm0KCn0seyIuL3JlYWRhYmxlIjoxMjl9XSwxMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTsKCn0seyIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIjoxMjR9XSwxMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovCnZhciBidWZmZXIgPSBfZGVyZXFfKCdidWZmZXInKQp2YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcgoKLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2VycwpmdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7CiAgZm9yICh2YXIga2V5IGluIHNyYykgewogICAgZHN0W2tleV0gPSBzcmNba2V5XQogIH0KfQppZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7CiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXIKfSBlbHNlIHsKICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKQogIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpCiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyCn0KCmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlcgpjb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKQoKU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpCiAgfQogIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCn0KClNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJykKICB9CiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKQogIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHsKICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7CiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKQogICAgfSBlbHNlIHsKICAgICAgYnVmLmZpbGwoZmlsbCkKICAgIH0KICB9IGVsc2UgewogICAgYnVmLmZpbGwoMCkKICB9CiAgcmV0dXJuIGJ1Zgp9CgpTYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHsKICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJykKICB9CiAgcmV0dXJuIEJ1ZmZlcihzaXplKQp9CgpTYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpCiAgfQogIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKQp9Cgp9LHsiYnVmZmVyIjoyMH1dLDEzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCm1vZHVsZS5leHBvcnRzID0gU3RyZWFtOwoKdmFyIEVFID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyOwp2YXIgaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwoKaW5oZXJpdHMoU3RyZWFtLCBFRSk7ClN0cmVhbS5SZWFkYWJsZSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpOwpTdHJlYW0uV3JpdGFibGUgPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTsKU3RyZWFtLkR1cGxleCA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTsKU3RyZWFtLlRyYW5zZm9ybSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTsKU3RyZWFtLlBhc3NUaHJvdWdoID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7CgovLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueApTdHJlYW0uU3RyZWFtID0gU3RyZWFtOwoKCgovLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50Ci8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuCgpmdW5jdGlvbiBTdHJlYW0oKSB7CiAgRUUuY2FsbCh0aGlzKTsKfQoKU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykgewogIHZhciBzb3VyY2UgPSB0aGlzOwoKICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHsKICAgIGlmIChkZXN0LndyaXRhYmxlKSB7CiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7CiAgICAgICAgc291cmNlLnBhdXNlKCk7CiAgICAgIH0KICAgIH0KICB9CgogIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7CgogIGZ1bmN0aW9uIG9uZHJhaW4oKSB7CiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHsKICAgICAgc291cmNlLnJlc3VtZSgpOwogICAgfQogIH0KCiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTsKCiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlbgogIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLgogIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkgewogICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7CiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7CiAgfQoKICB2YXIgZGlkT25FbmQgPSBmYWxzZTsKICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuOwogICAgZGlkT25FbmQgPSB0cnVlOwoKICAgIGRlc3QuZW5kKCk7CiAgfQoKCiAgZnVuY3Rpb24gb25jbG9zZSgpIHsKICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuOwogICAgZGlkT25FbmQgPSB0cnVlOwoKICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTsKICB9CgogIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy4KICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7CiAgICBjbGVhbnVwKCk7CiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkgewogICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLgogICAgfQogIH0KCiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpOwogIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7CgogIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuCiAgZnVuY3Rpb24gY2xlYW51cCgpIHsKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pOwoKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwogICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpOwoKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CgogICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTsKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTsKCiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApOwogIH0KCiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTsKICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7CgogIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7CgogIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7CgogIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpCiAgcmV0dXJuIGRlc3Q7Cn07Cgp9LHsiZXZlbnRzIjoxMDAsImluaGVyaXRzIjoxMDIsInJlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiOjExOSwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIjoxMjgsInJlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyI6MTI5LCJyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIjoxMzAsInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyI6MTMxfV0sMTM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwoKdmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwoKdmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHsKICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7CiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7CiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzoKICAgICAgcmV0dXJuIHRydWU7CiAgICBkZWZhdWx0OgogICAgICByZXR1cm4gZmFsc2U7CiAgfQp9OwoKZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykgewogIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnOwogIHZhciByZXRyaWVkOwogIHdoaWxlICh0cnVlKSB7CiAgICBzd2l0Y2ggKGVuYykgewogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiAndXRmOCc7CiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuICd1dGYxNmxlJzsKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gJ2xhdGluMSc7CiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgY2FzZSAnaGV4JzoKICAgICAgICByZXR1cm4gZW5jOwogICAgICBkZWZhdWx0OgogICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZAogICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTsKICAgICAgICByZXRyaWVkID0gdHJ1ZTsKICAgIH0KICB9Cn07CgovLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWUKLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5ncwpmdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHsKICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpOwogIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpOwogIHJldHVybiBuZW5jIHx8IGVuYzsKfQoKLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZgovLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGUKLy8gY2hhcmFjdGVycy4KZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjsKZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykgewogIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7CiAgdmFyIG5iOwogIHN3aXRjaCAodGhpcy5lbmNvZGluZykgewogICAgY2FzZSAndXRmMTZsZSc6CiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDsKICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDsKICAgICAgbmIgPSA0OwogICAgICBicmVhazsKICAgIGNhc2UgJ3V0ZjgnOgogICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0OwogICAgICBuYiA9IDQ7CiAgICAgIGJyZWFrOwogICAgY2FzZSAnYmFzZTY0JzoKICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDsKICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7CiAgICAgIG5iID0gMzsKICAgICAgYnJlYWs7CiAgICBkZWZhdWx0OgogICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7CiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kOwogICAgICByZXR1cm47CiAgfQogIHRoaXMubGFzdE5lZWQgPSAwOwogIHRoaXMubGFzdFRvdGFsID0gMDsKICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTsKfQoKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7CiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJzsKICB2YXIgcjsKICB2YXIgaTsKICBpZiAodGhpcy5sYXN0TmVlZCkgewogICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTsKICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJzsKICAgIGkgPSB0aGlzLmxhc3ROZWVkOwogICAgdGhpcy5sYXN0TmVlZCA9IDA7CiAgfSBlbHNlIHsKICAgIGkgPSAwOwogIH0KICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7CiAgcmV0dXJuIHIgfHwgJyc7Cn07CgpTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kOwoKLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0OwoKLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlcgpTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHsKICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7CiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpOwogICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpOwogIH0KICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpOwogIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKfTsKCi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGEKLy8gY29udGludWF0aW9uIGJ5dGUuCmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkgewogIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0OwogIHJldHVybiAtMTsKfQoKLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhbgovLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KQovLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLgpmdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkgewogIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7CiAgaWYgKGogPCBpKSByZXR1cm4gMDsKICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgaWYgKG5iID49IDApIHsKICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7CiAgICByZXR1cm4gbmI7CiAgfQogIGlmICgtLWogPCBpKSByZXR1cm4gMDsKICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICBpZiAobmIgPj0gMCkgewogICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjsKICAgIHJldHVybiBuYjsKICB9CiAgaWYgKC0taiA8IGkpIHJldHVybiAwOwogIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwogIGlmIChuYiA+PSAwKSB7CiAgICBpZiAobmIgPiAwKSB7CiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMzsKICAgIH0KICAgIHJldHVybiBuYjsKICB9CiAgcmV0dXJuIDA7Cn0KCi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhcwovLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdAovLyBvbmUsIHdlICJyZXBsYWNlIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoCi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZwovLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlCi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuCi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGEKLy8gbG9vcC4KZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHsKICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7CiAgICBzZWxmLmxhc3ROZWVkID0gMDsKICAgIHJldHVybiAnXHVmZmZkJy5yZXBlYXQocCk7CiAgfQogIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkgewogICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgICBzZWxmLmxhc3ROZWVkID0gMTsKICAgICAgcmV0dXJuICdcdWZmZmQnLnJlcGVhdChwICsgMSk7CiAgICB9CiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHsKICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgICAgIHNlbGYubGFzdE5lZWQgPSAyOwogICAgICAgIHJldHVybiAnXHVmZmZkJy5yZXBlYXQocCArIDIpOwogICAgICB9CiAgICB9CiAgfQp9CgovLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuCmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHsKICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDsKICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTsKICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjsKICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7CiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTsKICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTsKICB9CiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7CiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoOwp9CgovLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGEKLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkCi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLgpmdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHsKICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7CiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7CiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDsKICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpOwogIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7CiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7Cn0KCi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIGVhY2ggYnVmZmVyZWQgYnl0ZSBvZiBhIChwYXJ0aWFsKQovLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC4KZnVuY3Rpb24gdXRmOEVuZChidWYpIHsKICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7CiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1x1ZmZmZCcucmVwZWF0KHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7CiAgcmV0dXJuIHI7Cn0KCi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuCi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoCi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0bwovLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LgpmdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7CiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7CiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpOwogICAgaWYgKHIpIHsKICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTsKICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7CiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7CiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0OwogICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdOwogICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwogICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHI7CiAgfQogIHRoaXMubGFzdE5lZWQgPSAxOwogIHRoaXMubGFzdFRvdGFsID0gMjsKICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpOwp9CgovLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZQovLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC4KZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7CiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwogIGlmICh0aGlzLmxhc3ROZWVkKSB7CiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkOwogICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTsKICB9CiAgcmV0dXJuIHI7Cn0KCmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7CiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMzsKICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7CiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuOwogIHRoaXMubGFzdFRvdGFsID0gMzsKICBpZiAobiA9PT0gMSkgewogICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgfSBlbHNlIHsKICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdOwogICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgfQogIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTsKfQoKZnVuY3Rpb24gYmFzZTY0RW5kKGJ1ZikgewogIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJzsKICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7CiAgcmV0dXJuIHI7Cn0KCi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleCkKZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7CiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTsKfQoKZnVuY3Rpb24gc2ltcGxlRW5kKGJ1ZikgewogIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwp9Cn0seyJzYWZlLWJ1ZmZlciI6MTMyfV0sMTM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChnbG9iYWwpewoKLyoqCiAqIE1vZHVsZSBleHBvcnRzLgogKi8KCm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlOwoKLyoqCiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuCiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuCiAqCiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLgogKgogKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnMKICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuCiAqCiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9ucwogKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLgogKgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGUKICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWQKICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyAiZGVwcmVjYXRlZCIgdmVyc2lvbiBvZiBgZm5gCiAqIEBhcGkgcHVibGljCiAqLwoKZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7CiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7CiAgICByZXR1cm4gZm47CiAgfQoKICB2YXIgd2FybmVkID0gZmFsc2U7CiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHsKICAgIGlmICghd2FybmVkKSB7CiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpOwogICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7CiAgICAgICAgY29uc29sZS50cmFjZShtc2cpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnNvbGUud2Fybihtc2cpOwogICAgICB9CiAgICAgIHdhcm5lZCA9IHRydWU7CiAgICB9CiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICB9CgogIHJldHVybiBkZXByZWNhdGVkOwp9CgovKioKICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC4KICoKICogQHBhcmFtIHtTdHJpbmd9IG5hbWUKICogQHJldHVybnMge0Jvb2xlYW59CiAqIEBhcGkgcHJpdmF0ZQogKi8KCmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkgewogIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzCiAgdHJ5IHsKICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlOwogIH0gY2F0Y2ggKF8pIHsKICAgIHJldHVybiBmYWxzZTsKICB9CiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07CiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7CiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJzsKfQoKfSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0se31dLDEzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmFyZ3VtZW50c1s0XVsxMDJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKQp9LHsiZHVwIjoxMDJ9XSwxMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykgewogIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcKICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJwogICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nCiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJzsKfQp9LHt9XSwxMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7CmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikgewogIGlmICghaXNTdHJpbmcoZikpIHsKICAgIHZhciBvYmplY3RzID0gW107CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTsKICAgIH0KICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTsKICB9CgogIHZhciBpID0gMTsKICB2YXIgYXJncyA9IGFyZ3VtZW50czsKICB2YXIgbGVuID0gYXJncy5sZW5ndGg7CiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkgewogICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7CiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4OwogICAgc3dpdGNoICh4KSB7CiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pOwogICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTsKICAgICAgY2FzZSAnJWonOgogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTsKICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nOwogICAgICAgIH0KICAgICAgZGVmYXVsdDoKICAgICAgICByZXR1cm4geDsKICAgIH0KICB9KTsKICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkgewogICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHsKICAgICAgc3RyICs9ICcgJyArIHg7CiAgICB9IGVsc2UgewogICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTsKICAgIH0KICB9CiAgcmV0dXJuIHN0cjsKfTsKCgovLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLgovLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LgovLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLgpleHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHsKICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLgogIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9OwogIH0KCiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkgewogICAgcmV0dXJuIGZuOwogIH0KCiAgdmFyIHdhcm5lZCA9IGZhbHNlOwogIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7CiAgICBpZiAoIXdhcm5lZCkgewogICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7CiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7CiAgICAgICAgY29uc29sZS50cmFjZShtc2cpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTsKICAgICAgfQogICAgICB3YXJuZWQgPSB0cnVlOwogICAgfQogICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgfQoKICByZXR1cm4gZGVwcmVjYXRlZDsKfTsKCgp2YXIgZGVidWdzID0ge307CnZhciBkZWJ1Z0Vudmlyb247CmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHsKICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSkKICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7CiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7CiAgaWYgKCFkZWJ1Z3Nbc2V0XSkgewogICAgaWYgKG5ldyBSZWdFeHAoJ1xcYicgKyBzZXQgKyAnXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHsKICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkOwogICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpOwogICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpOwogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9OwogICAgfQogIH0KICByZXR1cm4gZGVidWdzW3NldF07Cn07CgoKLyoqCiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXQKICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuCiAqCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuCiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuCiAqLwovKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovCmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7CiAgLy8gZGVmYXVsdCBvcHRpb25zCiAgdmFyIGN0eCA9IHsKICAgIHNlZW46IFtdLAogICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3IKICB9OwogIC8vIGxlZ2FjeS4uLgogIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTsKICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdOwogIGlmIChpc0Jvb2xlYW4ob3B0cykpIHsKICAgIC8vIGxlZ2FjeS4uLgogICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzOwogIH0gZWxzZSBpZiAob3B0cykgewogICAgLy8gZ290IGFuICJvcHRpb25zIiBvYmplY3QKICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpOwogIH0KICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zCiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTsKICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjsKICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTsKICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7CiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjsKICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7Cn0KZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDsKCgovLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3MKaW5zcGVjdC5jb2xvcnMgPSB7CiAgJ2JvbGQnIDogWzEsIDIyXSwKICAnaXRhbGljJyA6IFszLCAyM10sCiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLAogICdpbnZlcnNlJyA6IFs3LCAyN10sCiAgJ3doaXRlJyA6IFszNywgMzldLAogICdncmV5JyA6IFs5MCwgMzldLAogICdibGFjaycgOiBbMzAsIDM5XSwKICAnYmx1ZScgOiBbMzQsIDM5XSwKICAnY3lhbicgOiBbMzYsIDM5XSwKICAnZ3JlZW4nIDogWzMyLCAzOV0sCiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sCiAgJ3JlZCcgOiBbMzEsIDM5XSwKICAneWVsbG93JyA6IFszMywgMzldCn07CgovLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGUKaW5zcGVjdC5zdHlsZXMgPSB7CiAgJ3NwZWNpYWwnOiAnY3lhbicsCiAgJ251bWJlcic6ICd5ZWxsb3cnLAogICdib29sZWFuJzogJ3llbGxvdycsCiAgJ3VuZGVmaW5lZCc6ICdncmV5JywKICAnbnVsbCc6ICdib2xkJywKICAnc3RyaW5nJzogJ2dyZWVuJywKICAnZGF0ZSc6ICdtYWdlbnRhJywKICAvLyAibmFtZSI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmcKICAncmVnZXhwJzogJ3JlZCcKfTsKCgpmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7CiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTsKCiAgaWYgKHN0eWxlKSB7CiAgICByZXR1cm4gJ1x1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICsKICAgICAgICAgICAnXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7CiAgfSBlbHNlIHsKICAgIHJldHVybiBzdHI7CiAgfQp9CgoKZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHsKICByZXR1cm4gc3RyOwp9CgoKZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHsKICB2YXIgaGFzaCA9IHt9OwoKICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7CiAgICBoYXNoW3ZhbF0gPSB0cnVlOwogIH0pOwoKICByZXR1cm4gaGFzaDsKfQoKCmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykgewogIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy4KICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXQKICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiYKICAgICAgdmFsdWUgJiYKICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJgogICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWwKICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmCiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLgogICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7CiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7CiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHsKICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7CiAgICB9CiAgICByZXR1cm4gcmV0OwogIH0KCiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXMKICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpOwogIGlmIChwcmltaXRpdmUpIHsKICAgIHJldHVybiBwcmltaXRpdmU7CiAgfQoKICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuCiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7CiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7CgogIGlmIChjdHguc2hvd0hpZGRlbikgewogICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTsKICB9CgogIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGUKICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweAogIGlmIChpc0Vycm9yKHZhbHVlKQogICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHsKICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7CiAgfQoKICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuCiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7CiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHsKICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJzsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTsKICAgIH0KICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTsKICAgIH0KICAgIGlmIChpc0RhdGUodmFsdWUpKSB7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTsKICAgIH0KICAgIGlmIChpc0Vycm9yKHZhbHVlKSkgewogICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpOwogICAgfQogIH0KCiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTsKCiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheQogIGlmIChpc0FycmF5KHZhbHVlKSkgewogICAgYXJyYXkgPSB0cnVlOwogICAgYnJhY2VzID0gWydbJywgJ10nXTsKICB9CgogIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9ucwogIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkgewogICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJzsKICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nOwogIH0KCiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHMKICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7CiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTsKICB9CgogIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZQogIGlmIChpc0RhdGUodmFsdWUpKSB7CiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7CiAgfQoKICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yCiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7CiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpOwogIH0KCiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7CiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTsKICB9CgogIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7CiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9CgogIGN0eC5zZWVuLnB1c2godmFsdWUpOwoKICB2YXIgb3V0cHV0OwogIGlmIChhcnJheSkgewogICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7CiAgfSBlbHNlIHsKICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkgewogICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7CiAgICB9KTsKICB9CgogIGN0eC5zZWVuLnBvcCgpOwoKICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpOwp9CgoKZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHsKICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKQogICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7CiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkgewogICAgdmFyIHNpbXBsZSA9ICdcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXiJ8IiQvZywgJycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICJcXCciKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwiL2csICciJykgKyAnXCcnOwogICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpOwogIH0KICBpZiAoaXNOdW1iZXIodmFsdWUpKQogICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTsKICBpZiAoaXNCb29sZWFuKHZhbHVlKSkKICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpOwogIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyAib2JqZWN0Iiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuCiAgaWYgKGlzTnVsbCh2YWx1ZSkpCiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpOwp9CgoKZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHsKICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nOwp9CgoKZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykgewogIHZhciBvdXRwdXQgPSBbXTsKICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkgewogICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7CiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsCiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTsKICAgIH0gZWxzZSB7CiAgICAgIG91dHB1dC5wdXNoKCcnKTsKICAgIH0KICB9CiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgewogICAgaWYgKCFrZXkubWF0Y2goL15cZCskLykpIHsKICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywKICAgICAgICAgIGtleSwgdHJ1ZSkpOwogICAgfQogIH0pOwogIHJldHVybiBvdXRwdXQ7Cn0KCgpmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7CiAgdmFyIG5hbWUsIHN0ciwgZGVzYzsKICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07CiAgaWYgKGRlc2MuZ2V0KSB7CiAgICBpZiAoZGVzYy5zZXQpIHsKICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7CiAgICB9IGVsc2UgewogICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpOwogICAgfQogIH0gZWxzZSB7CiAgICBpZiAoZGVzYy5zZXQpIHsKICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9CiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkgewogICAgbmFtZSA9ICdbJyArIGtleSArICddJzsKICB9CiAgaWYgKCFzdHIpIHsKICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkgewogICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHsKICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpOwogICAgICB9IGVsc2UgewogICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7CiAgICAgIH0KICAgICAgaWYgKHN0ci5pbmRleE9mKCdcbicpID4gLTEpIHsKICAgICAgICBpZiAoYXJyYXkpIHsKICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXG4nKS5tYXAoZnVuY3Rpb24obGluZSkgewogICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7CiAgICAgICAgICB9KS5qb2luKCdcbicpLnN1YnN0cigyKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RyID0gJ1xuJyArIHN0ci5zcGxpdCgnXG4nKS5tYXAoZnVuY3Rpb24obGluZSkgewogICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lOwogICAgICAgICAgfSkuam9pbignXG4nKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9CiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7CiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXGQrJC8pKSB7CiAgICAgIHJldHVybiBzdHI7CiAgICB9CiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpOwogICAgaWYgKG5hbWUubWF0Y2goL14iKFthLXpBLVpfXVthLXpBLVpfMC05XSopIiQvKSkgewogICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTsKICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7CiAgICB9IGVsc2UgewogICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csICJcXCciKQogICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCIvZywgJyInKQogICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXiJ8IiQpL2csICInIik7CiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7CiAgICB9CiAgfQoKICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7Cn0KCgpmdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykgewogIHZhciBudW1MaW5lc0VzdCA9IDA7CiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7CiAgICBudW1MaW5lc0VzdCsrOwogICAgaWYgKGN1ci5pbmRleE9mKCdcbicpID49IDApIG51bUxpbmVzRXN0Kys7CiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cdTAwMWJcW1xkXGQ/bS9nLCAnJykubGVuZ3RoICsgMTsKICB9LCAwKTsKCiAgaWYgKGxlbmd0aCA+IDYwKSB7CiAgICByZXR1cm4gYnJhY2VzWzBdICsKICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXG4gJykgKwogICAgICAgICAgICcgJyArCiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcbiAgJykgKwogICAgICAgICAgICcgJyArCiAgICAgICAgICAgYnJhY2VzWzFdOwogIH0KCiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTsKfQoKCi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYAovLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC4KZnVuY3Rpb24gaXNBcnJheShhcikgewogIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTsKfQpleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5OwoKZnVuY3Rpb24gaXNCb29sZWFuKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7Cn0KZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47CgpmdW5jdGlvbiBpc051bGwoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gbnVsbDsKfQpleHBvcnRzLmlzTnVsbCA9IGlzTnVsbDsKCmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT0gbnVsbDsKfQpleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7CgpmdW5jdGlvbiBpc051bWJlcihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7Cn0KZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyOwoKZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnOwp9CmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZzsKCmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJzsKfQpleHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7CgpmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09PSB2b2lkIDA7Cn0KZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkOwoKZnVuY3Rpb24gaXNSZWdFeHAocmUpIHsKICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7Cn0KZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwOwoKZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDsKfQpleHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7CgpmdW5jdGlvbiBpc0RhdGUoZCkgewogIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nOwp9CmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlOwoKZnVuY3Rpb24gaXNFcnJvcihlKSB7CiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmCiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpOwp9CmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7CgpmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nOwp9CmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247CgpmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHsKICByZXR1cm4gYXJnID09PSBudWxsIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbAogICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJzsKfQpleHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7CgpleHBvcnRzLmlzQnVmZmVyID0gX2RlcmVxXygnLi9zdXBwb3J0L2lzQnVmZmVyJyk7CgpmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7CiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTsKfQoKCmZ1bmN0aW9uIHBhZChuKSB7CiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7Cn0KCgp2YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsCiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107CgovLyAyNiBGZWIgMTY6MTk6MzQKZnVuY3Rpb24gdGltZXN0YW1wKCkgewogIHZhciBkID0gbmV3IERhdGUoKTsKICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSwKICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLAogICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTsKICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpOwp9CgoKLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcApleHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkgewogIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpOwp9OwoKCi8qKgogKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuCiAqCiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmUKICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkCiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlCiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhcwogKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS4KICoKICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZQogKiAgICAgcHJvdG90eXBlLgogKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS4KICovCmV4cG9ydHMuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwoKZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHsKICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0CiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47CgogIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTsKICB2YXIgaSA9IGtleXMubGVuZ3RoOwogIHdoaWxlIChpLS0pIHsKICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTsKICB9CiAgcmV0dXJuIG9yaWdpbjsKfTsKCmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkgewogIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsKfQoKfSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Ii4vc3VwcG9ydC9pc0J1ZmZlciI6MTM3LCJfcHJvY2VzcyI6MTksImluaGVyaXRzIjoxMzZ9XSwxMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKGdsb2JhbCxCdWZmZXIpewpfZGVyZXFfPWZ1bmN0aW9uIHQoZSxuLHIpe2Z1bmN0aW9uIG8oYSxzKXtpZighblthXSl7aWYoIWVbYV0pe3ZhciBjPSJmdW5jdGlvbiI9PXR5cGVvZiBfZGVyZXFfJiZfZGVyZXFfO2lmKCFzJiZjKXJldHVybiBjKGEsITApO2lmKGkpcmV0dXJuIGkoYSwhMCk7dmFyIHU9bmV3IEVycm9yKCJDYW5ub3QgZmluZCBtb2R1bGUgJyIrYSsiJyIpO3Rocm93IHUuY29kZT0iTU9EVUxFX05PVF9GT1VORCIsdX12YXIgZj1uW2FdPXtleHBvcnRzOnt9fTtlW2FdWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciBuPWVbYV1bMV1bdF07cmV0dXJuIG8obnx8dCl9LGYsZi5leHBvcnRzLHQsZSxuLHIpfXJldHVybiBuW2FdLmV4cG9ydHN9Zm9yKHZhciBpPSJmdW5jdGlvbiI9PXR5cGVvZiBfZGVyZXFfJiZfZGVyZXFfLGE9MDthPHIubGVuZ3RoO2ErKylvKHJbYV0pO3JldHVybiBvfSh7MTpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz1be2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9vd25lciIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJuYW1lIixvdXRwdXRzOlt7bmFtZToib19uYW1lIix0eXBlOiJieXRlczMyIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6Im93bmVyIixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJhZGRyZXNzIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6ImNvbnRlbnQiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImJ5dGVzMzIifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITAsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiYWRkciIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYWRkcmVzcyJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJyZXNlcnZlIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6InN1YlJlZ2lzdHJhciIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYWRkcmVzcyJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfbmV3T3duZXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToidHJhbnNmZXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX3JlZ2lzdHJhciIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJzZXRTdWJSZWdpc3RyYXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOltdLG5hbWU6IlJlZ2lzdHJhciIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfYSIsdHlwZToiYWRkcmVzcyJ9LHtuYW1lOiJfcHJpbWFyeSIsdHlwZToiYm9vbCJ9XSxuYW1lOiJzZXRBZGRyZXNzIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9jb250ZW50Iix0eXBlOiJieXRlczMyIn1dLG5hbWU6InNldENvbnRlbnQiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiZGlzb3duIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITEsbmFtZToiX3dpbm5lciIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJBdWN0aW9uRW5kZWQiLHR5cGU6ImV2ZW50In0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITEsbmFtZToiX2JpZGRlciIsdHlwZToiYWRkcmVzcyJ9LHtpbmRleGVkOiExLG5hbWU6Il92YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJOZXdCaWQiLHR5cGU6ImV2ZW50In0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6Im5hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiQ2hhbmdlZCIsdHlwZToiZXZlbnQifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToibmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiEwLG5hbWU6ImFkZHIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToiUHJpbWFyeUNoYW5nZWQiLHR5cGU6ImV2ZW50In1dfSx7fV0sMjpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz1be2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6Im93bmVyIixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJhZGRyZXNzIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9yZWZ1bmQiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToiZGlzb3duIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6ImFkZHIiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImFkZHJlc3MifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToicmVzZXJ2ZSIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfbmV3T3duZXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToidHJhbnNmZXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX2EiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToic2V0QWRkciIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJuYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6IkNoYW5nZWQiLHR5cGU6ImV2ZW50In1dfSx7fV0sMzpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz1be2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6ImZyb20iLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToidG8iLHR5cGU6ImFkZHJlc3MifSx7bmFtZToidmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToidHJhbnNmZXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiZnJvbSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJ0byIsdHlwZToiYWRkcmVzcyJ9LHtuYW1lOiJpbmRpcmVjdElkIix0eXBlOiJieXRlczMyIn0se25hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6ImljYXBUcmFuc2ZlciIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJ0byIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJkZXBvc2l0IixvdXRwdXRzOltdLHBheWFibGU6ITAsdHlwZToiZnVuY3Rpb24ifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToiZnJvbSIsdHlwZToiYWRkcmVzcyJ9LHtpbmRleGVkOiExLG5hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6IkFub255bW91c0RlcG9zaXQiLHR5cGU6ImV2ZW50In0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6ImZyb20iLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMCxuYW1lOiJ0byIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiExLG5hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6IkRlcG9zaXQiLHR5cGU6ImV2ZW50In0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6ImZyb20iLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMCxuYW1lOiJ0byIsdHlwZToiYWRkcmVzcyJ9LHtpbmRleGVkOiExLG5hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6IlRyYW5zZmVyIix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJmcm9tIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITAsbmFtZToidG8iLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMSxuYW1lOiJpbmRpcmVjdElkIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITEsbmFtZToidmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToiSWNhcFRyYW5zZmVyIix0eXBlOiJldmVudCJ9XX0se31dLDQ6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0SW50LHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dEFkZHJlc3N9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvYWRkcmVzcyhcWyhbMC05XSopXF0pPy8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSw1OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dEJvb2wsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0Qm9vbH07KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9eYm9vbChcWyhbMC05XSopXF0pKiQvKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sNjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRCeXRlcyx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9ci5mb3JtYXRPdXRwdXRCeXRlc307KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9eYnl0ZXMoWzAtOV17MSx9KShcWyhbMC05XSopXF0pKiQvKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sNzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi9hZGRyZXNzIiksaT10KCIuL2Jvb2wiKSxhPXQoIi4vaW50Iikscz10KCIuL3VpbnQiKSxjPXQoIi4vZHluYW1pY2J5dGVzIiksdT10KCIuL3N0cmluZyIpLGY9dCgiLi9yZWFsIiksbD10KCIuL3VyZWFsIikscD10KCIuL2J5dGVzIiksaD1mdW5jdGlvbih0LGUpe3JldHVybiB0LmlzRHluYW1pY1R5cGUoZSl8fHQuaXNEeW5hbWljQXJyYXkoZSl9LGQ9ZnVuY3Rpb24odCl7dGhpcy5fdHlwZXM9dH07ZC5wcm90b3R5cGUuX3JlcXVpcmVUeXBlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3R5cGVzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5pc1R5cGUodCl9KVswXTtpZighZSl0aHJvdyBFcnJvcigiaW52YWxpZCBzb2xpZGl0eSB0eXBlITogIit0KTtyZXR1cm4gZX0sZC5wcm90b3R5cGUuZW5jb2RlUGFyYW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGVQYXJhbXMoW3RdLFtlXSl9LGQucHJvdG90eXBlLmVuY29kZVBhcmFtcz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0U29saWRpdHlUeXBlcyh0KSxyPW4ubWFwKGZ1bmN0aW9uKG4scil7cmV0dXJuIG4uZW5jb2RlKGVbcl0sdFtyXSl9KSxvPW4ucmVkdWNlKGZ1bmN0aW9uKGUscixvKXt2YXIgaT1yLnN0YXRpY1BhcnRMZW5ndGgodFtvXSksYT0zMipNYXRoLmZsb29yKChpKzMxKS8zMik7cmV0dXJuIGUrKGgobltvXSx0W29dKT8zMjphKX0sMCk7cmV0dXJuIHRoaXMuZW5jb2RlTXVsdGlXaXRoT2Zmc2V0KHQsbixyLG8pfSxkLnByb3RvdHlwZS5lbmNvZGVNdWx0aVdpdGhPZmZzZXQ9ZnVuY3Rpb24odCxlLG4sbyl7dmFyIGk9IiIsYT10aGlzO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24ocyxjKXtpZihoKGVbY10sdFtjXSkpe2krPXIuZm9ybWF0SW5wdXRJbnQobykuZW5jb2RlKCk7dmFyIHU9YS5lbmNvZGVXaXRoT2Zmc2V0KHRbY10sZVtjXSxuW2NdLG8pO28rPXUubGVuZ3RoLzJ9ZWxzZSBpKz1hLmVuY29kZVdpdGhPZmZzZXQodFtjXSxlW2NdLG5bY10sbyl9KSx0LmZvckVhY2goZnVuY3Rpb24ocixzKXtpZihoKGVbc10sdFtzXSkpe3ZhciBjPWEuZW5jb2RlV2l0aE9mZnNldCh0W3NdLGVbc10sbltzXSxvKTtvKz1jLmxlbmd0aC8yLGkrPWN9fSksaX0sZC5wcm90b3R5cGUuZW5jb2RlV2l0aE9mZnNldD1mdW5jdGlvbih0LGUsbixvKXt2YXIgaT10aGlzLGE9e2R5bmFtaWM6MSxzdGF0aWM6MixvdGhlcjozfSxzPWUuaXNEeW5hbWljQXJyYXkodCk/YS5keW5hbWljOmUuaXNTdGF0aWNBcnJheSh0KT9hLnN0YXRpYzphLm90aGVyO2lmKHMhPT1hLm90aGVyKXt2YXIgYz1lLm5lc3RlZE5hbWUodCksdT1lLnN0YXRpY1BhcnRMZW5ndGgoYyksZj1zPT09YS5keW5hbWljP25bMF06IiI7aWYoZS5pc0R5bmFtaWNBcnJheShjKSlmb3IodmFyIGw9cz09PWEuZHluYW1pYz8yOjAscD0wO3A8bi5sZW5ndGg7cCsrKXM9PT1hLmR5bmFtaWM/bCs9K25bcC0xXVswXXx8MDpzPT09YS5zdGF0aWMmJihsKz0rKG5bcC0xXXx8W10pWzBdfHwwKSxmKz1yLmZvcm1hdElucHV0SW50KG8rcCp1KzMyKmwpLmVuY29kZSgpO2Zvcih2YXIgaD1zPT09YS5keW5hbWljP24ubGVuZ3RoLTE6bi5sZW5ndGgsZD0wO2Q8aDtkKyspe3ZhciBtPWYvMjtzPT09YS5keW5hbWljP2YrPWkuZW5jb2RlV2l0aE9mZnNldChjLGUsbltkKzFdLG8rbSk6cz09PWEuc3RhdGljJiYoZis9aS5lbmNvZGVXaXRoT2Zmc2V0KGMsZSxuW2RdLG8rbSkpfXJldHVybiBmfXJldHVybiBufSxkLnByb3RvdHlwZS5kZWNvZGVQYXJhbT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmRlY29kZVBhcmFtcyhbdF0sZSlbMF19LGQucHJvdG90eXBlLmRlY29kZVBhcmFtcz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0U29saWRpdHlUeXBlcyh0KSxyPXRoaXMuZ2V0T2Zmc2V0cyh0LG4pO3JldHVybiBuLm1hcChmdW5jdGlvbihuLG8pe3JldHVybiBuLmRlY29kZShlLHJbb10sdFtvXSxvKX0pfSxkLnByb3RvdHlwZS5nZXRPZmZzZXRzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGUuc3RhdGljUGFydExlbmd0aCh0W25dKX0pLHI9MTtyPG4ubGVuZ3RoO3IrKyluW3JdKz1uW3ItMV07cmV0dXJuIG4ubWFwKGZ1bmN0aW9uKG4scil7cmV0dXJuIG4tZVtyXS5zdGF0aWNQYXJ0TGVuZ3RoKHRbcl0pfSl9LGQucHJvdG90eXBlLmdldFNvbGlkaXR5VHlwZXM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuX3JlcXVpcmVUeXBlKHQpfSl9O3ZhciBtPW5ldyBkKFtuZXcgbyxuZXcgaSxuZXcgYSxuZXcgcyxuZXcgYyxuZXcgcCxuZXcgdSxuZXcgZixuZXcgbF0pO2UuZXhwb3J0cz1tfSx7Ii4vYWRkcmVzcyI6NCwiLi9ib29sIjo1LCIuL2J5dGVzIjo2LCIuL2R5bmFtaWNieXRlcyI6OCwiLi9mb3JtYXR0ZXJzIjo5LCIuL2ludCI6MTAsIi4vcmVhbCI6MTIsIi4vc3RyaW5nIjoxMywiLi91aW50IjoxNSwiLi91cmVhbCI6MTZ9XSw4OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dER5bmFtaWNCeXRlcyx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9ci5mb3JtYXRPdXRwdXREeW5hbWljQnl0ZXN9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXmJ5dGVzKFxbKFswLTldKilcXSkqJC8pfSxpLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDk6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCJiaWdudW1iZXIuanMiKSxvPXQoIi4uL3V0aWxzL3V0aWxzIiksaT10KCIuLi91dGlscy9jb25maWciKSxhPXQoIi4vcGFyYW0iKSxzPWZ1bmN0aW9uKHQpe3IuY29uZmlnKGkuRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFKTt2YXIgZT1vLnBhZExlZnQoby50b1R3b3NDb21wbGVtZW50KHQpLnRvU3RyaW5nKDE2KSw2NCk7cmV0dXJuIG5ldyBhKGUpfSxjPWZ1bmN0aW9uKHQpe3JldHVybiIxIj09PW5ldyByKHQuc3Vic3RyKDAsMSksMTYpLnRvU3RyaW5nKDIpLnN1YnN0cigwLDEpfSx1PWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGljUGFydCgpfHwiMCI7cmV0dXJuIGMoZSk/bmV3IHIoZSwxNikubWludXMobmV3IHIoImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYiLDE2KSkubWludXMoMSk6bmV3IHIoZSwxNil9LGY9ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0aWNQYXJ0KCl8fCIwIjtyZXR1cm4gbmV3IHIoZSwxNil9O2UuZXhwb3J0cz17Zm9ybWF0SW5wdXRJbnQ6cyxmb3JtYXRJbnB1dEJ5dGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW8udG9IZXgodCkuc3Vic3RyKDIpLG49TWF0aC5mbG9vcigoZS5sZW5ndGgrNjMpLzY0KTtyZXR1cm4gZT1vLnBhZFJpZ2h0KGUsNjQqbiksbmV3IGEoZSl9LGZvcm1hdElucHV0RHluYW1pY0J5dGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW8udG9IZXgodCkuc3Vic3RyKDIpLG49ZS5sZW5ndGgvMixyPU1hdGguZmxvb3IoKGUubGVuZ3RoKzYzKS82NCk7cmV0dXJuIGU9by5wYWRSaWdodChlLDY0KnIpLG5ldyBhKHMobikudmFsdWUrZSl9LGZvcm1hdElucHV0U3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbVV0ZjgodCkuc3Vic3RyKDIpLG49ZS5sZW5ndGgvMixyPU1hdGguZmxvb3IoKGUubGVuZ3RoKzYzKS82NCk7cmV0dXJuIGU9by5wYWRSaWdodChlLDY0KnIpLG5ldyBhKHMobikudmFsdWUrZSl9LGZvcm1hdElucHV0Qm9vbDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGEoIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIrKHQ/IjEiOiIwIikpfSxmb3JtYXRJbnB1dFJlYWw6ZnVuY3Rpb24odCl7cmV0dXJuIHMobmV3IHIodCkudGltZXMobmV3IHIoMikucG93KDEyOCkpKX0sZm9ybWF0T3V0cHV0SW50OnUsZm9ybWF0T3V0cHV0VUludDpmLGZvcm1hdE91dHB1dFJlYWw6ZnVuY3Rpb24odCl7cmV0dXJuIHUodCkuZGl2aWRlZEJ5KG5ldyByKDIpLnBvdygxMjgpKX0sZm9ybWF0T3V0cHV0VVJlYWw6ZnVuY3Rpb24odCl7cmV0dXJuIGYodCkuZGl2aWRlZEJ5KG5ldyByKDIpLnBvdygxMjgpKX0sZm9ybWF0T3V0cHV0Qm9vbDpmdW5jdGlvbih0KXtyZXR1cm4iMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSI9PT10LnN0YXRpY1BhcnQoKX0sZm9ybWF0T3V0cHV0Qnl0ZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLm1hdGNoKC9eYnl0ZXMoWzAtOV0qKS8pLHI9cGFyc2VJbnQoblsxXSk7cmV0dXJuIjB4Iit0LnN0YXRpY1BhcnQoKS5zbGljZSgwLDIqcil9LGZvcm1hdE91dHB1dER5bmFtaWNCeXRlczpmdW5jdGlvbih0KXt2YXIgZT0yKm5ldyByKHQuZHluYW1pY1BhcnQoKS5zbGljZSgwLDY0KSwxNikudG9OdW1iZXIoKTtyZXR1cm4iMHgiK3QuZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsZSl9LGZvcm1hdE91dHB1dFN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT0yKm5ldyByKHQuZHluYW1pY1BhcnQoKS5zbGljZSgwLDY0KSwxNikudG9OdW1iZXIoKTtyZXR1cm4gby50b1V0ZjgodC5keW5hbWljUGFydCgpLnN1YnN0cig2NCxlKSl9LGZvcm1hdE91dHB1dEFkZHJlc3M6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0aWNQYXJ0KCk7cmV0dXJuIjB4IitlLnNsaWNlKGUubGVuZ3RoLTQwLGUubGVuZ3RoKX19fSx7Ii4uL3V0aWxzL2NvbmZpZyI6MTgsIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9wYXJhbSI6MTEsImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwxMDpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRJbnQsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0SW50fTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL15pbnQoWzAtOV0qKT8oXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDExOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vdXRpbHMvdXRpbHMiKSxvPWZ1bmN0aW9uKHQsZSl7dGhpcy52YWx1ZT10fHwiIix0aGlzLm9mZnNldD1lfTtvLnByb3RvdHlwZS5keW5hbWljUGFydExlbmd0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmR5bmFtaWNQYXJ0KCkubGVuZ3RoLzJ9LG8ucHJvdG90eXBlLndpdGhPZmZzZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvKHRoaXMudmFsdWUsdCl9LG8ucHJvdG90eXBlLmNvbWJpbmU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvKHRoaXMudmFsdWUrdC52YWx1ZSl9LG8ucHJvdG90eXBlLmlzRHluYW1pYz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLm9mZnNldH0sby5wcm90b3R5cGUub2Zmc2V0QXNCeXRlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRHluYW1pYygpP3IucGFkTGVmdChyLnRvVHdvc0NvbXBsZW1lbnQodGhpcy5vZmZzZXQpLnRvU3RyaW5nKDE2KSw2NCk6IiJ9LG8ucHJvdG90eXBlLnN0YXRpY1BhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0R5bmFtaWMoKT90aGlzLm9mZnNldEFzQnl0ZXMoKTp0aGlzLnZhbHVlfSxvLnByb3RvdHlwZS5keW5hbWljUGFydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRHluYW1pYygpP3RoaXMudmFsdWU6IiJ9LG8ucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRpY1BhcnQoKSt0aGlzLmR5bmFtaWNQYXJ0KCl9LG8uZW5jb2RlTGlzdD1mdW5jdGlvbih0KXt2YXIgZT0zMip0Lmxlbmd0aCxuPXQubWFwKGZ1bmN0aW9uKHQpe2lmKCF0LmlzRHluYW1pYygpKXJldHVybiB0O3ZhciBuPWU7cmV0dXJuIGUrPXQuZHluYW1pY1BhcnRMZW5ndGgoKSx0LndpdGhPZmZzZXQobil9KTtyZXR1cm4gbi5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlLmR5bmFtaWNQYXJ0KCl9LG4ucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZS5zdGF0aWNQYXJ0KCl9LCIiKSl9LGUuZXhwb3J0cz1vfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMH1dLDEyOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dFJlYWwsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0UmVhbH07KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9yZWFsKFswLTldKik/KFxbKFswLTldKilcXSk/Lyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDEzOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dFN0cmluZyx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9ci5mb3JtYXRPdXRwdXRTdHJpbmd9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXnN0cmluZyhcWyhbMC05XSopXF0pKiQvKX0saS5wcm90b3R5cGUuaXNEeW5hbWljVHlwZT1mdW5jdGlvbigpe3JldHVybiEwfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxNDpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi9wYXJhbSIpLGk9ZnVuY3Rpb24odCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9dC5pbnB1dEZvcm1hdHRlcix0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9dC5vdXRwdXRGb3JtYXR0ZXJ9O2kucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXt0aHJvdyJ0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJ3cml0dGVuIGZvciB0eXBlICIrdH0saS5wcm90b3R5cGUuc3RhdGljUGFydExlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4odGhpcy5uZXN0ZWRUeXBlcyh0KXx8WyJbMV0iXSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBwYXJzZUludCh0LnNsaWNlKDEsLTEpLDEwKXx8MX0pLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9LDMyKX0saS5wcm90b3R5cGUuaXNEeW5hbWljQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4hIWUmJiFlW2UubGVuZ3RoLTFdLm1hdGNoKC9bMC05XXsxLH0vZyl9LGkucHJvdG90eXBlLmlzU3RhdGljQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4hIWUmJiEhZVtlLmxlbmd0aC0xXS5tYXRjaCgvWzAtOV17MSx9L2cpfSxpLnByb3RvdHlwZS5zdGF0aWNBcnJheUxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm5lc3RlZFR5cGVzKHQpO3JldHVybiBlP3BhcnNlSW50KGVbZS5sZW5ndGgtMV0ubWF0Y2goL1swLTldezEsfS9nKXx8MSk6MX0saS5wcm90b3R5cGUubmVzdGVkTmFtZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm5lc3RlZFR5cGVzKHQpO3JldHVybiBlP3Quc3Vic3RyKDAsdC5sZW5ndGgtZVtlLmxlbmd0aC0xXS5sZW5ndGgpOnR9LGkucHJvdG90eXBlLmlzRHluYW1pY1R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0saS5wcm90b3R5cGUubmVzdGVkVHlwZXM9ZnVuY3Rpb24odCl7cmV0dXJuIHQubWF0Y2goLyhcW1swLTldKlxdKS9nKX0saS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5pc0R5bmFtaWNBcnJheShlKT9mdW5jdGlvbigpe3ZhciBvPXQubGVuZ3RoLGk9bi5uZXN0ZWROYW1lKGUpLGE9W107cmV0dXJuIGEucHVzaChyLmZvcm1hdElucHV0SW50KG8pLmVuY29kZSgpKSx0LmZvckVhY2goZnVuY3Rpb24odCl7YS5wdXNoKG4uZW5jb2RlKHQsaSkpfSksYX0oKTp0aGlzLmlzU3RhdGljQXJyYXkoZSk/ZnVuY3Rpb24oKXtmb3IodmFyIHI9bi5zdGF0aWNBcnJheUxlbmd0aChlKSxvPW4ubmVzdGVkTmFtZShlKSxpPVtdLGE9MDthPHI7YSsrKWkucHVzaChuLmVuY29kZSh0W2FdLG8pKTtyZXR1cm4gaX0oKTp0aGlzLl9pbnB1dEZvcm1hdHRlcih0LGUpLmVuY29kZSgpfSxpLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXM7aWYodGhpcy5pc0R5bmFtaWNBcnJheShuKSlyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIG89cGFyc2VJbnQoIjB4Iit0LnN1YnN0cigyKmUsNjQpKSxpPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMipvLDY0KSksYT1vKzMyLHM9ci5uZXN0ZWROYW1lKG4pLGM9ci5zdGF0aWNQYXJ0TGVuZ3RoKHMpLHU9MzIqTWF0aC5mbG9vcigoYyszMSkvMzIpLGY9W10sbD0wO2w8aSp1O2wrPXUpZi5wdXNoKHIuZGVjb2RlKHQsYStsLHMpKTtyZXR1cm4gZn0oKTtpZih0aGlzLmlzU3RhdGljQXJyYXkobikpcmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBvPXIuc3RhdGljQXJyYXlMZW5ndGgobiksaT1lLGE9ci5uZXN0ZWROYW1lKG4pLHM9ci5zdGF0aWNQYXJ0TGVuZ3RoKGEpLGM9MzIqTWF0aC5mbG9vcigocyszMSkvMzIpLHU9W10sZj0wO2Y8bypjO2YrPWMpdS5wdXNoKHIuZGVjb2RlKHQsaStmLGEpKTtyZXR1cm4gdX0oKTtpZih0aGlzLmlzRHluYW1pY1R5cGUobikpcmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGk9cGFyc2VJbnQoIjB4Iit0LnN1YnN0cigyKmUsNjQpKSxhPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMippLDY0KSkscz1NYXRoLmZsb29yKChhKzMxKS8zMiksYz1uZXcgbyh0LnN1YnN0cigyKmksNjQqKDErcykpLDApO3JldHVybiByLl9vdXRwdXRGb3JtYXR0ZXIoYyxuKX0oKTt2YXIgaT10aGlzLnN0YXRpY1BhcnRMZW5ndGgobiksYT1uZXcgbyh0LnN1YnN0cigyKmUsMippKSk7cmV0dXJuIHRoaXMuX291dHB1dEZvcm1hdHRlcihhLG4pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vcGFyYW0iOjExfV0sMTU6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0SW50LHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dFVJbnR9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXnVpbnQoWzAtOV0qKT8oXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDE2OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dFJlYWwsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0VVJlYWx9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXnVyZWFsKFswLTldKik/KFxbKFswLTldKilcXSkqJC8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxNzpbZnVuY3Rpb24odCxlLG4peyJ1c2Ugc3RyaWN0IjsidW5kZWZpbmVkIj09dHlwZW9mIFhNTEh0dHBSZXF1ZXN0P24uWE1MSHR0cFJlcXVlc3Q9e306bi5YTUxIdHRwUmVxdWVzdD1YTUxIdHRwUmVxdWVzdH0se31dLDE4OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiYmlnbnVtYmVyLmpzIiksbz1bIndlaSIsImt3ZWkiLCJNd2VpIiwiR3dlaSIsInN6YWJvIiwiZmlubmV5IiwiZmVtdG9ldGhlciIsInBpY29ldGhlciIsIm5hbm9ldGhlciIsIm1pY3JvZXRoZXIiLCJtaWxsaWV0aGVyIiwibmFubyIsIm1pY3JvIiwibWlsbGkiLCJldGhlciIsImdyYW5kIiwiTWV0aGVyIiwiR2V0aGVyIiwiVGV0aGVyIiwiUGV0aGVyIiwiRWV0aGVyIiwiWmV0aGVyIiwiWWV0aGVyIiwiTmV0aGVyIiwiRGV0aGVyIiwiVmV0aGVyIiwiVWV0aGVyIl07ZS5leHBvcnRzPXtFVEhfUEFERElORzozMixFVEhfU0lHTkFUVVJFX0xFTkdUSDo0LEVUSF9VTklUUzpvLEVUSF9CSUdOVU1CRVJfUk9VTkRJTkdfTU9ERTp7Uk9VTkRJTkdfTU9ERTpyLlJPVU5EX0RPV059LEVUSF9QT0xMSU5HX1RJTUVPVVQ6NTAwLGRlZmF1bHRCbG9jazoibGF0ZXN0IixkZWZhdWx0QWNjb3VudDp2b2lkIDB9fSx7ImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwxOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoImNyeXB0by1qcyIpLG89dCgiY3J5cHRvLWpzL3NoYTMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSYmImhleCI9PT1lLmVuY29kaW5nJiYodC5sZW5ndGg+MiYmIjB4Ij09PXQuc3Vic3RyKDAsMikmJih0PXQuc3Vic3RyKDIpKSx0PXIuZW5jLkhleC5wYXJzZSh0KSksbyh0LHtvdXRwdXRMZW5ndGg6MjU2fSkudG9TdHJpbmcoKX19LHsiY3J5cHRvLWpzIjo1OCwiY3J5cHRvLWpzL3NoYTMiOjc5fV0sMjA6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCJiaWdudW1iZXIuanMiKSxvPXQoIi4vc2hhMy5qcyIpLGk9dCgidXRmOCIpLGE9e25vZXRoZXI6IjAiLHdlaToiMSIsa3dlaToiMTAwMCIsS3dlaToiMTAwMCIsYmFiYmFnZToiMTAwMCIsZmVtdG9ldGhlcjoiMTAwMCIsbXdlaToiMTAwMDAwMCIsTXdlaToiMTAwMDAwMCIsbG92ZWxhY2U6IjEwMDAwMDAiLHBpY29ldGhlcjoiMTAwMDAwMCIsZ3dlaToiMTAwMDAwMDAwMCIsR3dlaToiMTAwMDAwMDAwMCIsc2hhbm5vbjoiMTAwMDAwMDAwMCIsbmFub2V0aGVyOiIxMDAwMDAwMDAwIixuYW5vOiIxMDAwMDAwMDAwIixzemFibzoiMTAwMDAwMDAwMDAwMCIsbWljcm9ldGhlcjoiMTAwMDAwMDAwMDAwMCIsbWljcm86IjEwMDAwMDAwMDAwMDAiLGZpbm5leToiMTAwMDAwMDAwMDAwMDAwMCIsbWlsbGlldGhlcjoiMTAwMDAwMDAwMDAwMDAwMCIsbWlsbGk6IjEwMDAwMDAwMDAwMDAwMDAiLGV0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwIixrZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLGdyYW5kOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwIixtZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLGdldGhlcjoiMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsdGV0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIn0scz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG5ldyBBcnJheShlLXQubGVuZ3RoKzEpLmpvaW4obnx8IjAiKSt0fSxjPWZ1bmN0aW9uKHQpe3Q9aS5lbmNvZGUodCk7Zm9yKHZhciBlPSIiLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dC5jaGFyQ29kZUF0KG4pO2lmKDA9PT1yKWJyZWFrO3ZhciBvPXIudG9TdHJpbmcoMTYpO2UrPW8ubGVuZ3RoPDI/IjAiK286b31yZXR1cm4iMHgiK2V9LHU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSIiLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dC5jaGFyQ29kZUF0KG4pLnRvU3RyaW5nKDE2KTtlKz1yLmxlbmd0aDwyPyIwIityOnJ9cmV0dXJuIjB4IitlfSxmPWZ1bmN0aW9uKHQpe3ZhciBlPWgodCksbj1lLnRvU3RyaW5nKDE2KTtyZXR1cm4gZS5sZXNzVGhhbigwKT8iLTB4IituLnN1YnN0cigxKToiMHgiK259LGw9ZnVuY3Rpb24odCl7aWYodih0KSlyZXR1cm4gZigrdCk7aWYoeSh0KSlyZXR1cm4gZih0KTtpZigib2JqZWN0Ij09dHlwZW9mIHQpcmV0dXJuIGMoSlNPTi5zdHJpbmdpZnkodCkpO2lmKGcodCkpe2lmKDA9PT10LmluZGV4T2YoIi0weCIpKXJldHVybiBmKHQpO2lmKDA9PT10LmluZGV4T2YoIjB4IikpcmV0dXJuIHQ7aWYoIWlzRmluaXRlKHQpKXJldHVybiB1KHQpfXJldHVybiBmKHQpfSxwPWZ1bmN0aW9uKHQpe3Q9dD90LnRvTG93ZXJDYXNlKCk6ImV0aGVyIjt2YXIgZT1hW3RdO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKCJUaGlzIHVuaXQgZG9lc24ndCBleGlzdHMsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzIitKU09OLnN0cmluZ2lmeShhLG51bGwsMikpO3JldHVybiBuZXcgcihlLDEwKX0saD1mdW5jdGlvbih0KXtyZXR1cm4gdD10fHwwLHkodCk/dDohZyh0KXx8MCE9PXQuaW5kZXhPZigiMHgiKSYmMCE9PXQuaW5kZXhPZigiLTB4Iik/bmV3IHIodC50b1N0cmluZygxMCksMTApOm5ldyByKHQucmVwbGFjZSgiMHgiLCIiKSwxNil9LGQ9ZnVuY3Rpb24odCl7cmV0dXJuL14weFswLTlhLWZdezQwfSQvaS50ZXN0KHQpfSxtPWZ1bmN0aW9uKHQpe3Q9dC5yZXBsYWNlKCIweCIsIiIpO2Zvcih2YXIgZT1vKHQudG9Mb3dlckNhc2UoKSksbj0wO248NDA7bisrKWlmKHBhcnNlSW50KGVbbl0sMTYpPjcmJnRbbl0udG9VcHBlckNhc2UoKSE9PXRbbl18fHBhcnNlSW50KGVbbl0sMTYpPD03JiZ0W25dLnRvTG93ZXJDYXNlKCkhPT10W25dKXJldHVybiExO3JldHVybiEwfSx5PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygcnx8dCYmdC5jb25zdHJ1Y3RvciYmIkJpZ051bWJlciI9PT10LmNvbnN0cnVjdG9yLm5hbWV9LGc9ZnVuY3Rpb24odCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0fHx0JiZ0LmNvbnN0cnVjdG9yJiYiU3RyaW5nIj09PXQuY29uc3RydWN0b3IubmFtZX0sdj1mdW5jdGlvbih0KXtyZXR1cm4iYm9vbGVhbiI9PXR5cGVvZiB0fTtlLmV4cG9ydHM9e3BhZExlZnQ6cyxwYWRSaWdodDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHQrbmV3IEFycmF5KGUtdC5sZW5ndGgrMSkuam9pbihufHwiMCIpfSx0b0hleDpsLHRvRGVjaW1hbDpmdW5jdGlvbih0KXtyZXR1cm4gaCh0KS50b051bWJlcigpfSxmcm9tRGVjaW1hbDpmLHRvVXRmODpmdW5jdGlvbih0KXt2YXIgZT0iIixuPTAscj10Lmxlbmd0aDtmb3IoIjB4Ij09PXQuc3Vic3RyaW5nKDAsMikmJihuPTIpO248cjtuKz0yKXt2YXIgbz1wYXJzZUludCh0LnN1YnN0cihuLDIpLDE2KTtpZigwPT09bylicmVhaztlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiBpLmRlY29kZShlKX0sdG9Bc2NpaTpmdW5jdGlvbih0KXt2YXIgZT0iIixuPTAscj10Lmxlbmd0aDtmb3IoIjB4Ij09PXQuc3Vic3RyaW5nKDAsMikmJihuPTIpO248cjtuKz0yKXt2YXIgbz1wYXJzZUludCh0LnN1YnN0cihuLDIpLDE2KTtlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiBlfSxmcm9tVXRmODpjLGZyb21Bc2NpaTp1LHRyYW5zZm9ybVRvRnVsbE5hbWU6ZnVuY3Rpb24odCl7aWYoLTEhPT10Lm5hbWUuaW5kZXhPZigiKCIpKXJldHVybiB0Lm5hbWU7dmFyIGU9dC5pbnB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGV9KS5qb2luKCk7cmV0dXJuIHQubmFtZSsiKCIrZSsiKSJ9LGV4dHJhY3REaXNwbGF5TmFtZTpmdW5jdGlvbih0KXt2YXIgZT10LmluZGV4T2YoIigiKTtyZXR1cm4tMSE9PWU/dC5zdWJzdHIoMCxlKTp0fSxleHRyYWN0VHlwZU5hbWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbmRleE9mKCIoIik7cmV0dXJuLTEhPT1lP3Quc3Vic3RyKGUrMSx0Lmxlbmd0aC0xLShlKzEpKS5yZXBsYWNlKCIgIiwiIik6IiJ9LHRvV2VpOmZ1bmN0aW9uKHQsZSl7dmFyIG49aCh0KS50aW1lcyhwKGUpKTtyZXR1cm4geSh0KT9uOm4udG9TdHJpbmcoMTApfSxmcm9tV2VpOmZ1bmN0aW9uKHQsZSl7dmFyIG49aCh0KS5kaXZpZGVkQnkocChlKSk7cmV0dXJuIHkodCk/bjpuLnRvU3RyaW5nKDEwKX0sdG9CaWdOdW1iZXI6aCx0b1R3b3NDb21wbGVtZW50OmZ1bmN0aW9uKHQpe3ZhciBlPWgodCkucm91bmQoKTtyZXR1cm4gZS5sZXNzVGhhbigwKT9uZXcgcigiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZiIsMTYpLnBsdXMoZSkucGx1cygxKTplfSx0b0FkZHJlc3M6ZnVuY3Rpb24odCl7cmV0dXJuIGQodCk/dDovXlswLTlhLWZdezQwfSQvLnRlc3QodCk/IjB4Iit0OiIweCIrcyhsKHQpLnN1YnN0cigyKSw0MCl9LGlzQmlnTnVtYmVyOnksaXNTdHJpY3RBZGRyZXNzOmQsaXNBZGRyZXNzOmZ1bmN0aW9uKHQpe3JldHVybiEhL14oMHgpP1swLTlhLWZdezQwfSQvaS50ZXN0KHQpJiYoISghL14oMHgpP1swLTlhLWZdezQwfSQvLnRlc3QodCkmJiEvXigweCk/WzAtOUEtRl17NDB9JC8udGVzdCh0KSl8fG0odCkpfSxpc0NoZWNrc3VtQWRkcmVzczptLHRvQ2hlY2tzdW1BZGRyZXNzOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIiI7dD10LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgiMHgiLCIiKTtmb3IodmFyIGU9byh0KSxuPSIweCIscj0wO3I8dC5sZW5ndGg7cisrKXBhcnNlSW50KGVbcl0sMTYpPjc/bis9dFtyXS50b1VwcGVyQ2FzZSgpOm4rPXRbcl07cmV0dXJuIG59LGlzRnVuY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHR9LGlzU3RyaW5nOmcsaXNPYmplY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiYhQXJyYXkuaXNBcnJheSh0KSYmIm9iamVjdCI9PXR5cGVvZiB0fSxpc0Jvb2xlYW46dixpc0FycmF5OmZ1bmN0aW9uKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpfSxpc0pzb246ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhSlNPTi5wYXJzZSh0KX1jYXRjaCh0KXtyZXR1cm4hMX19LGlzQmxvb206ZnVuY3Rpb24odCl7cmV0dXJuISghL14oMHgpP1swLTlhLWZdezUxMn0kL2kudGVzdCh0KXx8IS9eKDB4KT9bMC05YS1mXXs1MTJ9JC8udGVzdCh0KSYmIS9eKDB4KT9bMC05QS1GXXs1MTJ9JC8udGVzdCh0KSl9LGlzVG9waWM6ZnVuY3Rpb24odCl7cmV0dXJuISghL14oMHgpP1swLTlhLWZdezY0fSQvaS50ZXN0KHQpfHwhL14oMHgpP1swLTlhLWZdezY0fSQvLnRlc3QodCkmJiEvXigweCk/WzAtOUEtRl17NjR9JC8udGVzdCh0KSl9fX0seyIuL3NoYTMuanMiOjE5LCJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMiLHV0Zjg6ODR9XSwyMTpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz17dmVyc2lvbjoiMC4yMC4yIn19LHt9XSwyMjpbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9bmV3IG8odCksdGhpcy5jdXJyZW50UHJvdmlkZXI9dCx0aGlzLmV0aD1uZXcgYSh0aGlzKSx0aGlzLmRiPW5ldyBzKHRoaXMpLHRoaXMuc2hoPW5ldyBjKHRoaXMpLHRoaXMubmV0PW5ldyB1KHRoaXMpLHRoaXMucGVyc29uYWw9bmV3IGYodGhpcyksdGhpcy5ieno9bmV3IGwodGhpcyksdGhpcy5zZXR0aW5ncz1uZXcgcCx0aGlzLnZlcnNpb249e2FwaTpoLnZlcnNpb259LHRoaXMucHJvdmlkZXJzPXtIdHRwUHJvdmlkZXI6YixJcGNQcm92aWRlcjpffSx0aGlzLl9leHRlbmQ9eSh0aGlzKSx0aGlzLl9leHRlbmQoe3Byb3BlcnRpZXM6eCgpfSl9dmFyIG89dCgiLi93ZWIzL3JlcXVlc3RtYW5hZ2VyIiksaT10KCIuL3dlYjMvaWJhbiIpLGE9dCgiLi93ZWIzL21ldGhvZHMvZXRoIikscz10KCIuL3dlYjMvbWV0aG9kcy9kYiIpLGM9dCgiLi93ZWIzL21ldGhvZHMvc2hoIiksdT10KCIuL3dlYjMvbWV0aG9kcy9uZXQiKSxmPXQoIi4vd2ViMy9tZXRob2RzL3BlcnNvbmFsIiksbD10KCIuL3dlYjMvbWV0aG9kcy9zd2FybSIpLHA9dCgiLi93ZWIzL3NldHRpbmdzIiksaD10KCIuL3ZlcnNpb24uanNvbiIpLGQ9dCgiLi91dGlscy91dGlscyIpLG09dCgiLi91dGlscy9zaGEzIikseT10KCIuL3dlYjMvZXh0ZW5kIiksZz10KCIuL3dlYjMvYmF0Y2giKSx2PXQoIi4vd2ViMy9wcm9wZXJ0eSIpLGI9dCgiLi93ZWIzL2h0dHBwcm92aWRlciIpLF89dCgiLi93ZWIzL2lwY3Byb3ZpZGVyIiksdz10KCJiaWdudW1iZXIuanMiKTtyLnByb3ZpZGVycz17SHR0cFByb3ZpZGVyOmIsSXBjUHJvdmlkZXI6X30sci5wcm90b3R5cGUuc2V0UHJvdmlkZXI9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXIuc2V0UHJvdmlkZXIodCksdGhpcy5jdXJyZW50UHJvdmlkZXI9dH0sci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXIucmVzZXQodCksdGhpcy5zZXR0aW5ncz1uZXcgcH0sci5wcm90b3R5cGUuQmlnTnVtYmVyPXcsci5wcm90b3R5cGUudG9IZXg9ZC50b0hleCxyLnByb3RvdHlwZS50b0FzY2lpPWQudG9Bc2NpaSxyLnByb3RvdHlwZS50b1V0Zjg9ZC50b1V0Zjgsci5wcm90b3R5cGUuZnJvbUFzY2lpPWQuZnJvbUFzY2lpLHIucHJvdG90eXBlLmZyb21VdGY4PWQuZnJvbVV0Zjgsci5wcm90b3R5cGUudG9EZWNpbWFsPWQudG9EZWNpbWFsLHIucHJvdG90eXBlLmZyb21EZWNpbWFsPWQuZnJvbURlY2ltYWwsci5wcm90b3R5cGUudG9CaWdOdW1iZXI9ZC50b0JpZ051bWJlcixyLnByb3RvdHlwZS50b1dlaT1kLnRvV2VpLHIucHJvdG90eXBlLmZyb21XZWk9ZC5mcm9tV2VpLHIucHJvdG90eXBlLmlzQWRkcmVzcz1kLmlzQWRkcmVzcyxyLnByb3RvdHlwZS5pc0NoZWNrc3VtQWRkcmVzcz1kLmlzQ2hlY2tzdW1BZGRyZXNzLHIucHJvdG90eXBlLnRvQ2hlY2tzdW1BZGRyZXNzPWQudG9DaGVja3N1bUFkZHJlc3Msci5wcm90b3R5cGUuaXNJQkFOPWQuaXNJQkFOLHIucHJvdG90eXBlLnBhZExlZnQ9ZC5wYWRMZWZ0LHIucHJvdG90eXBlLnBhZFJpZ2h0PWQucGFkUmlnaHQsci5wcm90b3R5cGUuc2hhMz1mdW5jdGlvbih0LGUpe3JldHVybiIweCIrbSh0LGUpfSxyLnByb3RvdHlwZS5mcm9tSUNBUD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkodCkuYWRkcmVzcygpfTt2YXIgeD1mdW5jdGlvbigpe3JldHVybltuZXcgdih7bmFtZToidmVyc2lvbi5ub2RlIixnZXR0ZXI6IndlYjNfY2xpZW50VmVyc2lvbiJ9KSxuZXcgdih7bmFtZToidmVyc2lvbi5uZXR3b3JrIixnZXR0ZXI6Im5ldF92ZXJzaW9uIixpbnB1dEZvcm1hdHRlcjpkLnRvRGVjaW1hbH0pLG5ldyB2KHtuYW1lOiJ2ZXJzaW9uLmV0aGVyZXVtIixnZXR0ZXI6ImV0aF9wcm90b2NvbFZlcnNpb24iLGlucHV0Rm9ybWF0dGVyOmQudG9EZWNpbWFsfSksbmV3IHYoe25hbWU6InZlcnNpb24ud2hpc3BlciIsZ2V0dGVyOiJzaGhfdmVyc2lvbiIsaW5wdXRGb3JtYXR0ZXI6ZC50b0RlY2ltYWx9KV19O3IucHJvdG90eXBlLmlzQ29ubmVjdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VycmVudFByb3ZpZGVyJiZ0aGlzLmN1cnJlbnRQcm92aWRlci5pc0Nvbm5lY3RlZCgpfSxyLnByb3RvdHlwZS5jcmVhdGVCYXRjaD1mdW5jdGlvbigpe3JldHVybiBuZXcgZyh0aGlzKX0sZS5leHBvcnRzPXJ9LHsiLi91dGlscy9zaGEzIjoxOSwiLi91dGlscy91dGlscyI6MjAsIi4vdmVyc2lvbi5qc29uIjoyMSwiLi93ZWIzL2JhdGNoIjoyNCwiLi93ZWIzL2V4dGVuZCI6MjgsIi4vd2ViMy9odHRwcHJvdmlkZXIiOjMyLCIuL3dlYjMvaWJhbiI6MzMsIi4vd2ViMy9pcGNwcm92aWRlciI6MzQsIi4vd2ViMy9tZXRob2RzL2RiIjozNywiLi93ZWIzL21ldGhvZHMvZXRoIjozOCwiLi93ZWIzL21ldGhvZHMvbmV0IjozOSwiLi93ZWIzL21ldGhvZHMvcGVyc29uYWwiOjQwLCIuL3dlYjMvbWV0aG9kcy9zaGgiOjQxLCIuL3dlYjMvbWV0aG9kcy9zd2FybSI6NDIsIi4vd2ViMy9wcm9wZXJ0eSI6NDUsIi4vd2ViMy9yZXF1ZXN0bWFuYWdlciI6NDYsIi4vd2ViMy9zZXR0aW5ncyI6NDcsImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwyMzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3NoYTMiKSxvPXQoIi4vZXZlbnQiKSxpPXQoIi4vZm9ybWF0dGVycyIpLGE9dCgiLi4vdXRpbHMvdXRpbHMiKSxzPXQoIi4vZmlsdGVyIiksYz10KCIuL21ldGhvZHMvd2F0Y2hlcyIpLHU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQsdGhpcy5fanNvbj1lLHRoaXMuX2FkZHJlc3M9bn07dS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQpe3Q9dHx8e307dmFyIGU9e307cmV0dXJuWyJmcm9tQmxvY2siLCJ0b0Jsb2NrIl0uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT10W2VdfSkuZm9yRWFjaChmdW5jdGlvbihuKXtlW25dPWkuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcih0W25dKX0pLGUuYWRkcmVzcz10aGlzLl9hZGRyZXNzLGV9LHUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0KXt0LmRhdGE9dC5kYXRhfHwiIix0LnRvcGljcz10LnRvcGljc3x8W107dmFyIGU9dC50b3BpY3NbMF0uc2xpY2UoMiksbj10aGlzLl9qc29uLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gZT09PXIoYS50cmFuc2Zvcm1Ub0Z1bGxOYW1lKHQpKX0pWzBdO3JldHVybiBuP25ldyBvKHRoaXMuX3JlcXVlc3RNYW5hZ2VyLG4sdGhpcy5fYWRkcmVzcykuZGVjb2RlKHQpOihjb25zb2xlLndhcm4oImNhbm5vdCBmaW5kIGV2ZW50IGZvciBsb2ciKSx0KX0sdS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbih0LGUpe2EuaXNGdW5jdGlvbihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSkmJihlPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdLDE9PT1hcmd1bWVudHMubGVuZ3RoJiYodD1udWxsKSk7dmFyIG49dGhpcy5lbmNvZGUodCkscj10aGlzLmRlY29kZS5iaW5kKHRoaXMpO3JldHVybiBuZXcgcyhuLCJldGgiLHRoaXMuX3JlcXVlc3RNYW5hZ2VyLGMuZXRoKCkscixlKX0sdS5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTt0LmFsbEV2ZW50cz1lfSxlLmV4cG9ydHM9dX0seyIuLi91dGlscy9zaGEzIjoxOSwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2V2ZW50IjoyNywiLi9maWx0ZXIiOjI5LCIuL2Zvcm1hdHRlcnMiOjMwLCIuL21ldGhvZHMvd2F0Y2hlcyI6NDN9XSwyNDpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vanNvbnJwYyIpLG89dCgiLi9lcnJvcnMiKSxpPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXIsdGhpcy5yZXF1ZXN0cz1bXX07aS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdHMucHVzaCh0KX0saS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucmVxdWVzdHM7dGhpcy5yZXF1ZXN0TWFuYWdlci5zZW5kQmF0Y2godCxmdW5jdGlvbihlLG4pe249bnx8W10sdC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gbltlXXx8e319KS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7aWYodFtuXS5jYWxsYmFjayl7aWYoIXIuaXNWYWxpZFJlc3BvbnNlKGUpKXJldHVybiB0W25dLmNhbGxiYWNrKG8uSW52YWxpZFJlc3BvbnNlKGUpKTt0W25dLmNhbGxiYWNrKG51bGwsdFtuXS5mb3JtYXQ/dFtuXS5mb3JtYXQoZS5yZXN1bHQpOmUucmVzdWx0KX19KX0pfSxlLmV4cG9ydHM9aX0seyIuL2Vycm9ycyI6MjYsIi4vanNvbnJwYyI6MzV9XSwyNTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9zb2xpZGl0eS9jb2RlciIpLGk9dCgiLi9ldmVudCIpLGE9dCgiLi9mdW5jdGlvbiIpLHM9dCgiLi9hbGxldmVudHMiKSxjPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiJjb25zdHJ1Y3RvciI9PT10LnR5cGUmJnQuaW5wdXRzLmxlbmd0aD09PWUubGVuZ3RofSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlucHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBvLmVuY29kZVBhcmFtcyh0LGUpfSlbMF18fCIifSx1PWZ1bmN0aW9uKHQpe3QuYWJpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT09dC50eXBlfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgYSh0Ll9ldGgsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sZj1mdW5jdGlvbih0KXt2YXIgZT10LmFiaS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuImV2ZW50Ij09PXQudHlwZX0pO25ldyBzKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpLmF0dGFjaFRvQ29udHJhY3QodCksZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sbD1mdW5jdGlvbih0LGUpe3ZhciBuPTAscj0hMSxvPXQuX2V0aC5maWx0ZXIoImxhdGVzdCIsZnVuY3Rpb24oaSl7aWYoIWkmJiFyKWlmKCsrbj41MCl7aWYoby5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKXt9KSxyPSEwLCFlKXRocm93IG5ldyBFcnJvcigiQ29udHJhY3QgdHJhbnNhY3Rpb24gY291bGRuJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzIik7ZShuZXcgRXJyb3IoIkNvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkbid0IGJlIGZvdW5kIGFmdGVyIDUwIGJsb2NrcyIpKX1lbHNlIHQuX2V0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodC50cmFuc2FjdGlvbkhhc2gsZnVuY3Rpb24obixpKXtpJiYhciYmdC5fZXRoLmdldENvZGUoaS5jb250cmFjdEFkZHJlc3MsZnVuY3Rpb24obixhKXtpZighciYmYSlpZihvLnN0b3BXYXRjaGluZyhmdW5jdGlvbigpe30pLHI9ITAsYS5sZW5ndGg+Myl0LmFkZHJlc3M9aS5jb250cmFjdEFkZHJlc3MsdSh0KSxmKHQpLGUmJmUobnVsbCx0KTtlbHNle2lmKCFlKXRocm93IG5ldyBFcnJvcigiVGhlIGNvbnRyYWN0IGNvZGUgY291bGRuJ3QgYmUgc3RvcmVkLCBwbGVhc2UgY2hlY2sgeW91ciBnYXMgYW1vdW50LiIpO2UobmV3IEVycm9yKCJUaGUgY29udHJhY3QgY29kZSBjb3VsZG4ndCBiZSBzdG9yZWQsIHBsZWFzZSBjaGVjayB5b3VyIGdhcyBhbW91bnQuIikpfX0pfSl9KX0scD1mdW5jdGlvbih0LGUpe3RoaXMuZXRoPXQsdGhpcy5hYmk9ZSx0aGlzLm5ldz1mdW5jdGlvbigpe3ZhciB0LG49bmV3IGgodGhpcy5ldGgsdGhpcy5hYmkpLG89e30saT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3IuaXNGdW5jdGlvbihpW2kubGVuZ3RoLTFdKSYmKHQ9aS5wb3AoKSk7dmFyIGE9aVtpLmxlbmd0aC0xXTtpZihyLmlzT2JqZWN0KGEpJiYhci5pc0FycmF5KGEpJiYobz1pLnBvcCgpKSxvLnZhbHVlPjAmJiEoZS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuImNvbnN0cnVjdG9yIj09PXQudHlwZSYmdC5pbnB1dHMubGVuZ3RoPT09aS5sZW5ndGh9KVswXXx8e30pLnBheWFibGUpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBjb25zdHJ1Y3RvciIpO3ZhciBzPWModGhpcy5hYmksaSk7aWYoby5kYXRhKz1zLHQpdGhpcy5ldGguc2VuZFRyYW5zYWN0aW9uKG8sZnVuY3Rpb24oZSxyKXtlP3QoZSk6KG4udHJhbnNhY3Rpb25IYXNoPXIsdChudWxsLG4pLGwobix0KSl9KTtlbHNle3ZhciB1PXRoaXMuZXRoLnNlbmRUcmFuc2FjdGlvbihvKTtuLnRyYW5zYWN0aW9uSGFzaD11LGwobil9cmV0dXJuIG59LHRoaXMubmV3LmdldERhdGE9dGhpcy5nZXREYXRhLmJpbmQodGhpcyl9O3AucHJvdG90eXBlLmF0PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGgodGhpcy5ldGgsdGhpcy5hYmksdCk7cmV0dXJuIHUobiksZihuKSxlJiZlKG51bGwsbiksbn0scC5wcm90b3R5cGUuZ2V0RGF0YT1mdW5jdGlvbigpe3ZhciB0PXt9LGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxuPWVbZS5sZW5ndGgtMV07ci5pc09iamVjdChuKSYmIXIuaXNBcnJheShuKSYmKHQ9ZS5wb3AoKSk7dmFyIG89Yyh0aGlzLmFiaSxlKTtyZXR1cm4gdC5kYXRhKz1vLHQuZGF0YX07dmFyIGg9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX2V0aD10LHRoaXMudHJhbnNhY3Rpb25IYXNoPW51bGwsdGhpcy5hZGRyZXNzPW4sdGhpcy5hYmk9ZX07ZS5leHBvcnRzPXB9LHsiLi4vc29saWRpdHkvY29kZXIiOjcsIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9hbGxldmVudHMiOjIzLCIuL2V2ZW50IjoyNywiLi9mdW5jdGlvbiI6MzF9XSwyNjpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz17SW52YWxpZE51bWJlck9mU29saWRpdHlBcmdzOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBFcnJvcigiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIFNvbGlkaXR5IGZ1bmN0aW9uIil9LEludmFsaWROdW1iZXJPZlJQQ1BhcmFtczpmdW5jdGlvbigpe3JldHVybiBuZXcgRXJyb3IoIkludmFsaWQgbnVtYmVyIG9mIGlucHV0IHBhcmFtZXRlcnMgdG8gUlBDIG1ldGhvZCIpfSxJbnZhbGlkQ29ubmVjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEVycm9yKCJDT05ORUNUSU9OIEVSUk9SOiBDb3VsZG4ndCBjb25uZWN0IHRvIG5vZGUgIit0KyIuIil9LEludmFsaWRQcm92aWRlcjpmdW5jdGlvbigpe3JldHVybiBuZXcgRXJyb3IoIlByb3ZpZGVyIG5vdCBzZXQgb3IgaW52YWxpZCIpfSxJbnZhbGlkUmVzcG9uc2U6ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5lcnJvciYmdC5lcnJvci5tZXNzYWdlP3QuZXJyb3IubWVzc2FnZToiSW52YWxpZCBKU09OIFJQQyByZXNwb25zZTogIitKU09OLnN0cmluZ2lmeSh0KTtyZXR1cm4gbmV3IEVycm9yKGUpfSxDb25uZWN0aW9uVGltZW91dDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEVycm9yKCJDT05ORUNUSU9OIFRJTUVPVVQ6IHRpbWVvdXQgb2YgIit0KyIgbXMgYWNoaXZlZCIpfX19LHt9XSwyNzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9zb2xpZGl0eS9jb2RlciIpLGk9dCgiLi9mb3JtYXR0ZXJzIiksYT10KCIuLi91dGlscy9zaGEzIikscz10KCIuL2ZpbHRlciIpLGM9dCgiLi9tZXRob2RzL3dhdGNoZXMiKSx1PWZ1bmN0aW9uKHQsZSxuKXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10LHRoaXMuX3BhcmFtcz1lLmlucHV0cyx0aGlzLl9uYW1lPXIudHJhbnNmb3JtVG9GdWxsTmFtZShlKSx0aGlzLl9hZGRyZXNzPW4sdGhpcy5fYW5vbnltb3VzPWUuYW5vbnltb3VzfTt1LnByb3RvdHlwZS50eXBlcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5pbmRleGVkPT09dH0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlfSl9LHUucHJvdG90eXBlLmRpc3BsYXlOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpfSx1LnByb3RvdHlwZS50eXBlTmFtZT1mdW5jdGlvbigpe3JldHVybiByLmV4dHJhY3RUeXBlTmFtZSh0aGlzLl9uYW1lKX0sdS5wcm90b3R5cGUuc2lnbmF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcy5fbmFtZSl9LHUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUpe3Q9dHx8e30sZT1lfHx7fTt2YXIgbj17fTtbImZyb21CbG9jayIsInRvQmxvY2siXS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PWVbdF19KS5mb3JFYWNoKGZ1bmN0aW9uKHQpe25bdF09aS5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKGVbdF0pfSksbi50b3BpY3M9W10sbi5hZGRyZXNzPXRoaXMuX2FkZHJlc3MsdGhpcy5fYW5vbnltb3VzfHxuLnRvcGljcy5wdXNoKCIweCIrdGhpcy5zaWduYXR1cmUoKSk7dmFyIGE9dGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hMD09PXQuaW5kZXhlZH0pLm1hcChmdW5jdGlvbihlKXt2YXIgbj10W2UubmFtZV07cmV0dXJuIHZvaWQgMD09PW58fG51bGw9PT1uP251bGw6ci5pc0FycmF5KG4pP24ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiIweCIrby5lbmNvZGVQYXJhbShlLnR5cGUsdCl9KToiMHgiK28uZW5jb2RlUGFyYW0oZS50eXBlLG4pfSk7cmV0dXJuIG4udG9waWNzPW4udG9waWNzLmNvbmNhdChhKSxufSx1LnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24odCl7dC5kYXRhPXQuZGF0YXx8IiIsdC50b3BpY3M9dC50b3BpY3N8fFtdO3ZhciBlPSh0aGlzLl9hbm9ueW1vdXM/dC50b3BpY3M6dC50b3BpY3Muc2xpY2UoMSkpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zbGljZSgyKX0pLmpvaW4oIiIpLG49by5kZWNvZGVQYXJhbXModGhpcy50eXBlcyghMCksZSkscj10LmRhdGEuc2xpY2UoMiksYT1vLmRlY29kZVBhcmFtcyh0aGlzLnR5cGVzKCExKSxyKSxzPWkub3V0cHV0TG9nRm9ybWF0dGVyKHQpO3JldHVybiBzLmV2ZW50PXRoaXMuZGlzcGxheU5hbWUoKSxzLmFkZHJlc3M9dC5hZGRyZXNzLHMuYXJncz10aGlzLl9wYXJhbXMucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbZS5uYW1lXT1lLmluZGV4ZWQ/bi5zaGlmdCgpOmEuc2hpZnQoKSx0fSx7fSksZGVsZXRlIHMuZGF0YSxkZWxldGUgcy50b3BpY3Msc30sdS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbih0LGUsbil7ci5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdKSYmKG49YXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0sMj09PWFyZ3VtZW50cy5sZW5ndGgmJihlPW51bGwpLDE9PT1hcmd1bWVudHMubGVuZ3RoJiYoZT1udWxsLHQ9e30pKTt2YXIgbz10aGlzLmVuY29kZSh0LGUpLGk9dGhpcy5kZWNvZGUuYmluZCh0aGlzKTtyZXR1cm4gbmV3IHMobywiZXRoIix0aGlzLl9yZXF1ZXN0TWFuYWdlcixjLmV0aCgpLGksbil9LHUucHJvdG90eXBlLmF0dGFjaFRvQ29udHJhY3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5leGVjdXRlLmJpbmQodGhpcyksbj10aGlzLmRpc3BsYXlOYW1lKCk7dFtuXXx8KHRbbl09ZSksdFtuXVt0aGlzLnR5cGVOYW1lKCldPXRoaXMuZXhlY3V0ZS5iaW5kKHRoaXMsdCl9LGUuZXhwb3J0cz11fSx7Ii4uL3NvbGlkaXR5L2NvZGVyIjo3LCIuLi91dGlscy9zaGEzIjoxOSwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2ZpbHRlciI6MjksIi4vZm9ybWF0dGVycyI6MzAsIi4vbWV0aG9kcy93YXRjaGVzIjo0M31dLDI4OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuLy4uL3V0aWxzL3V0aWxzIiksaT10KCIuL21ldGhvZCIpLGE9dCgiLi9wcm9wZXJ0eSIpO2UuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbihlKXt2YXIgbjtlLnByb3BlcnR5Pyh0W2UucHJvcGVydHldfHwodFtlLnByb3BlcnR5XT17fSksbj10W2UucHJvcGVydHldKTpuPXQsZS5tZXRob2RzJiZlLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvT2JqZWN0KG4pLGUuc2V0UmVxdWVzdE1hbmFnZXIodC5fcmVxdWVzdE1hbmFnZXIpfSksZS5wcm9wZXJ0aWVzJiZlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvT2JqZWN0KG4pLGUuc2V0UmVxdWVzdE1hbmFnZXIodC5fcmVxdWVzdE1hbmFnZXIpfSl9O3JldHVybiBlLmZvcm1hdHRlcnM9cixlLnV0aWxzPW8sZS5NZXRob2Q9aSxlLlByb3BlcnR5PWEsZX19LHsiLi8uLi91dGlscy91dGlscyI6MjAsIi4vZm9ybWF0dGVycyI6MzAsIi4vbWV0aG9kIjozNiwiLi9wcm9wZXJ0eSI6NDV9XSwyOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dHx8dm9pZCAwPT09dD9udWxsOjA9PT0odD1TdHJpbmcodCkpLmluZGV4T2YoIjB4Iik/dDpvLmZyb21VdGY4KHQpfSxhPWZ1bmN0aW9uKHQsZSl7aWYoby5pc1N0cmluZyh0KSlyZXR1cm4gdDtzd2l0Y2godD10fHx7fSxlKXtjYXNlImV0aCI6cmV0dXJuIHQudG9waWNzPXQudG9waWNzfHxbXSx0LnRvcGljcz10LnRvcGljcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG8uaXNBcnJheSh0KT90Lm1hcChpKTppKHQpfSkse3RvcGljczp0LnRvcGljcyxmcm9tOnQuZnJvbSx0bzp0LnRvLGFkZHJlc3M6dC5hZGRyZXNzLGZyb21CbG9jazpyLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIodC5mcm9tQmxvY2spLHRvQmxvY2s6ci5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKHQudG9CbG9jayl9O2Nhc2Uic2hoIjpyZXR1cm4gdH19LHM9ZnVuY3Rpb24odCxlKXtvLmlzU3RyaW5nKHQub3B0aW9ucyl8fHQuZ2V0KGZ1bmN0aW9uKHQsbil7dCYmZSh0KSxvLmlzQXJyYXkobikmJm4uZm9yRWFjaChmdW5jdGlvbih0KXtlKG51bGwsdCl9KX0pfSxjPWZ1bmN0aW9uKHQpe3QucmVxdWVzdE1hbmFnZXIuc3RhcnRQb2xsaW5nKHttZXRob2Q6dC5pbXBsZW1lbnRhdGlvbi5wb2xsLmNhbGwscGFyYW1zOlt0LmZpbHRlcklkXX0sdC5maWx0ZXJJZCxmdW5jdGlvbihlLG4pe2lmKGUpcmV0dXJuIHQuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7dChlKX0pO28uaXNBcnJheShuKSYmbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe2U9dC5mb3JtYXR0ZXI/dC5mb3JtYXR0ZXIoZSk6ZSx0LmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QobnVsbCxlKX0pfSl9LHQuc3RvcFdhdGNoaW5nLmJpbmQodCkpfSx1PWZ1bmN0aW9uKHQsZSxuLHIsbyxpLHUpe3ZhciBmPXRoaXMsbD17fTtyZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Quc2V0UmVxdWVzdE1hbmFnZXIobiksdC5hdHRhY2hUb09iamVjdChsKX0pLHRoaXMucmVxdWVzdE1hbmFnZXI9bix0aGlzLm9wdGlvbnM9YSh0LGUpLHRoaXMuaW1wbGVtZW50YXRpb249bCx0aGlzLmZpbHRlcklkPW51bGwsdGhpcy5jYWxsYmFja3M9W10sdGhpcy5nZXRMb2dzQ2FsbGJhY2tzPVtdLHRoaXMucG9sbEZpbHRlcnM9W10sdGhpcy5mb3JtYXR0ZXI9byx0aGlzLmltcGxlbWVudGF0aW9uLm5ld0ZpbHRlcih0aGlzLm9wdGlvbnMsZnVuY3Rpb24odCxlKXtpZih0KWYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oZSl7ZSh0KX0pLCJmdW5jdGlvbiI9PXR5cGVvZiB1JiZ1KHQpO2Vsc2UgaWYoZi5maWx0ZXJJZD1lLGYuZ2V0TG9nc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2YuZ2V0KHQpfSksZi5nZXRMb2dzQ2FsbGJhY2tzPVtdLGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7cyhmLHQpfSksZi5jYWxsYmFja3MubGVuZ3RoPjAmJmMoZiksImZ1bmN0aW9uIj09dHlwZW9mIGkpcmV0dXJuIGYud2F0Y2goaSl9KSx0aGlzfTt1LnByb3RvdHlwZS53YXRjaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYWxsYmFja3MucHVzaCh0KSx0aGlzLmZpbHRlcklkJiYocyh0aGlzLHQpLGModGhpcykpLHRoaXN9LHUucHJvdG90eXBlLnN0b3BXYXRjaGluZz1mdW5jdGlvbih0KXtpZih0aGlzLnJlcXVlc3RNYW5hZ2VyLnN0b3BQb2xsaW5nKHRoaXMuZmlsdGVySWQpLHRoaXMuY2FsbGJhY2tzPVtdLCF0KXJldHVybiB0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkKTt0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkLHQpfSx1LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZighby5pc0Z1bmN0aW9uKHQpKXtpZihudWxsPT09dGhpcy5maWx0ZXJJZCl0aHJvdyBuZXcgRXJyb3IoIkZpbHRlciBJRCBFcnJvcjogZmlsdGVyKCkuZ2V0KCkgY2FuJ3QgYmUgY2hhaW5lZCBzeW5jaHJvbm91cywgcGxlYXNlIHByb3ZpZGUgYSBjYWxsYmFjayBmb3IgdGhlIGdldCgpIG1ldGhvZC4iKTtyZXR1cm4gdGhpcy5pbXBsZW1lbnRhdGlvbi5nZXRMb2dzKHRoaXMuZmlsdGVySWQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5mb3JtYXR0ZXI/ZS5mb3JtYXR0ZXIodCk6dH0pfXJldHVybiBudWxsPT09dGhpcy5maWx0ZXJJZD90aGlzLmdldExvZ3NDYWxsYmFja3MucHVzaCh0KTp0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCxmdW5jdGlvbihuLHIpe24/dChuKTp0KG51bGwsci5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuZm9ybWF0dGVyP2UuZm9ybWF0dGVyKHQpOnR9KSl9KSx0aGlzfSxlLmV4cG9ydHM9dX0seyIuLi91dGlscy91dGlscyI6MjAsIi4vZm9ybWF0dGVycyI6MzB9XSwzMDpbZnVuY3Rpb24odCxlLG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj10KCIuLi91dGlscy91dGlscyIpLG89dCgiLi4vdXRpbHMvY29uZmlnIiksaT10KCIuL2liYW4iKSxhPWZ1bmN0aW9uKHQpe3JldHVybiJsYXRlc3QiPT09dHx8InBlbmRpbmciPT09dHx8ImVhcmxpZXN0Ij09PXR9LHM9ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dClyZXR1cm4gYSh0KT90OnIudG9IZXgodCl9LGM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10LmJsb2NrTnVtYmVyJiYodC5ibG9ja051bWJlcj1yLnRvRGVjaW1hbCh0LmJsb2NrTnVtYmVyKSksbnVsbCE9PXQudHJhbnNhY3Rpb25JbmRleCYmKHQudHJhbnNhY3Rpb25JbmRleD1yLnRvRGVjaW1hbCh0LnRyYW5zYWN0aW9uSW5kZXgpKSx0Lm5vbmNlPXIudG9EZWNpbWFsKHQubm9uY2UpLHQuZ2FzPXIudG9EZWNpbWFsKHQuZ2FzKSx0Lmdhc1ByaWNlPXIudG9CaWdOdW1iZXIodC5nYXNQcmljZSksdC52YWx1ZT1yLnRvQmlnTnVtYmVyKHQudmFsdWUpLHR9LHU9ZnVuY3Rpb24odCl7cmV0dXJuIHQuYmxvY2tOdW1iZXImJih0LmJsb2NrTnVtYmVyPXIudG9EZWNpbWFsKHQuYmxvY2tOdW1iZXIpKSx0LnRyYW5zYWN0aW9uSW5kZXgmJih0LnRyYW5zYWN0aW9uSW5kZXg9ci50b0RlY2ltYWwodC50cmFuc2FjdGlvbkluZGV4KSksdC5sb2dJbmRleCYmKHQubG9nSW5kZXg9ci50b0RlY2ltYWwodC5sb2dJbmRleCkpLHR9LGY9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGkodCk7aWYoZS5pc1ZhbGlkKCkmJmUuaXNEaXJlY3QoKSlyZXR1cm4iMHgiK2UuYWRkcmVzcygpO2lmKHIuaXNTdHJpY3RBZGRyZXNzKHQpKXJldHVybiB0O2lmKHIuaXNBZGRyZXNzKHQpKXJldHVybiIweCIrdDt0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgYWRkcmVzcyIpfTtlLmV4cG9ydHM9e2lucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10P28uZGVmYXVsdEJsb2NrOnModCl9LGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXI6cyxpbnB1dENhbGxGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZnJvbT10LmZyb218fG8uZGVmYXVsdEFjY291bnQsdC5mcm9tJiYodC5mcm9tPWYodC5mcm9tKSksdC50byYmKHQudG89Zih0LnRvKSksWyJnYXNQcmljZSIsImdhcyIsInZhbHVlIiwibm9uY2UiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PXRbZV19KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV09ci5mcm9tRGVjaW1hbCh0W2VdKX0pLHR9LGlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZnJvbT10LmZyb218fG8uZGVmYXVsdEFjY291bnQsdC5mcm9tPWYodC5mcm9tKSx0LnRvJiYodC50bz1mKHQudG8pKSxbImdhc1ByaWNlIiwiZ2FzIiwidmFsdWUiLCJub25jZSJdLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09dFtlXX0pLmZvckVhY2goZnVuY3Rpb24oZSl7dFtlXT1yLmZyb21EZWNpbWFsKHRbZV0pfSksdH0saW5wdXRBZGRyZXNzRm9ybWF0dGVyOmYsaW5wdXRQb3N0Rm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR0bD1yLmZyb21EZWNpbWFsKHQudHRsKSx0LndvcmtUb1Byb3ZlPXIuZnJvbURlY2ltYWwodC53b3JrVG9Qcm92ZSksdC5wcmlvcml0eT1yLmZyb21EZWNpbWFsKHQucHJpb3JpdHkpLHIuaXNBcnJheSh0LnRvcGljcyl8fCh0LnRvcGljcz10LnRvcGljcz9bdC50b3BpY3NdOltdKSx0LnRvcGljcz10LnRvcGljcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10LmluZGV4T2YoIjB4Iik/dDpyLmZyb21VdGY4KHQpfSksdH0sb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiByLnRvQmlnTnVtYmVyKHQpfSxvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcjpjLG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXQuYmxvY2tOdW1iZXImJih0LmJsb2NrTnVtYmVyPXIudG9EZWNpbWFsKHQuYmxvY2tOdW1iZXIpKSxudWxsIT09dC50cmFuc2FjdGlvbkluZGV4JiYodC50cmFuc2FjdGlvbkluZGV4PXIudG9EZWNpbWFsKHQudHJhbnNhY3Rpb25JbmRleCkpLHQuY3VtdWxhdGl2ZUdhc1VzZWQ9ci50b0RlY2ltYWwodC5jdW11bGF0aXZlR2FzVXNlZCksdC5nYXNVc2VkPXIudG9EZWNpbWFsKHQuZ2FzVXNlZCksci5pc0FycmF5KHQubG9ncykmJih0LmxvZ3M9dC5sb2dzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdSh0KX0pKSx0fSxvdXRwdXRCbG9ja0Zvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5nYXNMaW1pdD1yLnRvRGVjaW1hbCh0Lmdhc0xpbWl0KSx0Lmdhc1VzZWQ9ci50b0RlY2ltYWwodC5nYXNVc2VkKSx0LnNpemU9ci50b0RlY2ltYWwodC5zaXplKSx0LnRpbWVzdGFtcD1yLnRvRGVjaW1hbCh0LnRpbWVzdGFtcCksbnVsbCE9PXQubnVtYmVyJiYodC5udW1iZXI9ci50b0RlY2ltYWwodC5udW1iZXIpKSx0LmRpZmZpY3VsdHk9ci50b0JpZ051bWJlcih0LmRpZmZpY3VsdHkpLHQudG90YWxEaWZmaWN1bHR5PXIudG9CaWdOdW1iZXIodC50b3RhbERpZmZpY3VsdHkpLHIuaXNBcnJheSh0LnRyYW5zYWN0aW9ucykmJnQudHJhbnNhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24odCl7aWYoIXIuaXNTdHJpbmcodCkpcmV0dXJuIGModCl9KSx0fSxvdXRwdXRMb2dGb3JtYXR0ZXI6dSxvdXRwdXRQb3N0Rm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0LmV4cGlyeT1yLnRvRGVjaW1hbCh0LmV4cGlyeSksdC5zZW50PXIudG9EZWNpbWFsKHQuc2VudCksdC50dGw9ci50b0RlY2ltYWwodC50dGwpLHQud29ya1Byb3ZlZD1yLnRvRGVjaW1hbCh0LndvcmtQcm92ZWQpLHQudG9waWNzfHwodC50b3BpY3M9W10pLHQudG9waWNzPXQudG9waWNzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gci50b0FzY2lpKHQpfSksdH0sb3V0cHV0U3luY2luZ0Zvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdD8odC5zdGFydGluZ0Jsb2NrPXIudG9EZWNpbWFsKHQuc3RhcnRpbmdCbG9jayksdC5jdXJyZW50QmxvY2s9ci50b0RlY2ltYWwodC5jdXJyZW50QmxvY2spLHQuaGlnaGVzdEJsb2NrPXIudG9EZWNpbWFsKHQuaGlnaGVzdEJsb2NrKSx0Lmtub3duU3RhdGVzJiYodC5rbm93blN0YXRlcz1yLnRvRGVjaW1hbCh0Lmtub3duU3RhdGVzKSx0LnB1bGxlZFN0YXRlcz1yLnRvRGVjaW1hbCh0LnB1bGxlZFN0YXRlcykpLHQpOnR9fX0seyIuLi91dGlscy9jb25maWciOjE4LCIuLi91dGlscy91dGlscyI6MjAsIi4vaWJhbiI6MzN9XSwzMTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3NvbGlkaXR5L2NvZGVyIiksbz10KCIuLi91dGlscy91dGlscyIpLGk9dCgiLi9lcnJvcnMiKSxhPXQoIi4vZm9ybWF0dGVycyIpLHM9dCgiLi4vdXRpbHMvc2hhMyIpLGM9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX2V0aD10LHRoaXMuX2lucHV0VHlwZXM9ZS5pbnB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGV9KSx0aGlzLl9vdXRwdXRUeXBlcz1lLm91dHB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGV9KSx0aGlzLl9jb25zdGFudD1lLmNvbnN0YW50LHRoaXMuX3BheWFibGU9ZS5wYXlhYmxlLHRoaXMuX25hbWU9by50cmFuc2Zvcm1Ub0Z1bGxOYW1lKGUpLHRoaXMuX2FkZHJlc3M9bn07Yy5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrPWZ1bmN0aW9uKHQpe2lmKG8uaXNGdW5jdGlvbih0W3QubGVuZ3RoLTFdKSlyZXR1cm4gdC5wb3AoKX0sYy5wcm90b3R5cGUuZXh0cmFjdERlZmF1bHRCbG9jaz1mdW5jdGlvbih0KXtpZih0Lmxlbmd0aD50aGlzLl9pbnB1dFR5cGVzLmxlbmd0aCYmIW8uaXNPYmplY3QodFt0Lmxlbmd0aC0xXSkpcmV0dXJuIGEuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIodC5wb3AoKSl9LGMucHJvdG90eXBlLnZhbGlkYXRlQXJncz1mdW5jdGlvbih0KXtpZih0LmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hKCEwPT09by5pc09iamVjdCh0KSYmITE9PT1vLmlzQXJyYXkodCkmJiExPT09by5pc0JpZ051bWJlcih0KSl9KS5sZW5ndGghPT10aGlzLl9pbnB1dFR5cGVzLmxlbmd0aCl0aHJvdyBpLkludmFsaWROdW1iZXJPZlNvbGlkaXR5QXJncygpfSxjLnByb3RvdHlwZS50b1BheWxvYWQ9ZnVuY3Rpb24odCl7dmFyIGU9e307cmV0dXJuIHQubGVuZ3RoPnRoaXMuX2lucHV0VHlwZXMubGVuZ3RoJiZvLmlzT2JqZWN0KHRbdC5sZW5ndGgtMV0pJiYoZT10W3QubGVuZ3RoLTFdKSx0aGlzLnZhbGlkYXRlQXJncyh0KSxlLnRvPXRoaXMuX2FkZHJlc3MsZS5kYXRhPSIweCIrdGhpcy5zaWduYXR1cmUoKStyLmVuY29kZVBhcmFtcyh0aGlzLl9pbnB1dFR5cGVzLHQpLGV9LGMucHJvdG90eXBlLnNpZ25hdHVyZT1mdW5jdGlvbigpe3JldHVybiBzKHRoaXMuX25hbWUpLnNsaWNlKDAsOCl9LGMucHJvdG90eXBlLnVucGFja091dHB1dD1mdW5jdGlvbih0KXtpZih0KXt0PXQubGVuZ3RoPj0yP3Quc2xpY2UoMik6dDt2YXIgZT1yLmRlY29kZVBhcmFtcyh0aGlzLl9vdXRwdXRUeXBlcyx0KTtyZXR1cm4gMT09PWUubGVuZ3RoP2VbMF06ZX19LGMucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pLGU9dGhpcy5leHRyYWN0Q2FsbGJhY2sodCksbj10aGlzLmV4dHJhY3REZWZhdWx0QmxvY2sodCkscj10aGlzLnRvUGF5bG9hZCh0KTtpZighZSl7dmFyIG89dGhpcy5fZXRoLmNhbGwocixuKTtyZXR1cm4gdGhpcy51bnBhY2tPdXRwdXQobyl9dmFyIGk9dGhpczt0aGlzLl9ldGguY2FsbChyLG4sZnVuY3Rpb24odCxuKXtpZih0KXJldHVybiBlKHQsbnVsbCk7dmFyIHI9bnVsbDt0cnl7cj1pLnVucGFja091dHB1dChuKX1jYXRjaChlKXt0PWV9ZSh0LHIpfSl9LGMucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbj1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSksZT10aGlzLmV4dHJhY3RDYWxsYmFjayh0KSxuPXRoaXMudG9QYXlsb2FkKHQpO2lmKG4udmFsdWU+MCYmIXRoaXMuX3BheWFibGUpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmdW5jdGlvbiIpO2lmKCFlKXJldHVybiB0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKG4pO3RoaXMuX2V0aC5zZW5kVHJhbnNhY3Rpb24obixlKX0sYy5wcm90b3R5cGUuZXN0aW1hdGVHYXM9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGU9dGhpcy5leHRyYWN0Q2FsbGJhY2sodCksbj10aGlzLnRvUGF5bG9hZCh0KTtpZighZSlyZXR1cm4gdGhpcy5fZXRoLmVzdGltYXRlR2FzKG4pO3RoaXMuX2V0aC5lc3RpbWF0ZUdhcyhuLGUpfSxjLnByb3RvdHlwZS5nZXREYXRhPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtyZXR1cm4gdGhpcy50b1BheWxvYWQodCkuZGF0YX0sYy5wcm90b3R5cGUuZGlzcGxheU5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gby5leHRyYWN0RGlzcGxheU5hbWUodGhpcy5fbmFtZSl9LGMucHJvdG90eXBlLnR5cGVOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG8uZXh0cmFjdFR5cGVOYW1lKHRoaXMuX25hbWUpfSxjLnByb3RvdHlwZS5yZXF1ZXN0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxlPXRoaXMuZXh0cmFjdENhbGxiYWNrKHQpLG49dGhpcy50b1BheWxvYWQodCkscj10aGlzLnVucGFja091dHB1dC5iaW5kKHRoaXMpO3JldHVybnttZXRob2Q6dGhpcy5fY29uc3RhbnQ/ImV0aF9jYWxsIjoiZXRoX3NlbmRUcmFuc2FjdGlvbiIsY2FsbGJhY2s6ZSxwYXJhbXM6W25dLGZvcm1hdDpyfX0sYy5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLl9jb25zdGFudD90aGlzLnNlbmRUcmFuc2FjdGlvbi5hcHBseSh0aGlzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpOnRoaXMuY2FsbC5hcHBseSh0aGlzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpfSxjLnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZXhlY3V0ZS5iaW5kKHRoaXMpO2UucmVxdWVzdD10aGlzLnJlcXVlc3QuYmluZCh0aGlzKSxlLmNhbGw9dGhpcy5jYWxsLmJpbmQodGhpcyksZS5zZW5kVHJhbnNhY3Rpb249dGhpcy5zZW5kVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxlLmVzdGltYXRlR2FzPXRoaXMuZXN0aW1hdGVHYXMuYmluZCh0aGlzKSxlLmdldERhdGE9dGhpcy5nZXREYXRhLmJpbmQodGhpcyk7dmFyIG49dGhpcy5kaXNwbGF5TmFtZSgpO3Rbbl18fCh0W25dPWUpLHRbbl1bdGhpcy50eXBlTmFtZSgpXT1lfSxlLmV4cG9ydHM9Y30seyIuLi9zb2xpZGl0eS9jb2RlciI6NywiLi4vdXRpbHMvc2hhMyI6MTksIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9lcnJvcnMiOjI2LCIuL2Zvcm1hdHRlcnMiOjMwfV0sMzI6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Vycm9ycyIpOyJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuWE1MSHR0cFJlcXVlc3Q/WE1MSHR0cFJlcXVlc3Q9d2luZG93LlhNTEh0dHBSZXF1ZXN0OlhNTEh0dHBSZXF1ZXN0PXQoInhtbGh0dHByZXF1ZXN0IikuWE1MSHR0cFJlcXVlc3Q7dmFyIG89dCgieGhyMiIpLGk9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5ob3N0PXR8fCJodHRwOi8vbG9jYWxob3N0Ojg1NDUiLHRoaXMudGltZW91dD1lfHwwLHRoaXMudXNlcj1uLHRoaXMucGFzc3dvcmQ9cn07aS5wcm90b3R5cGUucHJlcGFyZVJlcXVlc3Q9ZnVuY3Rpb24odCl7dmFyIGU7aWYodD8oZT1uZXcgbykudGltZW91dD10aGlzLnRpbWVvdXQ6ZT1uZXcgWE1MSHR0cFJlcXVlc3QsZS5vcGVuKCJQT1NUIix0aGlzLmhvc3QsdCksdGhpcy51c2VyJiZ0aGlzLnBhc3N3b3JkKXt2YXIgbj0iQmFzaWMgIituZXcgQnVmZmVyKHRoaXMudXNlcisiOiIrdGhpcy5wYXNzd29yZCkudG9TdHJpbmcoImJhc2U2NCIpO2Uuc2V0UmVxdWVzdEhlYWRlcigiQXV0aG9yaXphdGlvbiIsbil9cmV0dXJuIGUuc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1UeXBlIiwiYXBwbGljYXRpb24vanNvbiIpLGV9LGkucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcmVwYXJlUmVxdWVzdCghMSk7dHJ5e2Uuc2VuZChKU09OLnN0cmluZ2lmeSh0KSl9Y2F0Y2godCl7dGhyb3cgci5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpfXZhciBuPWUucmVzcG9uc2VUZXh0O3RyeXtuPUpTT04ucGFyc2Uobil9Y2F0Y2godCl7dGhyb3cgci5JbnZhbGlkUmVzcG9uc2UoZS5yZXNwb25zZVRleHQpfXJldHVybiBufSxpLnByb3RvdHlwZS5zZW5kQXN5bmM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnByZXBhcmVSZXF1ZXN0KCEwKTtuLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKDQ9PT1uLnJlYWR5U3RhdGUmJjEhPT1uLnRpbWVvdXQpe3ZhciB0PW4ucmVzcG9uc2VUZXh0LG89bnVsbDt0cnl7dD1KU09OLnBhcnNlKHQpfWNhdGNoKHQpe289ci5JbnZhbGlkUmVzcG9uc2Uobi5yZXNwb25zZVRleHQpfWUobyx0KX19LG4ub250aW1lb3V0PWZ1bmN0aW9uKCl7ZShyLkNvbm5lY3Rpb25UaW1lb3V0KHRoaXMudGltZW91dCkpfTt0cnl7bi5zZW5kKEpTT04uc3RyaW5naWZ5KHQpKX1jYXRjaCh0KXtlKHIuSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KSl9fSxpLnByb3RvdHlwZS5pc0Nvbm5lY3RlZD1mdW5jdGlvbigpe3RyeXtyZXR1cm4gdGhpcy5zZW5kKHtpZDo5OTk5OTk5OTk5LGpzb25ycGM6IjIuMCIsbWV0aG9kOiJuZXRfbGlzdGVuaW5nIixwYXJhbXM6W119KSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19LGUuZXhwb3J0cz1pfSx7Ii4vZXJyb3JzIjoyNix4aHIyOjg1LHhtbGh0dHByZXF1ZXN0OjE3fV0sMzM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCJiaWdudW1iZXIuanMiKSxvPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQ7bi5sZW5ndGg8MiplOyluPSIwIituO3JldHVybiBufSxpPWZ1bmN0aW9uKHQpe3ZhciBlPSJBIi5jaGFyQ29kZUF0KDApLG49IloiLmNoYXJDb2RlQXQoMCk7cmV0dXJuIHQ9dC50b1VwcGVyQ2FzZSgpLCh0PXQuc3Vic3RyKDQpK3Quc3Vic3RyKDAsNCkpLnNwbGl0KCIiKS5tYXAoZnVuY3Rpb24odCl7dmFyIHI9dC5jaGFyQ29kZUF0KDApO3JldHVybiByPj1lJiZyPD1uP3ItZSsxMDp0fSkuam9pbigiIil9LGE9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49dDtuLmxlbmd0aD4yOyllPW4uc2xpY2UoMCw5KSxuPXBhcnNlSW50KGUsMTApJTk3K24uc2xpY2UoZS5sZW5ndGgpO3JldHVybiBwYXJzZUludChuLDEwKSU5N30scz1mdW5jdGlvbih0KXt0aGlzLl9pYmFuPXR9O3MuZnJvbUFkZHJlc3M9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHIodCwxNikudG9TdHJpbmcoMzYpLG49byhlLDE1KTtyZXR1cm4gcy5mcm9tQmJhbihuLnRvVXBwZXJDYXNlKCkpfSxzLmZyb21CYmFuPWZ1bmN0aW9uKHQpe3ZhciBlPSgiMCIrKDk4LWEoaSgiWEUwMCIrdCkpKSkuc2xpY2UoLTIpO3JldHVybiBuZXcgcygiWEUiK2UrdCl9LHMuY3JlYXRlSW5kaXJlY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHMuZnJvbUJiYW4oIkVUSCIrdC5pbnN0aXR1dGlvbit0LmlkZW50aWZpZXIpfSxzLmlzVmFsaWQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBzKHQpLmlzVmFsaWQoKX0scy5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybi9eWEVbMC05XXsyfShFVEhbMC05QS1aXXsxM318WzAtOUEtWl17MzAsMzF9KSQvLnRlc3QodGhpcy5faWJhbikmJjE9PT1hKGkodGhpcy5faWJhbikpfSxzLnByb3RvdHlwZS5pc0RpcmVjdD1mdW5jdGlvbigpe3JldHVybiAzND09PXRoaXMuX2liYW4ubGVuZ3RofHwzNT09PXRoaXMuX2liYW4ubGVuZ3RofSxzLnByb3RvdHlwZS5pc0luZGlyZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIDIwPT09dGhpcy5faWJhbi5sZW5ndGh9LHMucHJvdG90eXBlLmNoZWNrc3VtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2liYW4uc3Vic3RyKDIsMil9LHMucHJvdG90eXBlLmluc3RpdHV0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpP3RoaXMuX2liYW4uc3Vic3RyKDcsNCk6IiJ9LHMucHJvdG90eXBlLmNsaWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzSW5kaXJlY3QoKT90aGlzLl9pYmFuLnN1YnN0cigxMSk6IiJ9LHMucHJvdG90eXBlLmFkZHJlc3M9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRGlyZWN0KCkpe3ZhciB0PXRoaXMuX2liYW4uc3Vic3RyKDQpLGU9bmV3IHIodCwzNik7cmV0dXJuIG8oZS50b1N0cmluZygxNiksMjApfXJldHVybiIifSxzLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pYmFufSxlLmV4cG9ydHM9c30seyJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMifV0sMzQ6W2Z1bmN0aW9uKHQsZSxuKXsidXNlIHN0cmljdCI7dmFyIHI9dCgiLi4vdXRpbHMvdXRpbHMiKSxvPXQoIi4vZXJyb3JzIiksaT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dGhpcy5yZXNwb25zZUNhbGxiYWNrcz17fSx0aGlzLnBhdGg9dCx0aGlzLmNvbm5lY3Rpb249ZS5jb25uZWN0KHtwYXRoOnRoaXMucGF0aH0pLHRoaXMuY29ubmVjdGlvbi5vbigiZXJyb3IiLGZ1bmN0aW9uKHQpe2NvbnNvbGUuZXJyb3IoIklQQyBDb25uZWN0aW9uIEVycm9yIix0KSxuLl90aW1lb3V0KCl9KSx0aGlzLmNvbm5lY3Rpb24ub24oImVuZCIsZnVuY3Rpb24oKXtuLl90aW1lb3V0KCl9KSx0aGlzLmNvbm5lY3Rpb24ub24oImRhdGEiLGZ1bmN0aW9uKHQpe24uX3BhcnNlUmVzcG9uc2UodC50b1N0cmluZygpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPW51bGw7ci5pc0FycmF5KHQpP3QuZm9yRWFjaChmdW5jdGlvbih0KXtuLnJlc3BvbnNlQ2FsbGJhY2tzW3QuaWRdJiYoZT10LmlkKX0pOmU9dC5pZCxuLnJlc3BvbnNlQ2FsbGJhY2tzW2VdJiYobi5yZXNwb25zZUNhbGxiYWNrc1tlXShudWxsLHQpLGRlbGV0ZSBuLnJlc3BvbnNlQ2FsbGJhY2tzW2VdKX0pfSl9O2kucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1bXTtyZXR1cm4gdC5yZXBsYWNlKC9cfVtcblxyXT9cey9nLCJ9fC0tfHsiKS5yZXBsYWNlKC9cfVxdW1xuXHJdP1xbXHsvZywifV18LS18W3siKS5yZXBsYWNlKC9cfVtcblxyXT9cW1x7L2csIn18LS18W3siKS5yZXBsYWNlKC9cfVxdW1xuXHJdP1x7L2csIn1dfC0tfHsiKS5zcGxpdCgifC0tfCIpLmZvckVhY2goZnVuY3Rpb24odCl7ZS5sYXN0Q2h1bmsmJih0PWUubGFzdENodW5rK3QpO3ZhciByPW51bGw7dHJ5e3I9SlNPTi5wYXJzZSh0KX1jYXRjaChuKXtyZXR1cm4gZS5sYXN0Q2h1bms9dCxjbGVhclRpbWVvdXQoZS5sYXN0Q2h1bmtUaW1lb3V0KSx2b2lkKGUubGFzdENodW5rVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZS5fdGltZW91dCgpLG8uSW52YWxpZFJlc3BvbnNlKHQpfSwxNWUzKSl9Y2xlYXJUaW1lb3V0KGUubGFzdENodW5rVGltZW91dCksZS5sYXN0Q2h1bms9bnVsbCxyJiZuLnB1c2gocil9KSxufSxpLnByb3RvdHlwZS5fYWRkUmVzcG9uc2VDYWxsYmFjaz1mdW5jdGlvbih0LGUpe3ZhciBuPXQuaWR8fHRbMF0uaWQscj10Lm1ldGhvZHx8dFswXS5tZXRob2Q7dGhpcy5yZXNwb25zZUNhbGxiYWNrc1tuXT1lLHRoaXMucmVzcG9uc2VDYWxsYmFja3Nbbl0ubWV0aG9kPXJ9LGkucHJvdG90eXBlLl90aW1lb3V0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMucmVzcG9uc2VDYWxsYmFja3MpdGhpcy5yZXNwb25zZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eSh0KSYmKHRoaXMucmVzcG9uc2VDYWxsYmFja3NbdF0oby5JbnZhbGlkQ29ubmVjdGlvbigib24gSVBDIikpLGRlbGV0ZSB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW3RdKX0saS5wcm90b3R5cGUuaXNDb25uZWN0ZWQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiB0LmNvbm5lY3Rpb24ud3JpdGFibGV8fHQuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOnQucGF0aH0pLCEhdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlfSxpLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHQpe2lmKHRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMpe3ZhciBlO3RoaXMuY29ubmVjdGlvbi53cml0YWJsZXx8dGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6dGhpcy5wYXRofSk7dmFyIG49dGhpcy5jb25uZWN0aW9uLndyaXRlU3luYyhKU09OLnN0cmluZ2lmeSh0KSk7dHJ5e2U9SlNPTi5wYXJzZShuKX1jYXRjaCh0KXt0aHJvdyBvLkludmFsaWRSZXNwb25zZShuKX1yZXR1cm4gZX10aHJvdyBuZXcgRXJyb3IoJ1lvdSB0cmllZCB0byBzZW5kICInK3QubWV0aG9kKyciIHN5bmNocm9ub3VzbHkuIFN5bmNocm9ub3VzIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUEMgcHJvdmlkZXIuJyl9LGkucHJvdG90eXBlLnNlbmRBc3luYz1mdW5jdGlvbih0LGUpe3RoaXMuY29ubmVjdGlvbi53cml0YWJsZXx8dGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6dGhpcy5wYXRofSksdGhpcy5jb25uZWN0aW9uLndyaXRlKEpTT04uc3RyaW5naWZ5KHQpKSx0aGlzLl9hZGRSZXNwb25zZUNhbGxiYWNrKHQsZSl9LGUuZXhwb3J0cz1pfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMCwiLi9lcnJvcnMiOjI2fV0sMzU6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj17bWVzc2FnZUlkOjB9O3IudG9QYXlsb2FkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR8fGNvbnNvbGUuZXJyb3IoImpzb25ycGMgbWV0aG9kIHNob3VsZCBiZSBzcGVjaWZpZWQhIiksci5tZXNzYWdlSWQrKyx7anNvbnJwYzoiMi4wIixpZDpyLm1lc3NhZ2VJZCxtZXRob2Q6dCxwYXJhbXM6ZXx8W119fSxyLmlzVmFsaWRSZXNwb25zZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3JldHVybiEhdCYmIXQuZXJyb3ImJiIyLjAiPT09dC5qc29ucnBjJiYibnVtYmVyIj09dHlwZW9mIHQuaWQmJnZvaWQgMCE9PXQucmVzdWx0fXJldHVybiBBcnJheS5pc0FycmF5KHQpP3QuZXZlcnkoZSk6ZSh0KX0sci50b0JhdGNoUGF5bG9hZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHIudG9QYXlsb2FkKHQubWV0aG9kLHQucGFyYW1zKX0pfSxlLmV4cG9ydHM9cn0se31dLDM2OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vdXRpbHMvdXRpbHMiKSxvPXQoIi4vZXJyb3JzIiksaT1mdW5jdGlvbih0KXt0aGlzLm5hbWU9dC5uYW1lLHRoaXMuY2FsbD10LmNhbGwsdGhpcy5wYXJhbXM9dC5wYXJhbXN8fDAsdGhpcy5pbnB1dEZvcm1hdHRlcj10LmlucHV0Rm9ybWF0dGVyLHRoaXMub3V0cHV0Rm9ybWF0dGVyPXQub3V0cHV0Rm9ybWF0dGVyLHRoaXMucmVxdWVzdE1hbmFnZXI9bnVsbH07aS5wcm90b3R5cGUuc2V0UmVxdWVzdE1hbmFnZXI9ZnVuY3Rpb24odCl7dGhpcy5yZXF1ZXN0TWFuYWdlcj10fSxpLnByb3RvdHlwZS5nZXRDYWxsPWZ1bmN0aW9uKHQpe3JldHVybiByLmlzRnVuY3Rpb24odGhpcy5jYWxsKT90aGlzLmNhbGwodCk6dGhpcy5jYWxsfSxpLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2s9ZnVuY3Rpb24odCl7aWYoci5pc0Z1bmN0aW9uKHRbdC5sZW5ndGgtMV0pKXJldHVybiB0LnBvcCgpfSxpLnByb3RvdHlwZS52YWxpZGF0ZUFyZ3M9ZnVuY3Rpb24odCl7aWYodC5sZW5ndGghPT10aGlzLnBhcmFtcyl0aHJvdyBvLkludmFsaWROdW1iZXJPZlJQQ1BhcmFtcygpfSxpLnByb3RvdHlwZS5mb3JtYXRJbnB1dD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pbnB1dEZvcm1hdHRlcj90aGlzLmlucHV0Rm9ybWF0dGVyLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBlP2UodFtuXSk6dFtuXX0pOnR9LGkucHJvdG90eXBlLmZvcm1hdE91dHB1dD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vdXRwdXRGb3JtYXR0ZXImJnQ/dGhpcy5vdXRwdXRGb3JtYXR0ZXIodCk6dH0saS5wcm90b3R5cGUudG9QYXlsb2FkPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Q2FsbCh0KSxuPXRoaXMuZXh0cmFjdENhbGxiYWNrKHQpLHI9dGhpcy5mb3JtYXRJbnB1dCh0KTtyZXR1cm4gdGhpcy52YWxpZGF0ZUFyZ3Mocikse21ldGhvZDplLHBhcmFtczpyLGNhbGxiYWNrOm59fSxpLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmJ1aWxkQ2FsbCgpO2UuY2FsbD10aGlzLmNhbGw7dmFyIG49dGhpcy5uYW1lLnNwbGl0KCIuIik7bi5sZW5ndGg+MT8odFtuWzBdXT10W25bMF1dfHx7fSx0W25bMF1dW25bMV1dPWUpOnRbblswXV09ZX0saS5wcm90b3R5cGUuYnVpbGRDYWxsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKCl7dmFyIGU9dC50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7cmV0dXJuIGUuY2FsbGJhY2s/dC5yZXF1ZXN0TWFuYWdlci5zZW5kQXN5bmMoZSxmdW5jdGlvbihuLHIpe2UuY2FsbGJhY2sobix0LmZvcm1hdE91dHB1dChyKSl9KTp0LmZvcm1hdE91dHB1dCh0LnJlcXVlc3RNYW5hZ2VyLnNlbmQoZSkpfTtyZXR1cm4gZS5yZXF1ZXN0PXRoaXMucmVxdWVzdC5iaW5kKHRoaXMpLGV9LGkucHJvdG90eXBlLnJlcXVlc3Q9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtyZXR1cm4gdC5mb3JtYXQ9dGhpcy5mb3JtYXRPdXRwdXQuYmluZCh0aGlzKSx0fSxlLmV4cG9ydHM9aX0seyIuLi91dGlscy91dGlscyI6MjAsIi4vZXJyb3JzIjoyNn1dLDM3OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vbWV0aG9kIiksbz1mdW5jdGlvbigpe3JldHVybltuZXcgcih7bmFtZToicHV0U3RyaW5nIixjYWxsOiJkYl9wdXRTdHJpbmciLHBhcmFtczozfSksbmV3IHIoe25hbWU6ImdldFN0cmluZyIsY2FsbDoiZGJfZ2V0U3RyaW5nIixwYXJhbXM6Mn0pLG5ldyByKHtuYW1lOiJwdXRIZXgiLGNhbGw6ImRiX3B1dEhleCIscGFyYW1zOjN9KSxuZXcgcih7bmFtZToiZ2V0SGV4IixjYWxsOiJkYl9nZXRIZXgiLHBhcmFtczoyfSldfTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpcztvKCkuZm9yRWFjaChmdW5jdGlvbihuKXtuLmF0dGFjaFRvT2JqZWN0KGUpLG4uc2V0UmVxdWVzdE1hbmFnZXIodC5fcmVxdWVzdE1hbmFnZXIpfSl9fSx7Ii4uL21ldGhvZCI6MzZ9XSwzODpbZnVuY3Rpb24odCxlLG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7dygpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pLHgoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KSx0aGlzLmliYW49ZCx0aGlzLnNlbmRJQkFOVHJhbnNhY3Rpb249bS5iaW5kKG51bGwsdGhpcyl9dmFyIG89dCgiLi4vZm9ybWF0dGVycyIpLGk9dCgiLi4vLi4vdXRpbHMvdXRpbHMiKSxhPXQoIi4uL21ldGhvZCIpLHM9dCgiLi4vcHJvcGVydHkiKSxjPXQoIi4uLy4uL3V0aWxzL2NvbmZpZyIpLHU9dCgiLi4vY29udHJhY3QiKSxmPXQoIi4vd2F0Y2hlcyIpLGw9dCgiLi4vZmlsdGVyIikscD10KCIuLi9zeW5jaW5nIiksaD10KCIuLi9uYW1lcmVnIiksZD10KCIuLi9pYmFuIiksbT10KCIuLi90cmFuc2ZlciIpLHk9ZnVuY3Rpb24odCl7cmV0dXJuIGkuaXNTdHJpbmcodFswXSkmJjA9PT10WzBdLmluZGV4T2YoIjB4Iik/ImV0aF9nZXRCbG9ja0J5SGFzaCI6ImV0aF9nZXRCbG9ja0J5TnVtYmVyIn0sZz1mdW5jdGlvbih0KXtyZXR1cm4gaS5pc1N0cmluZyh0WzBdKSYmMD09PXRbMF0uaW5kZXhPZigiMHgiKT8iZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCI6ImV0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCJ9LHY9ZnVuY3Rpb24odCl7cmV0dXJuIGkuaXNTdHJpbmcodFswXSkmJjA9PT10WzBdLmluZGV4T2YoIjB4Iik/ImV0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgiOiJldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgifSxiPWZ1bmN0aW9uKHQpe3JldHVybiBpLmlzU3RyaW5nKHRbMF0pJiYwPT09dFswXS5pbmRleE9mKCIweCIpPyJldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoIjoiZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyIn0sXz1mdW5jdGlvbih0KXtyZXR1cm4gaS5pc1N0cmluZyh0WzBdKSYmMD09PXRbMF0uaW5kZXhPZigiMHgiKT8iZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCI6ImV0aF9nZXRVbmNsZUNvdW50QnlCbG9ja051bWJlciJ9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSwiZGVmYXVsdEJsb2NrIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdEJsb2NrfSxzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIGMuZGVmYXVsdEJsb2NrPXQsdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsImRlZmF1bHRBY2NvdW50Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdEFjY291bnR9LHNldDpmdW5jdGlvbih0KXtyZXR1cm4gYy5kZWZhdWx0QWNjb3VudD10LHR9fSk7dmFyIHc9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgYSh7bmFtZToiZ2V0QmFsYW5jZSIsY2FsbDoiZXRoX2dldEJhbGFuY2UiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QWRkcmVzc0Zvcm1hdHRlcixvLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXJ9KSxlPW5ldyBhKHtuYW1lOiJnZXRTdG9yYWdlQXQiLGNhbGw6ImV0aF9nZXRTdG9yYWdlQXQiLHBhcmFtczozLGlucHV0Rm9ybWF0dGVyOltudWxsLGkudG9IZXgsby5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl19KSxuPW5ldyBhKHtuYW1lOiJnZXRDb2RlIixjYWxsOiJldGhfZ2V0Q29kZSIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG8uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdfSkscj1uZXcgYSh7bmFtZToiZ2V0QmxvY2siLGNhbGw6eSxwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLGZ1bmN0aW9uKHQpe3JldHVybiEhdH1dLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dEJsb2NrRm9ybWF0dGVyfSkscz1uZXcgYSh7bmFtZToiZ2V0VW5jbGUiLGNhbGw6dixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLGkudG9IZXhdLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dEJsb2NrRm9ybWF0dGVyfSksYz1uZXcgYSh7bmFtZToiZ2V0Q29tcGlsZXJzIixjYWxsOiJldGhfZ2V0Q29tcGlsZXJzIixwYXJhbXM6MH0pLHU9bmV3IGEoe25hbWU6ImdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCIsY2FsbDpiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLG91dHB1dEZvcm1hdHRlcjppLnRvRGVjaW1hbH0pLGY9bmV3IGEoe25hbWU6ImdldEJsb2NrVW5jbGVDb3VudCIsY2FsbDpfLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLG91dHB1dEZvcm1hdHRlcjppLnRvRGVjaW1hbH0pLGw9bmV3IGEoe25hbWU6ImdldFRyYW5zYWN0aW9uIixjYWxsOiJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2giLHBhcmFtczoxLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyfSkscD1uZXcgYSh7bmFtZToiZ2V0VHJhbnNhY3Rpb25Gcm9tQmxvY2siLGNhbGw6ZyxwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLGkudG9IZXhdLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyfSksaD1uZXcgYSh7bmFtZToiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IixjYWxsOiJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IixwYXJhbXM6MSxvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJ9KSxkPW5ldyBhKHtuYW1lOiJnZXRUcmFuc2FjdGlvbkNvdW50IixjYWxsOiJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W251bGwsby5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl0sb3V0cHV0Rm9ybWF0dGVyOmkudG9EZWNpbWFsfSksbT1uZXcgYSh7bmFtZToic2VuZFJhd1RyYW5zYWN0aW9uIixjYWxsOiJldGhfc2VuZFJhd1RyYW5zYWN0aW9uIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSx3PW5ldyBhKHtuYW1lOiJzZW5kVHJhbnNhY3Rpb24iLGNhbGw6ImV0aF9zZW5kVHJhbnNhY3Rpb24iLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdfSkseD1uZXcgYSh7bmFtZToic2lnblRyYW5zYWN0aW9uIixjYWxsOiJldGhfc2lnblRyYW5zYWN0aW9uIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbby5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXX0pLGs9bmV3IGEoe25hbWU6InNpZ24iLGNhbGw6ImV0aF9zaWduIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsbnVsbF19KTtyZXR1cm5bdCxlLG4scixzLGMsdSxmLGwscCxoLGQsbmV3IGEoe25hbWU6ImNhbGwiLGNhbGw6ImV0aF9jYWxsIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbby5pbnB1dENhbGxGb3JtYXR0ZXIsby5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl19KSxuZXcgYSh7bmFtZToiZXN0aW1hdGVHYXMiLGNhbGw6ImV0aF9lc3RpbWF0ZUdhcyIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRDYWxsRm9ybWF0dGVyXSxvdXRwdXRGb3JtYXR0ZXI6aS50b0RlY2ltYWx9KSxtLHgsdyxrLG5ldyBhKHtuYW1lOiJjb21waWxlLnNvbGlkaXR5IixjYWxsOiJldGhfY29tcGlsZVNvbGlkaXR5IixwYXJhbXM6MX0pLG5ldyBhKHtuYW1lOiJjb21waWxlLmxsbCIsY2FsbDoiZXRoX2NvbXBpbGVMTEwiLHBhcmFtczoxfSksbmV3IGEoe25hbWU6ImNvbXBpbGUuc2VycGVudCIsY2FsbDoiZXRoX2NvbXBpbGVTZXJwZW50IixwYXJhbXM6MX0pLG5ldyBhKHtuYW1lOiJzdWJtaXRXb3JrIixjYWxsOiJldGhfc3VibWl0V29yayIscGFyYW1zOjN9KSxuZXcgYSh7bmFtZToiZ2V0V29yayIsY2FsbDoiZXRoX2dldFdvcmsiLHBhcmFtczowfSldfSx4PWZ1bmN0aW9uKCl7cmV0dXJuW25ldyBzKHtuYW1lOiJjb2luYmFzZSIsZ2V0dGVyOiJldGhfY29pbmJhc2UifSksbmV3IHMoe25hbWU6Im1pbmluZyIsZ2V0dGVyOiJldGhfbWluaW5nIn0pLG5ldyBzKHtuYW1lOiJoYXNocmF0ZSIsZ2V0dGVyOiJldGhfaGFzaHJhdGUiLG91dHB1dEZvcm1hdHRlcjppLnRvRGVjaW1hbH0pLG5ldyBzKHtuYW1lOiJzeW5jaW5nIixnZXR0ZXI6ImV0aF9zeW5jaW5nIixvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyfSksbmV3IHMoe25hbWU6Imdhc1ByaWNlIixnZXR0ZXI6ImV0aF9nYXNQcmljZSIsb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyfSksbmV3IHMoe25hbWU6ImFjY291bnRzIixnZXR0ZXI6ImV0aF9hY2NvdW50cyJ9KSxuZXcgcyh7bmFtZToiYmxvY2tOdW1iZXIiLGdldHRlcjoiZXRoX2Jsb2NrTnVtYmVyIixvdXRwdXRGb3JtYXR0ZXI6aS50b0RlY2ltYWx9KSxuZXcgcyh7bmFtZToicHJvdG9jb2xWZXJzaW9uIixnZXR0ZXI6ImV0aF9wcm90b2NvbFZlcnNpb24ifSldfTtyLnByb3RvdHlwZS5jb250cmFjdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHUodGhpcyx0KX0sci5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbmV3IGwodCwiZXRoIix0aGlzLl9yZXF1ZXN0TWFuYWdlcixmLmV0aCgpLG8ub3V0cHV0TG9nRm9ybWF0dGVyLGUsbil9LHIucHJvdG90eXBlLm5hbWVyZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250cmFjdChoLmdsb2JhbC5hYmkpLmF0KGguZ2xvYmFsLmFkZHJlc3MpfSxyLnByb3RvdHlwZS5pY2FwTmFtZXJlZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRyYWN0KGguaWNhcC5hYmkpLmF0KGguaWNhcC5hZGRyZXNzKX0sci5wcm90b3R5cGUuaXNTeW5jaW5nPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgcCh0aGlzLl9yZXF1ZXN0TWFuYWdlcix0KX0sZS5leHBvcnRzPXJ9LHsiLi4vLi4vdXRpbHMvY29uZmlnIjoxOCwiLi4vLi4vdXRpbHMvdXRpbHMiOjIwLCIuLi9jb250cmFjdCI6MjUsIi4uL2ZpbHRlciI6MjksIi4uL2Zvcm1hdHRlcnMiOjMwLCIuLi9pYmFuIjozMywiLi4vbWV0aG9kIjozNiwiLi4vbmFtZXJlZyI6NDQsIi4uL3Byb3BlcnR5Ijo0NSwiLi4vc3luY2luZyI6NDgsIi4uL3RyYW5zZmVyIjo0OSwiLi93YXRjaGVzIjo0M31dLDM5OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vLi4vdXRpbHMvdXRpbHMiKSxvPXQoIi4uL3Byb3BlcnR5IiksaT1mdW5jdGlvbigpe3JldHVybltuZXcgbyh7bmFtZToibGlzdGVuaW5nIixnZXR0ZXI6Im5ldF9saXN0ZW5pbmcifSksbmV3IG8oe25hbWU6InBlZXJDb3VudCIsZ2V0dGVyOiJuZXRfcGVlckNvdW50IixvdXRwdXRGb3JtYXR0ZXI6ci50b0RlY2ltYWx9KV19O2UuZXhwb3J0cz1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10Ll9yZXF1ZXN0TWFuYWdlcjt2YXIgZT10aGlzO2koKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uYXR0YWNoVG9PYmplY3QoZSksbi5zZXRSZXF1ZXN0TWFuYWdlcih0Ll9yZXF1ZXN0TWFuYWdlcil9KX19LHsiLi4vLi4vdXRpbHMvdXRpbHMiOjIwLCIuLi9wcm9wZXJ0eSI6NDV9XSw0MDpbZnVuY3Rpb24odCxlLG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj10KCIuLi9tZXRob2QiKSxvPXQoIi4uL3Byb3BlcnR5IiksaT10KCIuLi9mb3JtYXR0ZXJzIiksYT1mdW5jdGlvbigpe3ZhciB0PW5ldyByKHtuYW1lOiJuZXdBY2NvdW50IixjYWxsOiJwZXJzb25hbF9uZXdBY2NvdW50IixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSxlPW5ldyByKHtuYW1lOiJpbXBvcnRSYXdLZXkiLGNhbGw6InBlcnNvbmFsX2ltcG9ydFJhd0tleSIscGFyYW1zOjJ9KSxuPW5ldyByKHtuYW1lOiJzaWduIixjYWxsOiJwZXJzb25hbF9zaWduIixwYXJhbXM6MyxpbnB1dEZvcm1hdHRlcjpbbnVsbCxpLmlucHV0QWRkcmVzc0Zvcm1hdHRlcixudWxsXX0pLG89bmV3IHIoe25hbWU6ImVjUmVjb3ZlciIsY2FsbDoicGVyc29uYWxfZWNSZWNvdmVyIixwYXJhbXM6Mn0pO3JldHVyblt0LGUsbmV3IHIoe25hbWU6InVubG9ja0FjY291bnQiLGNhbGw6InBlcnNvbmFsX3VubG9ja0FjY291bnQiLHBhcmFtczozLGlucHV0Rm9ybWF0dGVyOltpLmlucHV0QWRkcmVzc0Zvcm1hdHRlcixudWxsLG51bGxdfSksbyxuLG5ldyByKHtuYW1lOiJzZW5kVHJhbnNhY3Rpb24iLGNhbGw6InBlcnNvbmFsX3NlbmRUcmFuc2FjdGlvbiIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W2kuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcixudWxsXX0pLG5ldyByKHtuYW1lOiJsb2NrQWNjb3VudCIsY2FsbDoicGVyc29uYWxfbG9ja0FjY291bnQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltpLmlucHV0QWRkcmVzc0Zvcm1hdHRlcl19KV19LHM9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG8oe25hbWU6Imxpc3RBY2NvdW50cyIsZ2V0dGVyOiJwZXJzb25hbF9saXN0QWNjb3VudHMifSldfTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpczthKCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSkscygpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pfX0seyIuLi9mb3JtYXR0ZXJzIjozMCwiLi4vbWV0aG9kIjozNiwiLi4vcHJvcGVydHkiOjQ1fV0sNDE6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi9tZXRob2QiKSxvPXQoIi4uL2ZpbHRlciIpLGk9dCgiLi93YXRjaGVzIiksYT1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10Ll9yZXF1ZXN0TWFuYWdlcjt2YXIgZT10aGlzO3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KX07YS5wcm90b3R5cGUubmV3TWVzc2FnZUZpbHRlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG5ldyBvKHQsInNoaCIsdGhpcy5fcmVxdWVzdE1hbmFnZXIsaS5zaGgoKSxudWxsLGUsbil9O3ZhciBzPWZ1bmN0aW9uKCl7cmV0dXJuW25ldyByKHtuYW1lOiJ2ZXJzaW9uIixjYWxsOiJzaGhfdmVyc2lvbiIscGFyYW1zOjB9KSxuZXcgcih7bmFtZToiaW5mbyIsY2FsbDoic2hoX2luZm8iLHBhcmFtczowfSksbmV3IHIoe25hbWU6InNldE1heE1lc3NhZ2VTaXplIixjYWxsOiJzaGhfc2V0TWF4TWVzc2FnZVNpemUiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6InNldE1pblBvVyIsY2FsbDoic2hoX3NldE1pblBvVyIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToibWFya1RydXN0ZWRQZWVyIixjYWxsOiJzaGhfbWFya1RydXN0ZWRQZWVyIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJuZXdLZXlQYWlyIixjYWxsOiJzaGhfbmV3S2V5UGFpciIscGFyYW1zOjB9KSxuZXcgcih7bmFtZToiYWRkUHJpdmF0ZUtleSIsY2FsbDoic2hoX2FkZFByaXZhdGVLZXkiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImRlbGV0ZUtleVBhaXIiLGNhbGw6InNoaF9kZWxldGVLZXlQYWlyIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJoYXNLZXlQYWlyIixjYWxsOiJzaGhfaGFzS2V5UGFpciIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZ2V0UHVibGljS2V5IixjYWxsOiJzaGhfZ2V0UHVibGljS2V5IixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJnZXRQcml2YXRlS2V5IixjYWxsOiJzaGhfZ2V0UHJpdmF0ZUtleSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToibmV3U3ltS2V5IixjYWxsOiJzaGhfbmV3U3ltS2V5IixwYXJhbXM6MH0pLG5ldyByKHtuYW1lOiJhZGRTeW1LZXkiLGNhbGw6InNoaF9hZGRTeW1LZXkiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImdlbmVyYXRlU3ltS2V5RnJvbVBhc3N3b3JkIixjYWxsOiJzaGhfZ2VuZXJhdGVTeW1LZXlGcm9tUGFzc3dvcmQiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6Imhhc1N5bUtleSIsY2FsbDoic2hoX2hhc1N5bUtleSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZ2V0U3ltS2V5IixjYWxsOiJzaGhfZ2V0U3ltS2V5IixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJkZWxldGVTeW1LZXkiLGNhbGw6InNoaF9kZWxldGVTeW1LZXkiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6InBvc3QiLGNhbGw6InNoaF9wb3N0IixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KV19O2UuZXhwb3J0cz1hfSx7Ii4uL2ZpbHRlciI6MjksIi4uL21ldGhvZCI6MzYsIi4vd2F0Y2hlcyI6NDN9XSw0MjpbZnVuY3Rpb24odCxlLG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj10KCIuLi9tZXRob2QiKSxvPXQoIi4uL3Byb3BlcnR5IiksaT1mdW5jdGlvbigpe3JldHVybltuZXcgcih7bmFtZToiYmxvY2tOZXR3b3JrUmVhZCIsY2FsbDoiYnp6X2Jsb2NrTmV0d29ya1JlYWQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLG5ldyByKHtuYW1lOiJzeW5jRW5hYmxlZCIsY2FsbDoiYnp6X3N5bmNFbmFibGVkIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSxuZXcgcih7bmFtZToic3dhcEVuYWJsZWQiLGNhbGw6ImJ6el9zd2FwRW5hYmxlZCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IHIoe25hbWU6ImRvd25sb2FkIixjYWxsOiJienpfZG93bmxvYWQiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG51bGxdfSksbmV3IHIoe25hbWU6InVwbG9hZCIsY2FsbDoiYnp6X3VwbG9hZCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W251bGwsbnVsbF19KSxuZXcgcih7bmFtZToicmV0cmlldmUiLGNhbGw6ImJ6el9yZXRyaWV2ZSIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IHIoe25hbWU6InN0b3JlIixjYWxsOiJienpfc3RvcmUiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG51bGxdfSksbmV3IHIoe25hbWU6ImdldCIsY2FsbDoiYnp6X2dldCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IHIoe25hbWU6InB1dCIsY2FsbDoiYnp6X3B1dCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W251bGwsbnVsbF19KSxuZXcgcih7bmFtZToibW9kaWZ5IixjYWxsOiJienpfbW9kaWZ5IixwYXJhbXM6NCxpbnB1dEZvcm1hdHRlcjpbbnVsbCxudWxsLG51bGwsbnVsbF19KV19LGE9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG8oe25hbWU6ImhpdmUiLGdldHRlcjoiYnp6X2hpdmUifSksbmV3IG8oe25hbWU6ImluZm8iLGdldHRlcjoiYnp6X2luZm8ifSldfTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpcztpKCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSksYSgpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pfX0seyIuLi9tZXRob2QiOjM2LCIuLi9wcm9wZXJ0eSI6NDV9XSw0MzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL21ldGhvZCIpO2UuZXhwb3J0cz17ZXRoOmZ1bmN0aW9uKCl7cmV0dXJuW25ldyByKHtuYW1lOiJuZXdGaWx0ZXIiLGNhbGw6ZnVuY3Rpb24odCl7c3dpdGNoKHRbMF0pe2Nhc2UibGF0ZXN0IjpyZXR1cm4gdC5zaGlmdCgpLHRoaXMucGFyYW1zPTAsImV0aF9uZXdCbG9ja0ZpbHRlciI7Y2FzZSJwZW5kaW5nIjpyZXR1cm4gdC5zaGlmdCgpLHRoaXMucGFyYW1zPTAsImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIiO2RlZmF1bHQ6cmV0dXJuImV0aF9uZXdGaWx0ZXIifX0scGFyYW1zOjF9KSxuZXcgcih7bmFtZToidW5pbnN0YWxsRmlsdGVyIixjYWxsOiJldGhfdW5pbnN0YWxsRmlsdGVyIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJnZXRMb2dzIixjYWxsOiJldGhfZ2V0RmlsdGVyTG9ncyIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToicG9sbCIsY2FsbDoiZXRoX2dldEZpbHRlckNoYW5nZXMiLHBhcmFtczoxfSldfSxzaGg6ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IHIoe25hbWU6Im5ld0ZpbHRlciIsY2FsbDoic2hoX25ld01lc3NhZ2VGaWx0ZXIiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6InVuaW5zdGFsbEZpbHRlciIsY2FsbDoic2hoX2RlbGV0ZU1lc3NhZ2VGaWx0ZXIiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImdldExvZ3MiLGNhbGw6InNoaF9nZXRGaWx0ZXJNZXNzYWdlcyIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToicG9sbCIsY2FsbDoic2hoX2dldEZpbHRlck1lc3NhZ2VzIixwYXJhbXM6MX0pXX19fSx7Ii4uL21ldGhvZCI6MzZ9XSw0NDpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL2NvbnRyYWN0cy9HbG9iYWxSZWdpc3RyYXIuanNvbiIpLG89dCgiLi4vY29udHJhY3RzL0lDQVBSZWdpc3RyYXIuanNvbiIpO2UuZXhwb3J0cz17Z2xvYmFsOnthYmk6cixhZGRyZXNzOiIweGM2ZDlkMmNkNDQ5YTc1NGM0OTQyNjRlMTgwOWM1MGUzNGQ2NDU2MmIifSxpY2FwOnthYmk6byxhZGRyZXNzOiIweGExYTExMWJjMDc0YzljZmE3ODFmMGMzOGU2M2JkNTFjOTFiOGFmMDAifX19LHsiLi4vY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uIjoxLCIuLi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uIjoyfV0sNDU6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi91dGlscy91dGlscyIpLG89ZnVuY3Rpb24odCl7dGhpcy5uYW1lPXQubmFtZSx0aGlzLmdldHRlcj10LmdldHRlcix0aGlzLnNldHRlcj10LnNldHRlcix0aGlzLm91dHB1dEZvcm1hdHRlcj10Lm91dHB1dEZvcm1hdHRlcix0aGlzLmlucHV0Rm9ybWF0dGVyPXQuaW5wdXRGb3JtYXR0ZXIsdGhpcy5yZXF1ZXN0TWFuYWdlcj1udWxsfTtvLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlcj1mdW5jdGlvbih0KXt0aGlzLnJlcXVlc3RNYW5hZ2VyPXR9LG8ucHJvdG90eXBlLmZvcm1hdElucHV0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyP3RoaXMuaW5wdXRGb3JtYXR0ZXIodCk6dH0sby5wcm90b3R5cGUuZm9ybWF0T3V0cHV0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciYmbnVsbCE9PXQmJnZvaWQgMCE9PXQ/dGhpcy5vdXRwdXRGb3JtYXR0ZXIodCk6dH0sby5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrPWZ1bmN0aW9uKHQpe2lmKHIuaXNGdW5jdGlvbih0W3QubGVuZ3RoLTFdKSlyZXR1cm4gdC5wb3AoKX0sby5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3Q9ZnVuY3Rpb24odCl7dmFyIGU9e2dldDp0aGlzLmJ1aWxkR2V0KCksZW51bWVyYWJsZTohMH0sbj10aGlzLm5hbWUuc3BsaXQoIi4iKSxyPW5bMF07bi5sZW5ndGg+MSYmKHRbblswXV09dFtuWzBdXXx8e30sdD10W25bMF1dLHI9blsxXSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixlKSx0W2kocildPXRoaXMuYnVpbGRBc3luY0dldCgpfTt2YXIgaT1mdW5jdGlvbih0KXtyZXR1cm4iZ2V0Iit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9O28ucHJvdG90eXBlLmJ1aWxkR2V0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5mb3JtYXRPdXRwdXQodC5yZXF1ZXN0TWFuYWdlci5zZW5kKHttZXRob2Q6dC5nZXR0ZXJ9KSl9fSxvLnByb3RvdHlwZS5idWlsZEFzeW5jR2V0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKGUpe3QucmVxdWVzdE1hbmFnZXIuc2VuZEFzeW5jKHttZXRob2Q6dC5nZXR0ZXJ9LGZ1bmN0aW9uKG4scil7ZShuLHQuZm9ybWF0T3V0cHV0KHIpKX0pfTtyZXR1cm4gZS5yZXF1ZXN0PXRoaXMucmVxdWVzdC5iaW5kKHRoaXMpLGV9LG8ucHJvdG90eXBlLnJlcXVlc3Q9ZnVuY3Rpb24oKXt2YXIgdD17bWV0aG9kOnRoaXMuZ2V0dGVyLHBhcmFtczpbXSxjYWxsYmFjazp0aGlzLmV4dHJhY3RDYWxsYmFjayhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKX07cmV0dXJuIHQuZm9ybWF0PXRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyksdH0sZS5leHBvcnRzPW99LHsiLi4vdXRpbHMvdXRpbHMiOjIwfV0sNDY6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2pzb25ycGMiKSxvPXQoIi4uL3V0aWxzL3V0aWxzIiksaT10KCIuLi91dGlscy9jb25maWciKSxhPXQoIi4vZXJyb3JzIikscz1mdW5jdGlvbih0KXt0aGlzLnByb3ZpZGVyPXQsdGhpcy5wb2xscz17fSx0aGlzLnRpbWVvdXQ9bnVsbH07cy5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbih0KXtpZighdGhpcy5wcm92aWRlcilyZXR1cm4gY29uc29sZS5lcnJvcihhLkludmFsaWRQcm92aWRlcigpKSxudWxsO3ZhciBlPXIudG9QYXlsb2FkKHQubWV0aG9kLHQucGFyYW1zKSxuPXRoaXMucHJvdmlkZXIuc2VuZChlKTtpZighci5pc1ZhbGlkUmVzcG9uc2UobikpdGhyb3cgYS5JbnZhbGlkUmVzcG9uc2Uobik7cmV0dXJuIG4ucmVzdWx0fSxzLnByb3RvdHlwZS5zZW5kQXN5bmM9ZnVuY3Rpb24odCxlKXtpZighdGhpcy5wcm92aWRlcilyZXR1cm4gZShhLkludmFsaWRQcm92aWRlcigpKTt2YXIgbj1yLnRvUGF5bG9hZCh0Lm1ldGhvZCx0LnBhcmFtcyk7dGhpcy5wcm92aWRlci5zZW5kQXN5bmMobixmdW5jdGlvbih0LG4pe3JldHVybiB0P2UodCk6ci5pc1ZhbGlkUmVzcG9uc2Uobik/dm9pZCBlKG51bGwsbi5yZXN1bHQpOmUoYS5JbnZhbGlkUmVzcG9uc2UobikpfSl9LHMucHJvdG90eXBlLnNlbmRCYXRjaD1mdW5jdGlvbih0LGUpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiBlKGEuSW52YWxpZFByb3ZpZGVyKCkpO3ZhciBuPXIudG9CYXRjaFBheWxvYWQodCk7dGhpcy5wcm92aWRlci5zZW5kQXN5bmMobixmdW5jdGlvbih0LG4pe3JldHVybiB0P2UodCk6by5pc0FycmF5KG4pP3ZvaWQgZSh0LG4pOmUoYS5JbnZhbGlkUmVzcG9uc2UobikpfSl9LHMucHJvdG90eXBlLnNldFByb3ZpZGVyPWZ1bmN0aW9uKHQpe3RoaXMucHJvdmlkZXI9dH0scy5wcm90b3R5cGUuc3RhcnRQb2xsaW5nPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMucG9sbHNbZV09e2RhdGE6dCxpZDplLGNhbGxiYWNrOm4sdW5pbnN0YWxsOnJ9LHRoaXMudGltZW91dHx8dGhpcy5wb2xsKCl9LHMucHJvdG90eXBlLnN0b3BQb2xsaW5nPWZ1bmN0aW9uKHQpe2RlbGV0ZSB0aGlzLnBvbGxzW3RdLDA9PT1PYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGgmJnRoaXMudGltZW91dCYmKGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLHRoaXMudGltZW91dD1udWxsKX0scy5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHRoaXMucG9sbHMpdCYmLTEhPT1lLmluZGV4T2YoInN5bmNQb2xsXyIpfHwodGhpcy5wb2xsc1tlXS51bmluc3RhbGwoKSxkZWxldGUgdGhpcy5wb2xsc1tlXSk7MD09PU9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCYmdGhpcy50aW1lb3V0JiYoY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCksdGhpcy50aW1lb3V0PW51bGwpfSxzLnByb3RvdHlwZS5wb2xsPWZ1bmN0aW9uKCl7aWYodGhpcy50aW1lb3V0PXNldFRpbWVvdXQodGhpcy5wb2xsLmJpbmQodGhpcyksaS5FVEhfUE9MTElOR19USU1FT1VUKSwwIT09T2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoKWlmKHRoaXMucHJvdmlkZXIpe3ZhciB0PVtdLGU9W107Zm9yKHZhciBuIGluIHRoaXMucG9sbHMpdC5wdXNoKHRoaXMucG9sbHNbbl0uZGF0YSksZS5wdXNoKG4pO2lmKDAhPT10Lmxlbmd0aCl7dmFyIHM9ci50b0JhdGNoUGF5bG9hZCh0KSxjPXt9O3MuZm9yRWFjaChmdW5jdGlvbih0LG4pe2NbdC5pZF09ZVtuXX0pO3ZhciB1PXRoaXM7dGhpcy5wcm92aWRlci5zZW5kQXN5bmMocyxmdW5jdGlvbih0LGUpe2lmKCF0KXtpZighby5pc0FycmF5KGUpKXRocm93IGEuSW52YWxpZFJlc3BvbnNlKGUpO2UubWFwKGZ1bmN0aW9uKHQpe3ZhciBlPWNbdC5pZF07cmV0dXJuISF1LnBvbGxzW2VdJiYodC5jYWxsYmFjaz11LnBvbGxzW2VdLmNhbGxiYWNrLHQpfSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiEhdH0pLmZpbHRlcihmdW5jdGlvbih0KXt2YXIgZT1yLmlzVmFsaWRSZXNwb25zZSh0KTtyZXR1cm4gZXx8dC5jYWxsYmFjayhhLkludmFsaWRSZXNwb25zZSh0KSksZX0pLmZvckVhY2goZnVuY3Rpb24odCl7dC5jYWxsYmFjayhudWxsLHQucmVzdWx0KX0pfX0pfX1lbHNlIGNvbnNvbGUuZXJyb3IoYS5JbnZhbGlkUHJvdmlkZXIoKSl9LGUuZXhwb3J0cz1zfSx7Ii4uL3V0aWxzL2NvbmZpZyI6MTgsIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9lcnJvcnMiOjI2LCIuL2pzb25ycGMiOjM1fV0sNDc6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRCbG9jaz0ibGF0ZXN0Iix0aGlzLmRlZmF1bHRBY2NvdW50PXZvaWQgMH19LHt9XSw0ODpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPTEsYT1mdW5jdGlvbih0KXt0LnJlcXVlc3RNYW5hZ2VyLnN0YXJ0UG9sbGluZyh7bWV0aG9kOiJldGhfc3luY2luZyIscGFyYW1zOltdfSx0LnBvbGxJZCxmdW5jdGlvbihlLG4pe2lmKGUpcmV0dXJuIHQuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7dChlKX0pO28uaXNPYmplY3QobikmJm4uc3RhcnRpbmdCbG9jayYmKG49ci5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyKG4pKSx0LmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QubGFzdFN5bmNTdGF0ZSE9PW4mJighdC5sYXN0U3luY1N0YXRlJiZvLmlzT2JqZWN0KG4pJiZlKG51bGwsITApLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKG51bGwsbil9LDApLHQubGFzdFN5bmNTdGF0ZT1uKX0pfSx0LnN0b3BXYXRjaGluZy5iaW5kKHQpKX0scz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnJlcXVlc3RNYW5hZ2VyPXQsdGhpcy5wb2xsSWQ9InN5bmNQb2xsXyIraSsrLHRoaXMuY2FsbGJhY2tzPVtdLHRoaXMuYWRkQ2FsbGJhY2soZSksdGhpcy5sYXN0U3luY1N0YXRlPSExLGEodGhpcyksdGhpc307cy5wcm90b3R5cGUuYWRkQ2FsbGJhY2s9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMuY2FsbGJhY2tzLnB1c2godCksdGhpc30scy5wcm90b3R5cGUuc3RvcFdhdGNoaW5nPWZ1bmN0aW9uKCl7dGhpcy5yZXF1ZXN0TWFuYWdlci5zdG9wUG9sbGluZyh0aGlzLnBvbGxJZCksdGhpcy5jYWxsYmFja3M9W119LGUuZXhwb3J0cz1zfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMCwiLi9mb3JtYXR0ZXJzIjozMH1dLDQ5OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9pYmFuIiksbz10KCIuLi9jb250cmFjdHMvU21hcnRFeGNoYW5nZS5qc29uIiksaT1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0LnNlbmRUcmFuc2FjdGlvbih7YWRkcmVzczpuLGZyb206ZSx2YWx1ZTpyfSxvKX0sYT1mdW5jdGlvbih0LGUsbixyLGksYSl7dmFyIHM9bztyZXR1cm4gdC5jb250cmFjdChzKS5hdChuKS5kZXBvc2l0KGkse2Zyb206ZSx2YWx1ZTpyfSxhKX07ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLG8scyl7dmFyIGM9bmV3IHIobik7aWYoIWMuaXNWYWxpZCgpKXRocm93IG5ldyBFcnJvcigiaW52YWxpZCBpYmFuIGFkZHJlc3MiKTtpZihjLmlzRGlyZWN0KCkpcmV0dXJuIGkodCxlLGMuYWRkcmVzcygpLG8scyk7aWYoIXMpe3ZhciB1PXQuaWNhcE5hbWVyZWcoKS5hZGRyKGMuaW5zdGl0dXRpb24oKSk7cmV0dXJuIGEodCxlLHUsbyxjLmNsaWVudCgpKX10LmljYXBOYW1lcmVnKCkuYWRkcihjLmluc3RpdHV0aW9uKCksZnVuY3Rpb24obixyKXtyZXR1cm4gYSh0LGUscixvLGMuY2xpZW50KCkscyl9KX19LHsiLi4vY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiI6MywiLi9pYmFuIjozM31dLDUwOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LG49ZS5saWIuQmxvY2tDaXBoZXIscj1lLmFsZ28sbz1bXSxpPVtdLGE9W10scz1bXSxjPVtdLHU9W10sZj1bXSxsPVtdLHA9W10saD1bXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8MjU2O2UrKyl0W2VdPWU8MTI4P2U8PDE6ZTw8MV4yODM7Zm9yKHZhciBuPTAscj0wLGU9MDtlPDI1NjtlKyspe3ZhciBkPXJecjw8MV5yPDwyXnI8PDNecjw8NDtkPWQ+Pj44XjI1NSZkXjk5LG9bbl09ZCxpW2RdPW47dmFyIG09dFtuXSx5PXRbbV0sZz10W3ldLHY9MjU3KnRbZF1eMTY4NDMwMDgqZDthW25dPXY8PDI0fHY+Pj44LHNbbl09djw8MTZ8dj4+PjE2LGNbbl09djw8OHx2Pj4+MjQsdVtuXT12O3Y9MTY4NDMwMDkqZ142NTUzNyp5XjI1NyptXjE2ODQzMDA4Km47ZltkXT12PDwyNHx2Pj4+OCxsW2RdPXY8PDE2fHY+Pj4xNixwW2RdPXY8PDh8dj4+PjI0LGhbZF09dixuPyhuPW1edFt0W3RbZ15tXV1dLHJePXRbdFtyXV0pOm49cj0xfX0oKTt2YXIgZD1bMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NF0sbT1yLkFFUz1uLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy5fblJvdW5kc3x8dGhpcy5fa2V5UHJpb3JSZXNldCE9PXRoaXMuX2tleSl7Zm9yKHZhciB0PXRoaXMuX2tleVByaW9yUmVzZXQ9dGhpcy5fa2V5LGU9dC53b3JkcyxuPXQuc2lnQnl0ZXMvNCxyPTQqKCh0aGlzLl9uUm91bmRzPW4rNikrMSksaT10aGlzLl9rZXlTY2hlZHVsZT1bXSxhPTA7YTxyO2ErKylpZihhPG4paVthXT1lW2FdO2Vsc2V7dT1pW2EtMV07YSVuP24+NiYmYSVuPT00JiYodT1vW3U+Pj4yNF08PDI0fG9bdT4+PjE2JjI1NV08PDE2fG9bdT4+PjgmMjU1XTw8OHxvWzI1NSZ1XSk6KHU9b1sodT11PDw4fHU+Pj4yNCk+Pj4yNF08PDI0fG9bdT4+PjE2JjI1NV08PDE2fG9bdT4+PjgmMjU1XTw8OHxvWzI1NSZ1XSx1Xj1kW2EvbnwwXTw8MjQpLGlbYV09aVthLW5dXnV9Zm9yKHZhciBzPXRoaXMuX2ludktleVNjaGVkdWxlPVtdLGM9MDtjPHI7YysrKXthPXItYztpZihjJTQpdT1pW2FdO2Vsc2UgdmFyIHU9aVthLTRdO3NbY109Yzw0fHxhPD00P3U6ZltvW3U+Pj4yNF1dXmxbb1t1Pj4+MTYmMjU1XV1ecFtvW3U+Pj44JjI1NV1dXmhbb1syNTUmdV1dfX19LGVuY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5fa2V5U2NoZWR1bGUsYSxzLGMsdSxvKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSl7bj10W2UrMV07dFtlKzFdPXRbZSszXSx0W2UrM109bix0aGlzLl9kb0NyeXB0QmxvY2sodCxlLHRoaXMuX2ludktleVNjaGVkdWxlLGYsbCxwLGgsaSk7dmFyIG49dFtlKzFdO3RbZSsxXT10W2UrM10sdFtlKzNdPW59LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24odCxlLG4scixvLGksYSxzKXtmb3IodmFyIGM9dGhpcy5fblJvdW5kcyx1PXRbZV1eblswXSxmPXRbZSsxXV5uWzFdLGw9dFtlKzJdXm5bMl0scD10W2UrM11eblszXSxoPTQsZD0xO2Q8YztkKyspe3ZhciBtPXJbdT4+PjI0XV5vW2Y+Pj4xNiYyNTVdXmlbbD4+PjgmMjU1XV5hWzI1NSZwXV5uW2grK10seT1yW2Y+Pj4yNF1eb1tsPj4+MTYmMjU1XV5pW3A+Pj44JjI1NV1eYVsyNTUmdV1ebltoKytdLGc9cltsPj4+MjRdXm9bcD4+PjE2JjI1NV1eaVt1Pj4+OCYyNTVdXmFbMjU1JmZdXm5baCsrXSx2PXJbcD4+PjI0XV5vW3U+Pj4xNiYyNTVdXmlbZj4+PjgmMjU1XV5hWzI1NSZsXV5uW2grK107dT1tLGY9eSxsPWcscD12fXZhciBtPShzW3U+Pj4yNF08PDI0fHNbZj4+PjE2JjI1NV08PDE2fHNbbD4+PjgmMjU1XTw8OHxzWzI1NSZwXSlebltoKytdLHk9KHNbZj4+PjI0XTw8MjR8c1tsPj4+MTYmMjU1XTw8MTZ8c1twPj4+OCYyNTVdPDw4fHNbMjU1JnVdKV5uW2grK10sZz0oc1tsPj4+MjRdPDwyNHxzW3A+Pj4xNiYyNTVdPDwxNnxzW3U+Pj44JjI1NV08PDh8c1syNTUmZl0pXm5baCsrXSx2PShzW3A+Pj4yNF08PDI0fHNbdT4+PjE2JjI1NV08PDE2fHNbZj4+PjgmMjU1XTw8OHxzWzI1NSZsXSlebltoKytdO3RbZV09bSx0W2UrMV09eSx0W2UrMl09Zyx0W2UrM109dn0sa2V5U2l6ZTo4fSk7ZS5BRVM9bi5fY3JlYXRlSGVscGVyKG0pfSgpLHQuQUVTfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTIsIi4vZW5jLWJhc2U2NCI6NTMsIi4vZXZwa2RmIjo1NSwiLi9tZDUiOjYwfV0sNTE6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3QubGliLkNpcGhlcnx8ZnVuY3Rpb24oZSl7dmFyIG49dCxyPW4ubGliLG89ci5CYXNlLGk9ci5Xb3JkQXJyYXksYT1yLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0scz1uLmVuYyxjPShzLlV0Zjgscy5CYXNlNjQpLHU9bi5hbGdvLkV2cEtERixmPXIuQ2lwaGVyPWEuZXh0ZW5kKHtjZmc6by5leHRlbmQoKSxjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsdCxlKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLHQsZSl9LGluaXQ6ZnVuY3Rpb24odCxlLG4pe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChuKSx0aGlzLl94Zm9ybU1vZGU9dCx0aGlzLl9rZXk9ZSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7YS5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0scHJvY2VzczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYXBwZW5kKHQpLHRoaXMuX3Byb2Nlc3MoKX0sZmluYWxpemU6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMuX2FwcGVuZCh0KSx0aGlzLl9kb0ZpbmFsaXplKCl9LGtleVNpemU6NCxpdlNpemU6NCxfRU5DX1hGT1JNX01PREU6MSxfREVDX1hGT1JNX01PREU6MixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHQ/YjpnfXJldHVybiBmdW5jdGlvbihlKXtyZXR1cm57ZW5jcnlwdDpmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQocikuZW5jcnlwdChlLG4scixvKX0sZGVjcnlwdDpmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQocikuZGVjcnlwdChlLG4scixvKX19fX0oKX0pLGw9KHIuU3RyZWFtQ2lwaGVyPWYuZXh0ZW5kKHtfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9jZXNzKCEwKX0sYmxvY2tTaXplOjF9KSxuLm1vZGU9e30pLHA9ci5CbG9ja0NpcGhlck1vZGU9by5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUodCxlKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZSh0LGUpfSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5fY2lwaGVyPXQsdGhpcy5faXY9ZX19KSxoPWwuQ0JDPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LG4scil7dmFyIG89dGhpcy5faXY7aWYobyl7aT1vO3RoaXMuX2l2PWV9ZWxzZSB2YXIgaT10aGlzLl9wcmV2QmxvY2s7Zm9yKHZhciBhPTA7YTxyO2ErKyl0W24rYV1ePWlbYV19dmFyIG49cC5leHRlbmQoKTtyZXR1cm4gbi5FbmNyeXB0b3I9bi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLG4pe3ZhciByPXRoaXMuX2NpcGhlcixvPXIuYmxvY2tTaXplO3QuY2FsbCh0aGlzLGUsbixvKSxyLmVuY3J5cHRCbG9jayhlLG4pLHRoaXMuX3ByZXZCbG9jaz1lLnNsaWNlKG4sbitvKX19KSxuLkRlY3J5cHRvcj1uLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsbil7dmFyIHI9dGhpcy5fY2lwaGVyLG89ci5ibG9ja1NpemUsaT1lLnNsaWNlKG4sbitvKTtyLmRlY3J5cHRCbG9jayhlLG4pLHQuY2FsbCh0aGlzLGUsbixvKSx0aGlzLl9wcmV2QmxvY2s9aX19KSxufSgpLGQ9KG4ucGFkPXt9KS5Qa2NzNz17cGFkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTQqZSxyPW4tdC5zaWdCeXRlcyVuLG89cjw8MjR8cjw8MTZ8cjw8OHxyLGE9W10scz0wO3M8cjtzKz00KWEucHVzaChvKTt2YXIgYz1pLmNyZWF0ZShhLHIpO3QuY29uY2F0KGMpfSx1bnBhZDpmdW5jdGlvbih0KXt2YXIgZT0yNTUmdC53b3Jkc1t0LnNpZ0J5dGVzLTE+Pj4yXTt0LnNpZ0J5dGVzLT1lfX0sbT0oci5CbG9ja0NpcGhlcj1mLmV4dGVuZCh7Y2ZnOmYuY2ZnLmV4dGVuZCh7bW9kZTpoLHBhZGRpbmc6ZH0pLHJlc2V0OmZ1bmN0aW9uKCl7Zi5yZXNldC5jYWxsKHRoaXMpO3ZhciB0PXRoaXMuY2ZnLGU9dC5pdixuPXQubW9kZTtpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXI9bi5jcmVhdGVFbmNyeXB0b3I7ZWxzZXt2YXIgcj1uLmNyZWF0ZURlY3J5cHRvcjt0aGlzLl9taW5CdWZmZXJTaXplPTF9dGhpcy5fbW9kZT1yLmNhbGwobix0aGlzLGUmJmUud29yZHMpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh0LGUpfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY2ZnLnBhZGRpbmc7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl7dC5wYWQodGhpcy5fZGF0YSx0aGlzLmJsb2NrU2l6ZSk7ZT10aGlzLl9wcm9jZXNzKCEwKX1lbHNle3ZhciBlPXRoaXMuX3Byb2Nlc3MoITApO3QudW5wYWQoZSl9cmV0dXJuIGV9LGJsb2NrU2l6ZTo0fSksci5DaXBoZXJQYXJhbXM9by5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCl7dGhpcy5taXhJbih0KX0sdG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuKHR8fHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyl9fSkpLHk9KG4uZm9ybWF0PXt9KS5PcGVuU1NMPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7dmFyIGU9dC5jaXBoZXJ0ZXh0LG49dC5zYWx0O2lmKG4pcj1pLmNyZWF0ZShbMTM5ODg5MzY4NCwxNzAxMDc2ODMxXSkuY29uY2F0KG4pLmNvbmNhdChlKTtlbHNlIHZhciByPWU7cmV0dXJuIHIudG9TdHJpbmcoYyl9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBlPWMucGFyc2UodCksbj1lLndvcmRzO2lmKDEzOTg4OTM2ODQ9PW5bMF0mJjE3MDEwNzY4MzE9PW5bMV0pe3ZhciByPWkuY3JlYXRlKG4uc2xpY2UoMiw0KSk7bi5zcGxpY2UoMCw0KSxlLnNpZ0J5dGVzLT0xNn1yZXR1cm4gbS5jcmVhdGUoe2NpcGhlcnRleHQ6ZSxzYWx0OnJ9KX19LGc9ci5TZXJpYWxpemFibGVDaXBoZXI9by5leHRlbmQoe2NmZzpvLmV4dGVuZCh7Zm9ybWF0Onl9KSxlbmNyeXB0OmZ1bmN0aW9uKHQsZSxuLHIpe3I9dGhpcy5jZmcuZXh0ZW5kKHIpO3ZhciBvPXQuY3JlYXRlRW5jcnlwdG9yKG4sciksaT1vLmZpbmFsaXplKGUpLGE9by5jZmc7cmV0dXJuIG0uY3JlYXRlKHtjaXBoZXJ0ZXh0Omksa2V5Om4saXY6YS5pdixhbGdvcml0aG06dCxtb2RlOmEubW9kZSxwYWRkaW5nOmEucGFkZGluZyxibG9ja1NpemU6dC5ibG9ja1NpemUsZm9ybWF0dGVyOnIuZm9ybWF0fSl9LGRlY3J5cHQ6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHI9dGhpcy5jZmcuZXh0ZW5kKHIpLGU9dGhpcy5fcGFyc2UoZSxyLmZvcm1hdCksdC5jcmVhdGVEZWNyeXB0b3IobixyKS5maW5hbGl6ZShlLmNpcGhlcnRleHQpfSxfcGFyc2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHQ/ZS5wYXJzZSh0LHRoaXMpOnR9fSksdj0obi5rZGY9e30pLk9wZW5TU0w9e2V4ZWN1dGU6ZnVuY3Rpb24odCxlLG4scil7cnx8KHI9aS5yYW5kb20oOCkpO3ZhciBvPXUuY3JlYXRlKHtrZXlTaXplOmUrbn0pLmNvbXB1dGUodCxyKSxhPWkuY3JlYXRlKG8ud29yZHMuc2xpY2UoZSksNCpuKTtyZXR1cm4gby5zaWdCeXRlcz00KmUsbS5jcmVhdGUoe2tleTpvLGl2OmEsc2FsdDpyfSl9fSxiPXIuUGFzc3dvcmRCYXNlZENpcGhlcj1nLmV4dGVuZCh7Y2ZnOmcuY2ZnLmV4dGVuZCh7a2RmOnZ9KSxlbmNyeXB0OmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPShyPXRoaXMuY2ZnLmV4dGVuZChyKSkua2RmLmV4ZWN1dGUobix0LmtleVNpemUsdC5pdlNpemUpO3IuaXY9by5pdjt2YXIgaT1nLmVuY3J5cHQuY2FsbCh0aGlzLHQsZSxvLmtleSxyKTtyZXR1cm4gaS5taXhJbihvKSxpfSxkZWNyeXB0OmZ1bmN0aW9uKHQsZSxuLHIpe3I9dGhpcy5jZmcuZXh0ZW5kKHIpLGU9dGhpcy5fcGFyc2UoZSxyLmZvcm1hdCk7dmFyIG89ci5rZGYuZXhlY3V0ZShuLHQua2V5U2l6ZSx0Lml2U2l6ZSxlLnNhbHQpO3JldHVybiByLml2PW8uaXYsZy5kZWNyeXB0LmNhbGwodGhpcyx0LGUsby5rZXkscil9fSl9KCl9KX0seyIuL2NvcmUiOjUyfV0sNTI6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24odCxyKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49cigpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHIpOnQuQ3J5cHRvSlM9cigpfSh0aGlzLGZ1bmN0aW9uKCl7dmFyIHQ9dHx8ZnVuY3Rpb24odCxlKXt2YXIgbj1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuO3JldHVybiB0LnByb3RvdHlwZT1lLG49bmV3IHQsdC5wcm90b3R5cGU9bnVsbCxufX0oKSxyPXt9LG89ci5saWI9e30saT1vLkJhc2U9e2V4dGVuZDpmdW5jdGlvbih0KXt2YXIgZT1uKHRoaXMpO3JldHVybiB0JiZlLm1peEluKHQpLGUuaGFzT3duUHJvcGVydHkoImluaXQiKSYmdGhpcy5pbml0IT09ZS5pbml0fHwoZS5pbml0PWZ1bmN0aW9uKCl7ZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSxlLmluaXQucHJvdG90eXBlPWUsZS4kc3VwZXI9dGhpcyxlfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmV4dGVuZCgpO3JldHVybiB0LmluaXQuYXBwbHkodCxhcmd1bWVudHMpLHR9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkmJih0aGlzW2VdPXRbZV0pO3QuaGFzT3duUHJvcGVydHkoInRvU3RyaW5nIikmJih0aGlzLnRvU3RyaW5nPXQudG9TdHJpbmcpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKX19LGE9by5Xb3JkQXJyYXk9aS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMud29yZHM9dHx8W10sdGhpcy5zaWdCeXRlcz12b2lkIDAhPWU/ZTo0KnQubGVuZ3RofSx0b1N0cmluZzpmdW5jdGlvbih0KXtyZXR1cm4odHx8Yykuc3RyaW5naWZ5KHRoaXMpfSxjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy53b3JkcyxuPXQud29yZHMscj10aGlzLnNpZ0J5dGVzLG89dC5zaWdCeXRlcztpZih0aGlzLmNsYW1wKCksciU0KWZvcihhPTA7YTxvO2ErKyl7dmFyIGk9blthPj4+Ml0+Pj4yNC1hJTQqOCYyNTU7ZVtyK2E+Pj4yXXw9aTw8MjQtKHIrYSklNCo4fWVsc2UgZm9yKHZhciBhPTA7YTxvO2ErPTQpZVtyK2E+Pj4yXT1uW2E+Pj4yXTtyZXR1cm4gdGhpcy5zaWdCeXRlcys9byx0aGlzfSxjbGFtcDpmdW5jdGlvbigpe3ZhciBlPXRoaXMud29yZHMsbj10aGlzLnNpZ0J5dGVzO2Vbbj4+PjJdJj00Mjk0OTY3Mjk1PDwzMi1uJTQqOCxlLmxlbmd0aD10LmNlaWwobi80KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1pLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKSx0fSxyYW5kb206ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHI9W10sbz0wO288ZTtvKz00KXt2YXIgaT1mdW5jdGlvbihlKXt2YXIgZT1lLG49OTg3NjU0MzIxLHI9NDI5NDk2NzI5NTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbz0oKG49MzY5NjkqKDY1NTM1Jm4pKyhuPj4xNikmcik8PDE2KSsoZT0xOGUzKig2NTUzNSZlKSsoZT4+MTYpJnIpJnI7cmV0dXJuIG8vPTQyOTQ5NjcyOTYsKG8rPS41KSoodC5yYW5kb20oKT4uNT8xOi0xKX19KDQyOTQ5NjcyOTYqKG58fHQucmFuZG9tKCkpKTtuPTk4NzY1NDA3MSppKCksci5wdXNoKDQyOTQ5NjcyOTYqaSgpfDApfXJldHVybiBuZXcgYS5pbml0KHIsZSl9fSkscz1yLmVuYz17fSxjPXMuSGV4PXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9W10sbz0wO288bjtvKyspe3ZhciBpPWVbbz4+PjJdPj4+MjQtbyU0KjgmMjU1O3IucHVzaCgoaT4+PjQpLnRvU3RyaW5nKDE2KSksci5wdXNoKCgxNSZpKS50b1N0cmluZygxNikpfXJldHVybiByLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgsbj1bXSxyPTA7cjxlO3IrPTIpbltyPj4+M118PXBhcnNlSW50KHQuc3Vic3RyKHIsMiksMTYpPDwyNC1yJTgqNDtyZXR1cm4gbmV3IGEuaW5pdChuLGUvMil9fSx1PXMuTGF0aW4xPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9W10sbz0wO288bjtvKyspe3ZhciBpPWVbbz4+PjJdPj4+MjQtbyU0KjgmMjU1O3IucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKX1yZXR1cm4gci5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10scj0wO3I8ZTtyKyspbltyPj4+Ml18PSgyNTUmdC5jaGFyQ29kZUF0KHIpKTw8MjQtciU0Kjg7cmV0dXJuIG5ldyBhLmluaXQobixlKX19LGY9cy5VdGY4PXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHUuc3RyaW5naWZ5KHQpKSl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgVVRGLTggZGF0YSIpfX0scGFyc2U6ZnVuY3Rpb24odCl7cmV0dXJuIHUucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHQpKSl9fSxsPW8uQnVmZmVyZWRCbG9ja0FsZ29yaXRobT1pLmV4dGVuZCh7cmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9kYXRhPW5ldyBhLmluaXQsdGhpcy5fbkRhdGFCeXRlcz0wfSxfYXBwZW5kOmZ1bmN0aW9uKHQpeyJzdHJpbmciPT10eXBlb2YgdCYmKHQ9Zi5wYXJzZSh0KSksdGhpcy5fZGF0YS5jb25jYXQodCksdGhpcy5fbkRhdGFCeXRlcys9dC5zaWdCeXRlc30sX3Byb2Nlc3M6ZnVuY3Rpb24oZSl7dmFyIG49dGhpcy5fZGF0YSxyPW4ud29yZHMsbz1uLnNpZ0J5dGVzLGk9dGhpcy5ibG9ja1NpemUscz1vLyg0KmkpLGM9KHM9ZT90LmNlaWwocyk6dC5tYXgoKDB8cyktdGhpcy5fbWluQnVmZmVyU2l6ZSwwKSkqaSx1PXQubWluKDQqYyxvKTtpZihjKXtmb3IodmFyIGY9MDtmPGM7Zis9aSl0aGlzLl9kb1Byb2Nlc3NCbG9jayhyLGYpO3ZhciBsPXIuc3BsaWNlKDAsYyk7bi5zaWdCeXRlcy09dX1yZXR1cm4gbmV3IGEuaW5pdChsLHUpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWkuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCksdH0sX21pbkJ1ZmZlclNpemU6MH0pLHA9KG8uSGFzaGVyPWwuZXh0ZW5kKHtjZmc6aS5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZCh0KSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7bC5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9hcHBlbmQodCksdGhpcy5fcHJvY2VzcygpLHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLl9hcHBlbmQodCksdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQuaW5pdChuKS5maW5hbGl6ZShlKX19LF9jcmVhdGVIbWFjSGVscGVyOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLG4pe3JldHVybiBuZXcgcC5ITUFDLmluaXQodCxuKS5maW5hbGl6ZShlKX19fSksci5hbGdvPXt9KTtyZXR1cm4gcn0oTWF0aCk7cmV0dXJuIHR9KX0se31dLDUzOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsZSxuKXtmb3IodmFyIG89W10saT0wLGE9MDthPGU7YSsrKWlmKGElNCl7dmFyIHM9blt0LmNoYXJDb2RlQXQoYS0xKV08PGElNCoyLGM9blt0LmNoYXJDb2RlQXQoYSldPj4+Ni1hJTQqMjtvW2k+Pj4yXXw9KHN8Yyk8PDI0LWklNCo4LGkrK31yZXR1cm4gci5jcmVhdGUobyxpKX12YXIgbj10LHI9bi5saWIuV29yZEFycmF5O24uZW5jLkJhc2U2ND17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3ZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9dGhpcy5fbWFwO3QuY2xhbXAoKTtmb3IodmFyIG89W10saT0wO2k8bjtpKz0zKWZvcih2YXIgYT0oZVtpPj4+Ml0+Pj4yNC1pJTQqOCYyNTUpPDwxNnwoZVtpKzE+Pj4yXT4+PjI0LShpKzEpJTQqOCYyNTUpPDw4fGVbaSsyPj4+Ml0+Pj4yNC0oaSsyKSU0KjgmMjU1LHM9MDtzPDQmJmkrLjc1KnM8bjtzKyspby5wdXNoKHIuY2hhckF0KGE+Pj42KigzLXMpJjYzKSk7dmFyIGM9ci5jaGFyQXQoNjQpO2lmKGMpZm9yKDtvLmxlbmd0aCU0OylvLnB1c2goYyk7cmV0dXJuIG8uam9pbigiIil9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBuPXQubGVuZ3RoLHI9dGhpcy5fbWFwLG89dGhpcy5fcmV2ZXJzZU1hcDtpZighbyl7bz10aGlzLl9yZXZlcnNlTWFwPVtdO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKW9bci5jaGFyQ29kZUF0KGkpXT1pfXZhciBhPXIuY2hhckF0KDY0KTtpZihhKXt2YXIgcz10LmluZGV4T2YoYSk7LTEhPT1zJiYobj1zKX1yZXR1cm4gZSh0LG4sbyl9LF9tYXA6IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89In19KCksdC5lbmMuQmFzZTY0fSl9LHsiLi9jb3JlIjo1Mn1dLDU0OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3JldHVybiB0PDw4JjQyNzgyNTUzNjB8dD4+PjgmMTY3MTE5MzV9dmFyIG49dCxyPW4ubGliLldvcmRBcnJheSxvPW4uZW5jO28uVXRmMTY9by5VdGYxNkJFPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9W10sbz0wO288bjtvKz0yKXt2YXIgaT1lW28+Pj4yXT4+PjE2LW8lNCo4JjY1NTM1O3IucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKX1yZXR1cm4gci5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10sbz0wO288ZTtvKyspbltvPj4+MV18PXQuY2hhckNvZGVBdChvKTw8MTYtbyUyKjE2O3JldHVybiByLmNyZWF0ZShuLDIqZSl9fTtvLlV0ZjE2TEU9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXtmb3IodmFyIG49dC53b3JkcyxyPXQuc2lnQnl0ZXMsbz1bXSxpPTA7aTxyO2krPTIpe3ZhciBhPWUobltpPj4+Ml0+Pj4xNi1pJTQqOCY2NTUzNSk7by5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYSkpfXJldHVybiBvLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXtmb3IodmFyIG49dC5sZW5ndGgsbz1bXSxpPTA7aTxuO2krKylvW2k+Pj4xXXw9ZSh0LmNoYXJDb2RlQXQoaSk8PDE2LWklMioxNik7cmV0dXJuIHIuY3JlYXRlKG8sMipuKX19fSgpLHQuZW5jLlV0ZjE2fSl9LHsiLi9jb3JlIjo1Mn1dLDU1OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3NoYTEiKSx0KCIuL2htYWMiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3NoYTEiLCIuL2htYWMiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYixyPW4uQmFzZSxvPW4uV29yZEFycmF5LGk9ZS5hbGdvLGE9aS5NRDUscz1pLkV2cEtERj1yLmV4dGVuZCh7Y2ZnOnIuZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOmEsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbih0KXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQodCl9LGNvbXB1dGU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5jZmcscj1uLmhhc2hlci5jcmVhdGUoKSxpPW8uY3JlYXRlKCksYT1pLndvcmRzLHM9bi5rZXlTaXplLGM9bi5pdGVyYXRpb25zO2EubGVuZ3RoPHM7KXt1JiZyLnVwZGF0ZSh1KTt2YXIgdT1yLnVwZGF0ZSh0KS5maW5hbGl6ZShlKTtyLnJlc2V0KCk7Zm9yKHZhciBmPTE7ZjxjO2YrKyl1PXIuZmluYWxpemUodSksci5yZXNldCgpO2kuY29uY2F0KHUpfXJldHVybiBpLnNpZ0J5dGVzPTQqcyxpfX0pO2UuRXZwS0RGPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gcy5jcmVhdGUobikuY29tcHV0ZSh0LGUpfX0oKSx0LkV2cEtERn0pfSx7Ii4vY29yZSI6NTIsIi4vaG1hYyI6NTcsIi4vc2hhMSI6NzZ9XSw1NjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbj10LHI9bi5saWIuQ2lwaGVyUGFyYW1zLG89bi5lbmMuSGV4O24uZm9ybWF0LkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmNpcGhlcnRleHQudG9TdHJpbmcobyl9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBlPW8ucGFyc2UodCk7cmV0dXJuIHIuY3JlYXRlKHtjaXBoZXJ0ZXh0OmV9KX19fSgpLHQuZm9ybWF0LkhleH0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNTc6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYi5CYXNlLHI9ZS5lbmMuVXRmODtlLmFsZ28uSE1BQz1uLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3Q9dGhpcy5faGFzaGVyPW5ldyB0LmluaXQsInN0cmluZyI9PXR5cGVvZiBlJiYoZT1yLnBhcnNlKGUpKTt2YXIgbj10LmJsb2NrU2l6ZSxvPTQqbjtlLnNpZ0J5dGVzPm8mJihlPXQuZmluYWxpemUoZSkpLGUuY2xhbXAoKTtmb3IodmFyIGk9dGhpcy5fb0tleT1lLmNsb25lKCksYT10aGlzLl9pS2V5PWUuY2xvbmUoKSxzPWkud29yZHMsYz1hLndvcmRzLHU9MDt1PG47dSsrKXNbdV1ePTE1NDk1NTY4MjgsY1t1XV49OTA5NTIyNDg2O2kuc2lnQnl0ZXM9YS5zaWdCeXRlcz1vLHRoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9oYXNoZXI7dC5yZXNldCgpLHQudXBkYXRlKHRoaXMuX2lLZXkpfSx1cGRhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2hhc2hlci51cGRhdGUodCksdGhpc30sZmluYWxpemU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5faGFzaGVyLG49ZS5maW5hbGl6ZSh0KTtyZXR1cm4gZS5yZXNldCgpLGUuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChuKSl9fSl9KCl9KX0seyIuL2NvcmUiOjUyfV0sNTg6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4veDY0LWNvcmUiKSx0KCIuL2xpYi10eXBlZGFycmF5cyIpLHQoIi4vZW5jLXV0ZjE2IiksdCgiLi9lbmMtYmFzZTY0IiksdCgiLi9tZDUiKSx0KCIuL3NoYTEiKSx0KCIuL3NoYTI1NiIpLHQoIi4vc2hhMjI0IiksdCgiLi9zaGE1MTIiKSx0KCIuL3NoYTM4NCIpLHQoIi4vc2hhMyIpLHQoIi4vcmlwZW1kMTYwIiksdCgiLi9obWFjIiksdCgiLi9wYmtkZjIiKSx0KCIuL2V2cGtkZiIpLHQoIi4vY2lwaGVyLWNvcmUiKSx0KCIuL21vZGUtY2ZiIiksdCgiLi9tb2RlLWN0ciIpLHQoIi4vbW9kZS1jdHItZ2xhZG1hbiIpLHQoIi4vbW9kZS1vZmIiKSx0KCIuL21vZGUtZWNiIiksdCgiLi9wYWQtYW5zaXg5MjMiKSx0KCIuL3BhZC1pc28xMDEyNiIpLHQoIi4vcGFkLWlzbzk3OTcxIiksdCgiLi9wYWQtemVyb3BhZGRpbmciKSx0KCIuL3BhZC1ub3BhZGRpbmciKSx0KCIuL2Zvcm1hdC1oZXgiKSx0KCIuL2FlcyIpLHQoIi4vdHJpcGxlZGVzIiksdCgiLi9yYzQiKSx0KCIuL3JhYmJpdCIpLHQoIi4vcmFiYml0LWxlZ2FjeSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4veDY0LWNvcmUiLCIuL2xpYi10eXBlZGFycmF5cyIsIi4vZW5jLXV0ZjE2IiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL3NoYTEiLCIuL3NoYTI1NiIsIi4vc2hhMjI0IiwiLi9zaGE1MTIiLCIuL3NoYTM4NCIsIi4vc2hhMyIsIi4vcmlwZW1kMTYwIiwiLi9obWFjIiwiLi9wYmtkZjIiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiLCIuL21vZGUtY2ZiIiwiLi9tb2RlLWN0ciIsIi4vbW9kZS1jdHItZ2xhZG1hbiIsIi4vbW9kZS1vZmIiLCIuL21vZGUtZWNiIiwiLi9wYWQtYW5zaXg5MjMiLCIuL3BhZC1pc28xMDEyNiIsIi4vcGFkLWlzbzk3OTcxIiwiLi9wYWQtemVyb3BhZGRpbmciLCIuL3BhZC1ub3BhZGRpbmciLCIuL2Zvcm1hdC1oZXgiLCIuL2FlcyIsIi4vdHJpcGxlZGVzIiwiLi9yYzQiLCIuL3JhYmJpdCIsIi4vcmFiYml0LWxlZ2FjeSJdLG8pOnIuQ3J5cHRvSlM9byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdH0pfSx7Ii4vYWVzIjo1MCwiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTIsIi4vZW5jLWJhc2U2NCI6NTMsIi4vZW5jLXV0ZjE2Ijo1NCwiLi9ldnBrZGYiOjU1LCIuL2Zvcm1hdC1oZXgiOjU2LCIuL2htYWMiOjU3LCIuL2xpYi10eXBlZGFycmF5cyI6NTksIi4vbWQ1Ijo2MCwiLi9tb2RlLWNmYiI6NjEsIi4vbW9kZS1jdHIiOjYzLCIuL21vZGUtY3RyLWdsYWRtYW4iOjYyLCIuL21vZGUtZWNiIjo2NCwiLi9tb2RlLW9mYiI6NjUsIi4vcGFkLWFuc2l4OTIzIjo2NiwiLi9wYWQtaXNvMTAxMjYiOjY3LCIuL3BhZC1pc285Nzk3MSI6NjgsIi4vcGFkLW5vcGFkZGluZyI6NjksIi4vcGFkLXplcm9wYWRkaW5nIjo3MCwiLi9wYmtkZjIiOjcxLCIuL3JhYmJpdCI6NzMsIi4vcmFiYml0LWxlZ2FjeSI6NzIsIi4vcmM0Ijo3NCwiLi9yaXBlbWQxNjAiOjc1LCIuL3NoYTEiOjc2LCIuL3NoYTIyNCI6NzcsIi4vc2hhMjU2Ijo3OCwiLi9zaGEzIjo3OSwiLi9zaGEzODQiOjgwLCIuL3NoYTUxMiI6ODEsIi4vdHJpcGxlZGVzIjo4MiwiLi94NjQtY29yZSI6ODN9XSw1OTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIEFycmF5QnVmZmVyKXt2YXIgZT10LmxpYi5Xb3JkQXJyYXksbj1lLmluaXQ7KGUuaW5pdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih0PW5ldyBVaW50OEFycmF5KHQpKSwodCBpbnN0YW5jZW9mIEludDhBcnJheXx8InVuZGVmaW5lZCIhPXR5cGVvZiBVaW50OENsYW1wZWRBcnJheSYmdCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHx0IGluc3RhbmNlb2YgSW50MTZBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSYmKHQ9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtmb3IodmFyIGU9dC5ieXRlTGVuZ3RoLHI9W10sbz0wO288ZTtvKyspcltvPj4+Ml18PXRbb108PDI0LW8lNCo4O24uY2FsbCh0aGlzLHIsZSl9ZWxzZSBuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pLnByb3RvdHlwZT1lfX0oKSx0LmxpYi5Xb3JkQXJyYXl9KX0seyIuL2NvcmUiOjUyfV0sNjA6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsZSxuLHIsbyxpLGEpe3ZhciBzPXQrKGUmbnx+ZSZyKStvK2E7cmV0dXJuKHM8PGl8cz4+PjMyLWkpK2V9ZnVuY3Rpb24gcih0LGUsbixyLG8saSxhKXt2YXIgcz10KyhlJnJ8biZ+cikrbythO3JldHVybihzPDxpfHM+Pj4zMi1pKStlfWZ1bmN0aW9uIG8odCxlLG4scixvLGksYSl7dmFyIHM9dCsoZV5uXnIpK28rYTtyZXR1cm4oczw8aXxzPj4+MzItaSkrZX1mdW5jdGlvbiBpKHQsZSxuLHIsbyxpLGEpe3ZhciBzPXQrKG5eKGV8fnIpKStvK2E7cmV0dXJuKHM8PGl8cz4+PjMyLWkpK2V9dmFyIGE9dCxzPWEubGliLGM9cy5Xb3JkQXJyYXksdT1zLkhhc2hlcixmPWEuYWxnbyxsPVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8NjQ7dCsrKWxbdF09NDI5NDk2NzI5NiplLmFicyhlLnNpbih0KzEpKXwwfSgpO3ZhciBwPWYuTUQ1PXUuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IGMuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgYT0wO2E8MTY7YSsrKXt2YXIgcz1lK2EsYz10W3NdO3Rbc109MTY3MTE5MzUmKGM8PDh8Yz4+PjI0KXw0Mjc4MjU1MzYwJihjPDwyNHxjPj4+OCl9dmFyIHU9dGhpcy5faGFzaC53b3JkcyxmPXRbZSswXSxwPXRbZSsxXSxoPXRbZSsyXSxkPXRbZSszXSxtPXRbZSs0XSx5PXRbZSs1XSxnPXRbZSs2XSx2PXRbZSs3XSxiPXRbZSs4XSxfPXRbZSs5XSx3PXRbZSsxMF0seD10W2UrMTFdLGs9dFtlKzEyXSxCPXRbZSsxM10sUz10W2UrMTRdLEE9dFtlKzE1XSxDPXVbMF0sRj11WzFdLE89dVsyXSxJPXVbM107Rj1pKEY9aShGPWkoRj1pKEY9byhGPW8oRj1vKEY9byhGPXIoRj1yKEY9cihGPXIoRj1uKEY9bihGPW4oRj1uKEYsTz1uKE8sST1uKEksQz1uKEMsRixPLEksZiw3LGxbMF0pLEYsTyxwLDEyLGxbMV0pLEMsRixoLDE3LGxbMl0pLEksQyxkLDIyLGxbM10pLE89bihPLEk9bihJLEM9bihDLEYsTyxJLG0sNyxsWzRdKSxGLE8seSwxMixsWzVdKSxDLEYsZywxNyxsWzZdKSxJLEMsdiwyMixsWzddKSxPPW4oTyxJPW4oSSxDPW4oQyxGLE8sSSxiLDcsbFs4XSksRixPLF8sMTIsbFs5XSksQyxGLHcsMTcsbFsxMF0pLEksQyx4LDIyLGxbMTFdKSxPPW4oTyxJPW4oSSxDPW4oQyxGLE8sSSxrLDcsbFsxMl0pLEYsTyxCLDEyLGxbMTNdKSxDLEYsUywxNyxsWzE0XSksSSxDLEEsMjIsbFsxNV0pLE89cihPLEk9cihJLEM9cihDLEYsTyxJLHAsNSxsWzE2XSksRixPLGcsOSxsWzE3XSksQyxGLHgsMTQsbFsxOF0pLEksQyxmLDIwLGxbMTldKSxPPXIoTyxJPXIoSSxDPXIoQyxGLE8sSSx5LDUsbFsyMF0pLEYsTyx3LDksbFsyMV0pLEMsRixBLDE0LGxbMjJdKSxJLEMsbSwyMCxsWzIzXSksTz1yKE8sST1yKEksQz1yKEMsRixPLEksXyw1LGxbMjRdKSxGLE8sUyw5LGxbMjVdKSxDLEYsZCwxNCxsWzI2XSksSSxDLGIsMjAsbFsyN10pLE89cihPLEk9cihJLEM9cihDLEYsTyxJLEIsNSxsWzI4XSksRixPLGgsOSxsWzI5XSksQyxGLHYsMTQsbFszMF0pLEksQyxrLDIwLGxbMzFdKSxPPW8oTyxJPW8oSSxDPW8oQyxGLE8sSSx5LDQsbFszMl0pLEYsTyxiLDExLGxbMzNdKSxDLEYseCwxNixsWzM0XSksSSxDLFMsMjMsbFszNV0pLE89byhPLEk9byhJLEM9byhDLEYsTyxJLHAsNCxsWzM2XSksRixPLG0sMTEsbFszN10pLEMsRix2LDE2LGxbMzhdKSxJLEMsdywyMyxsWzM5XSksTz1vKE8sST1vKEksQz1vKEMsRixPLEksQiw0LGxbNDBdKSxGLE8sZiwxMSxsWzQxXSksQyxGLGQsMTYsbFs0Ml0pLEksQyxnLDIzLGxbNDNdKSxPPW8oTyxJPW8oSSxDPW8oQyxGLE8sSSxfLDQsbFs0NF0pLEYsTyxrLDExLGxbNDVdKSxDLEYsQSwxNixsWzQ2XSksSSxDLGgsMjMsbFs0N10pLE89aShPLEk9aShJLEM9aShDLEYsTyxJLGYsNixsWzQ4XSksRixPLHYsMTAsbFs0OV0pLEMsRixTLDE1LGxbNTBdKSxJLEMseSwyMSxsWzUxXSksTz1pKE8sST1pKEksQz1pKEMsRixPLEksayw2LGxbNTJdKSxGLE8sZCwxMCxsWzUzXSksQyxGLHcsMTUsbFs1NF0pLEksQyxwLDIxLGxbNTVdKSxPPWkoTyxJPWkoSSxDPWkoQyxGLE8sSSxiLDYsbFs1Nl0pLEYsTyxBLDEwLGxbNTddKSxDLEYsZywxNSxsWzU4XSksSSxDLEIsMjEsbFs1OV0pLE89aShPLEk9aShJLEM9aShDLEYsTyxJLG0sNixsWzYwXSksRixPLHgsMTAsbFs2MV0pLEMsRixoLDE1LGxbNjJdKSxJLEMsXywyMSxsWzYzXSksdVswXT11WzBdK0N8MCx1WzFdPXVbMV0rRnwwLHVbMl09dVsyXStPfDAsdVszXT11WzNdK0l8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLG49dC53b3JkcyxyPTgqdGhpcy5fbkRhdGFCeXRlcyxvPTgqdC5zaWdCeXRlcztuW28+Pj41XXw9MTI4PDwyNC1vJTMyO3ZhciBpPWUuZmxvb3Ioci80Mjk0OTY3Mjk2KSxhPXI7blsxNSsobys2ND4+Pjk8PDQpXT0xNjcxMTkzNSYoaTw8OHxpPj4+MjQpfDQyNzgyNTUzNjAmKGk8PDI0fGk+Pj44KSxuWzE0KyhvKzY0Pj4+OTw8NCldPTE2NzExOTM1JihhPDw4fGE+Pj4yNCl8NDI3ODI1NTM2MCYoYTw8MjR8YT4+PjgpLHQuc2lnQnl0ZXM9NCoobi5sZW5ndGgrMSksdGhpcy5fcHJvY2VzcygpO2Zvcih2YXIgcz10aGlzLl9oYXNoLGM9cy53b3Jkcyx1PTA7dTw0O3UrKyl7dmFyIGY9Y1t1XTtjW3VdPTE2NzExOTM1JihmPDw4fGY+Pj4yNCl8NDI3ODI1NTM2MCYoZjw8MjR8Zj4+PjgpfXJldHVybiBzfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PXUuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTthLk1ENT11Ll9jcmVhdGVIZWxwZXIocCksYS5IbWFjTUQ1PXUuX2NyZWF0ZUhtYWNIZWxwZXIocCl9KE1hdGgpLHQuTUQ1fSl9LHsiLi9jb3JlIjo1Mn1dLDYxOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHQubW9kZS5DRkI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsZSxuLHIpe3ZhciBvPXRoaXMuX2l2O2lmKG8pe2k9by5zbGljZSgwKTt0aGlzLl9pdj12b2lkIDB9ZWxzZSB2YXIgaT10aGlzLl9wcmV2QmxvY2s7ci5lbmNyeXB0QmxvY2soaSwwKTtmb3IodmFyIGE9MDthPG47YSsrKXRbZSthXV49aVthXX12YXIgbj10LmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7cmV0dXJuIG4uRW5jcnlwdG9yPW4uZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzLl9jaXBoZXIsbz1yLmJsb2NrU2l6ZTtlLmNhbGwodGhpcyx0LG4sbyxyKSx0aGlzLl9wcmV2QmxvY2s9dC5zbGljZShuLG4rbyl9fSksbi5EZWNyeXB0b3I9bi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LG4pe3ZhciByPXRoaXMuX2NpcGhlcixvPXIuYmxvY2tTaXplLGk9dC5zbGljZShuLG4rbyk7ZS5jYWxsKHRoaXMsdCxuLG8sciksdGhpcy5fcHJldkJsb2NrPWl9fSksbn0oKSx0Lm1vZGUuQ0ZCfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2MjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuQ1RSR2xhZG1hbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7aWYoMjU1PT0odD4+MjQmMjU1KSl7dmFyIGU9dD4+MTYmMjU1LG49dD4+OCYyNTUscj0yNTUmdDsyNTU9PT1lPyhlPTAsMjU1PT09bj8obj0wLDI1NT09PXI/cj0wOisrcik6KytuKTorK2UsdD0wLHQrPWU8PDE2LHQrPW48PDgsdCs9cn1lbHNlIHQrPTE8PDI0O3JldHVybiB0fWZ1bmN0aW9uIG4odCl7cmV0dXJuIDA9PT0odFswXT1lKHRbMF0pKSYmKHRbMV09ZSh0WzFdKSksdH12YXIgcj10LmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCksbz1yLkVuY3J5cHRvcj1yLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5fY2lwaGVyLG89ci5ibG9ja1NpemUsaT10aGlzLl9pdixhPXRoaXMuX2NvdW50ZXI7aSYmKGE9dGhpcy5fY291bnRlcj1pLnNsaWNlKDApLHRoaXMuX2l2PXZvaWQgMCksbihhKTt2YXIgcz1hLnNsaWNlKDApO3IuZW5jcnlwdEJsb2NrKHMsMCk7Zm9yKHZhciBjPTA7YzxvO2MrKyl0W2UrY11ePXNbY119fSk7cmV0dXJuIHIuRGVjcnlwdG9yPW8scn0oKSx0Lm1vZGUuQ1RSR2xhZG1hbn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjM6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tb2RlLkNUUj1mdW5jdGlvbigpe3ZhciBlPXQubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKSxuPWUuRW5jcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9jaXBoZXIscj1uLmJsb2NrU2l6ZSxvPXRoaXMuX2l2LGk9dGhpcy5fY291bnRlcjtvJiYoaT10aGlzLl9jb3VudGVyPW8uc2xpY2UoMCksdGhpcy5faXY9dm9pZCAwKTt2YXIgYT1pLnNsaWNlKDApO24uZW5jcnlwdEJsb2NrKGEsMCksaVtyLTFdPWlbci0xXSsxfDA7Zm9yKHZhciBzPTA7czxyO3MrKyl0W2Urc11ePWFbc119fSk7cmV0dXJuIGUuRGVjcnlwdG9yPW4sZX0oKSx0Lm1vZGUuQ1RSfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2NDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuRUNCPWZ1bmN0aW9uKCl7dmFyIGU9dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO3JldHVybiBlLkVuY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0LGUpfX0pLGUuRGVjcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHQsZSl9fSksZX0oKSx0Lm1vZGUuRUNCfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2NTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuT0ZCPWZ1bmN0aW9uKCl7dmFyIGU9dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpLG49ZS5FbmNyeXB0b3I9ZS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2NpcGhlcixyPW4uYmxvY2tTaXplLG89dGhpcy5faXYsaT10aGlzLl9rZXlzdHJlYW07byYmKGk9dGhpcy5fa2V5c3RyZWFtPW8uc2xpY2UoMCksdGhpcy5faXY9dm9pZCAwKSxuLmVuY3J5cHRCbG9jayhpLDApO2Zvcih2YXIgYT0wO2E8cjthKyspdFtlK2FdXj1pW2FdfX0pO3JldHVybiBlLkRlY3J5cHRvcj1uLGV9KCksdC5tb2RlLk9GQn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjY6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuQW5zaVg5MjM9e3BhZDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuc2lnQnl0ZXMscj00KmUsbz1yLW4lcixpPW4rby0xO3QuY2xhbXAoKSx0LndvcmRzW2k+Pj4yXXw9bzw8MjQtaSU0KjgsdC5zaWdCeXRlcys9b30sdW5wYWQ6ZnVuY3Rpb24odCl7dmFyIGU9MjU1JnQud29yZHNbdC5zaWdCeXRlcy0xPj4+Ml07dC5zaWdCeXRlcy09ZX19LHQucGFkLkFuc2l4OTIzfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2NzpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZC5Jc28xMDEyNj17cGFkOmZ1bmN0aW9uKGUsbil7dmFyIHI9NCpuLG89ci1lLnNpZ0J5dGVzJXI7ZS5jb25jYXQodC5saWIuV29yZEFycmF5LnJhbmRvbShvLTEpKS5jb25jYXQodC5saWIuV29yZEFycmF5LmNyZWF0ZShbbzw8MjRdLDEpKX0sdW5wYWQ6ZnVuY3Rpb24odCl7dmFyIGU9MjU1JnQud29yZHNbdC5zaWdCeXRlcy0xPj4+Ml07dC5zaWdCeXRlcy09ZX19LHQucGFkLklzbzEwMTI2fSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2ODpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZC5Jc285Nzk3MT17cGFkOmZ1bmN0aW9uKGUsbil7ZS5jb25jYXQodC5saWIuV29yZEFycmF5LmNyZWF0ZShbMjE0NzQ4MzY0OF0sMSkpLHQucGFkLlplcm9QYWRkaW5nLnBhZChlLG4pfSx1bnBhZDpmdW5jdGlvbihlKXt0LnBhZC5aZXJvUGFkZGluZy51bnBhZChlKSxlLnNpZ0J5dGVzLS19fSx0LnBhZC5Jc285Nzk3MX0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjk6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuTm9QYWRkaW5nPXtwYWQ6ZnVuY3Rpb24oKXt9LHVucGFkOmZ1bmN0aW9uKCl7fX0sdC5wYWQuTm9QYWRkaW5nfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw3MDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZC5aZXJvUGFkZGluZz17cGFkOmZ1bmN0aW9uKHQsZSl7dmFyIG49NCplO3QuY2xhbXAoKSx0LnNpZ0J5dGVzKz1uLSh0LnNpZ0J5dGVzJW58fG4pfSx1bnBhZDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC53b3JkcyxuPXQuc2lnQnl0ZXMtMTshKGVbbj4+PjJdPj4+MjQtbiU0KjgmMjU1KTspbi0tO3Quc2lnQnl0ZXM9bisxfX0sdC5wYWQuWmVyb1BhZGRpbmd9KX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1Mn1dLDcxOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3NoYTEiKSx0KCIuL2htYWMiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3NoYTEiLCIuL2htYWMiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYixyPW4uQmFzZSxvPW4uV29yZEFycmF5LGk9ZS5hbGdvLGE9aS5TSEExLHM9aS5ITUFDLGM9aS5QQktERjI9ci5leHRlbmQoe2NmZzpyLmV4dGVuZCh7a2V5U2l6ZTo0LGhhc2hlcjphLGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKHQpfSxjb21wdXRlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuY2ZnLHI9cy5jcmVhdGUobi5oYXNoZXIsdCksaT1vLmNyZWF0ZSgpLGE9by5jcmVhdGUoWzFdKSxjPWkud29yZHMsdT1hLndvcmRzLGY9bi5rZXlTaXplLGw9bi5pdGVyYXRpb25zO2MubGVuZ3RoPGY7KXt2YXIgcD1yLnVwZGF0ZShlKS5maW5hbGl6ZShhKTtyLnJlc2V0KCk7Zm9yKHZhciBoPXAud29yZHMsZD1oLmxlbmd0aCxtPXAseT0xO3k8bDt5Kyspe209ci5maW5hbGl6ZShtKSxyLnJlc2V0KCk7Zm9yKHZhciBnPW0ud29yZHMsdj0wO3Y8ZDt2KyspaFt2XV49Z1t2XX1pLmNvbmNhdChwKSx1WzBdKyt9cmV0dXJuIGkuc2lnQnl0ZXM9NCpmLGl9fSk7ZS5QQktERjI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBjLmNyZWF0ZShuKS5jb21wdXRlKHQsZSl9fSgpLHQuUEJLREYyfSl9LHsiLi9jb3JlIjo1MiwiLi9obWFjIjo1NywiLi9zaGExIjo3Nn1dLDcyOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXRoaXMuX1gsZT10aGlzLl9DLG49MDtuPDg7bisrKWlbbl09ZVtuXTtlWzBdPWVbMF0rMTI5NTMwNzU5Nyt0aGlzLl9ifDAsZVsxXT1lWzFdKzM1NDUwNTIzNzErKGVbMF0+Pj4wPGlbMF0+Pj4wPzE6MCl8MCxlWzJdPWVbMl0rODg2MjYzMDkyKyhlWzFdPj4+MDxpWzFdPj4+MD8xOjApfDAsZVszXT1lWzNdKzEyOTUzMDc1OTcrKGVbMl0+Pj4wPGlbMl0+Pj4wPzE6MCl8MCxlWzRdPWVbNF0rMzU0NTA1MjM3MSsoZVszXT4+PjA8aVszXT4+PjA/MTowKXwwLGVbNV09ZVs1XSs4ODYyNjMwOTIrKGVbNF0+Pj4wPGlbNF0+Pj4wPzE6MCl8MCxlWzZdPWVbNl0rMTI5NTMwNzU5NysoZVs1XT4+PjA8aVs1XT4+PjA/MTowKXwwLGVbN109ZVs3XSszNTQ1MDUyMzcxKyhlWzZdPj4+MDxpWzZdPj4+MD8xOjApfDAsdGhpcy5fYj1lWzddPj4+MDxpWzddPj4+MD8xOjA7Zm9yKG49MDtuPDg7bisrKXt2YXIgcj10W25dK2Vbbl0sbz02NTUzNSZyLHM9cj4+PjE2LGM9KChvKm8+Pj4xNykrbypzPj4+MTUpK3Mqcyx1PSgoNDI5NDkwMTc2MCZyKSpyfDApKygoNjU1MzUmcikqcnwwKTthW25dPWNedX10WzBdPWFbMF0rKGFbN108PDE2fGFbN10+Pj4xNikrKGFbNl08PDE2fGFbNl0+Pj4xNil8MCx0WzFdPWFbMV0rKGFbMF08PDh8YVswXT4+PjI0KSthWzddfDAsdFsyXT1hWzJdKyhhWzFdPDwxNnxhWzFdPj4+MTYpKyhhWzBdPDwxNnxhWzBdPj4+MTYpfDAsdFszXT1hWzNdKyhhWzJdPDw4fGFbMl0+Pj4yNCkrYVsxXXwwLHRbNF09YVs0XSsoYVszXTw8MTZ8YVszXT4+PjE2KSsoYVsyXTw8MTZ8YVsyXT4+PjE2KXwwLHRbNV09YVs1XSsoYVs0XTw8OHxhWzRdPj4+MjQpK2FbM118MCx0WzZdPWFbNl0rKGFbNV08PDE2fGFbNV0+Pj4xNikrKGFbNF08PDE2fGFbNF0+Pj4xNil8MCx0WzddPWFbN10rKGFbNl08PDh8YVs2XT4+PjI0KSthWzVdfDB9dmFyIG49dCxyPW4ubGliLlN0cmVhbUNpcGhlcixvPVtdLGk9W10sYT1bXSxzPW4uYWxnby5SYWJiaXRMZWdhY3k9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fa2V5LndvcmRzLG49dGhpcy5jZmcuaXYscj10aGlzLl9YPVt0WzBdLHRbM108PDE2fHRbMl0+Pj4xNix0WzFdLHRbMF08PDE2fHRbM10+Pj4xNix0WzJdLHRbMV08PDE2fHRbMF0+Pj4xNix0WzNdLHRbMl08PDE2fHRbMV0+Pj4xNl0sbz10aGlzLl9DPVt0WzJdPDwxNnx0WzJdPj4+MTYsNDI5NDkwMTc2MCZ0WzBdfDY1NTM1JnRbMV0sdFszXTw8MTZ8dFszXT4+PjE2LDQyOTQ5MDE3NjAmdFsxXXw2NTUzNSZ0WzJdLHRbMF08PDE2fHRbMF0+Pj4xNiw0Mjk0OTAxNzYwJnRbMl18NjU1MzUmdFszXSx0WzFdPDwxNnx0WzFdPj4+MTYsNDI5NDkwMTc2MCZ0WzNdfDY1NTM1JnRbMF1dO3RoaXMuX2I9MDtmb3IocD0wO3A8NDtwKyspZS5jYWxsKHRoaXMpO2ZvcihwPTA7cDw4O3ArKylvW3BdXj1yW3ArNCY3XTtpZihuKXt2YXIgaT1uLndvcmRzLGE9aVswXSxzPWlbMV0sYz0xNjcxMTkzNSYoYTw8OHxhPj4+MjQpfDQyNzgyNTUzNjAmKGE8PDI0fGE+Pj44KSx1PTE2NzExOTM1JihzPDw4fHM+Pj4yNCl8NDI3ODI1NTM2MCYoczw8MjR8cz4+PjgpLGY9Yz4+PjE2fDQyOTQ5MDE3NjAmdSxsPXU8PDE2fDY1NTM1JmM7b1swXV49YyxvWzFdXj1mLG9bMl1ePXUsb1szXV49bCxvWzRdXj1jLG9bNV1ePWYsb1s2XV49dSxvWzddXj1sO2Zvcih2YXIgcD0wO3A8NDtwKyspZS5jYWxsKHRoaXMpfX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5fWDtlLmNhbGwodGhpcyksb1swXT1yWzBdXnJbNV0+Pj4xNl5yWzNdPDwxNixvWzFdPXJbMl1ecls3XT4+PjE2XnJbNV08PDE2LG9bMl09cls0XV5yWzFdPj4+MTZecls3XTw8MTYsb1szXT1yWzZdXnJbM10+Pj4xNl5yWzFdPDwxNjtmb3IodmFyIGk9MDtpPDQ7aSsrKW9baV09MTY3MTE5MzUmKG9baV08PDh8b1tpXT4+PjI0KXw0Mjc4MjU1MzYwJihvW2ldPDwyNHxvW2ldPj4+OCksdFtuK2ldXj1vW2ldfSxibG9ja1NpemU6NCxpdlNpemU6Mn0pO24uUmFiYml0TGVnYWN5PXIuX2NyZWF0ZUhlbHBlcihzKX0oKSx0LlJhYmJpdExlZ2FjeX0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyLCIuL2VuYy1iYXNlNjQiOjUzLCIuL2V2cGtkZiI6NTUsIi4vbWQ1Ijo2MH1dLDczOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXRoaXMuX1gsZT10aGlzLl9DLG49MDtuPDg7bisrKWlbbl09ZVtuXTtlWzBdPWVbMF0rMTI5NTMwNzU5Nyt0aGlzLl9ifDAsZVsxXT1lWzFdKzM1NDUwNTIzNzErKGVbMF0+Pj4wPGlbMF0+Pj4wPzE6MCl8MCxlWzJdPWVbMl0rODg2MjYzMDkyKyhlWzFdPj4+MDxpWzFdPj4+MD8xOjApfDAsZVszXT1lWzNdKzEyOTUzMDc1OTcrKGVbMl0+Pj4wPGlbMl0+Pj4wPzE6MCl8MCxlWzRdPWVbNF0rMzU0NTA1MjM3MSsoZVszXT4+PjA8aVszXT4+PjA/MTowKXwwLGVbNV09ZVs1XSs4ODYyNjMwOTIrKGVbNF0+Pj4wPGlbNF0+Pj4wPzE6MCl8MCxlWzZdPWVbNl0rMTI5NTMwNzU5NysoZVs1XT4+PjA8aVs1XT4+PjA/MTowKXwwLGVbN109ZVs3XSszNTQ1MDUyMzcxKyhlWzZdPj4+MDxpWzZdPj4+MD8xOjApfDAsdGhpcy5fYj1lWzddPj4+MDxpWzddPj4+MD8xOjA7Zm9yKG49MDtuPDg7bisrKXt2YXIgcj10W25dK2Vbbl0sbz02NTUzNSZyLHM9cj4+PjE2LGM9KChvKm8+Pj4xNykrbypzPj4+MTUpK3Mqcyx1PSgoNDI5NDkwMTc2MCZyKSpyfDApKygoNjU1MzUmcikqcnwwKTthW25dPWNedX10WzBdPWFbMF0rKGFbN108PDE2fGFbN10+Pj4xNikrKGFbNl08PDE2fGFbNl0+Pj4xNil8MCx0WzFdPWFbMV0rKGFbMF08PDh8YVswXT4+PjI0KSthWzddfDAsdFsyXT1hWzJdKyhhWzFdPDwxNnxhWzFdPj4+MTYpKyhhWzBdPDwxNnxhWzBdPj4+MTYpfDAsdFszXT1hWzNdKyhhWzJdPDw4fGFbMl0+Pj4yNCkrYVsxXXwwLHRbNF09YVs0XSsoYVszXTw8MTZ8YVszXT4+PjE2KSsoYVsyXTw8MTZ8YVsyXT4+PjE2KXwwLHRbNV09YVs1XSsoYVs0XTw8OHxhWzRdPj4+MjQpK2FbM118MCx0WzZdPWFbNl0rKGFbNV08PDE2fGFbNV0+Pj4xNikrKGFbNF08PDE2fGFbNF0+Pj4xNil8MCx0WzddPWFbN10rKGFbNl08PDh8YVs2XT4+PjI0KSthWzVdfDB9dmFyIG49dCxyPW4ubGliLlN0cmVhbUNpcGhlcixvPVtdLGk9W10sYT1bXSxzPW4uYWxnby5SYWJiaXQ9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2tleS53b3JkcyxuPXRoaXMuY2ZnLml2LHI9MDtyPDQ7cisrKXRbcl09MTY3MTE5MzUmKHRbcl08PDh8dFtyXT4+PjI0KXw0Mjc4MjU1MzYwJih0W3JdPDwyNHx0W3JdPj4+OCk7dmFyIG89dGhpcy5fWD1bdFswXSx0WzNdPDwxNnx0WzJdPj4+MTYsdFsxXSx0WzBdPDwxNnx0WzNdPj4+MTYsdFsyXSx0WzFdPDwxNnx0WzBdPj4+MTYsdFszXSx0WzJdPDwxNnx0WzFdPj4+MTZdLGk9dGhpcy5fQz1bdFsyXTw8MTZ8dFsyXT4+PjE2LDQyOTQ5MDE3NjAmdFswXXw2NTUzNSZ0WzFdLHRbM108PDE2fHRbM10+Pj4xNiw0Mjk0OTAxNzYwJnRbMV18NjU1MzUmdFsyXSx0WzBdPDwxNnx0WzBdPj4+MTYsNDI5NDkwMTc2MCZ0WzJdfDY1NTM1JnRbM10sdFsxXTw8MTZ8dFsxXT4+PjE2LDQyOTQ5MDE3NjAmdFszXXw2NTUzNSZ0WzBdXTt0aGlzLl9iPTA7Zm9yKHI9MDtyPDQ7cisrKWUuY2FsbCh0aGlzKTtmb3Iocj0wO3I8ODtyKyspaVtyXV49b1tyKzQmN107aWYobil7dmFyIGE9bi53b3JkcyxzPWFbMF0sYz1hWzFdLHU9MTY3MTE5MzUmKHM8PDh8cz4+PjI0KXw0Mjc4MjU1MzYwJihzPDwyNHxzPj4+OCksZj0xNjcxMTkzNSYoYzw8OHxjPj4+MjQpfDQyNzgyNTUzNjAmKGM8PDI0fGM+Pj44KSxsPXU+Pj4xNnw0Mjk0OTAxNzYwJmYscD1mPDwxNnw2NTUzNSZ1O2lbMF1ePXUsaVsxXV49bCxpWzJdXj1mLGlbM11ePXAsaVs0XV49dSxpWzVdXj1sLGlbNl1ePWYsaVs3XV49cDtmb3Iocj0wO3I8NDtyKyspZS5jYWxsKHRoaXMpfX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5fWDtlLmNhbGwodGhpcyksb1swXT1yWzBdXnJbNV0+Pj4xNl5yWzNdPDwxNixvWzFdPXJbMl1ecls3XT4+PjE2XnJbNV08PDE2LG9bMl09cls0XV5yWzFdPj4+MTZecls3XTw8MTYsb1szXT1yWzZdXnJbM10+Pj4xNl5yWzFdPDwxNjtmb3IodmFyIGk9MDtpPDQ7aSsrKW9baV09MTY3MTE5MzUmKG9baV08PDh8b1tpXT4+PjI0KXw0Mjc4MjU1MzYwJihvW2ldPDwyNHxvW2ldPj4+OCksdFtuK2ldXj1vW2ldfSxibG9ja1NpemU6NCxpdlNpemU6Mn0pO24uUmFiYml0PXIuX2NyZWF0ZUhlbHBlcihzKX0oKSx0LlJhYmJpdH0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyLCIuL2VuYy1iYXNlNjQiOjUzLCIuL2V2cGtkZiI6NTUsIi4vbWQ1Ijo2MH1dLDc0OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXRoaXMuX1MsZT10aGlzLl9pLG49dGhpcy5faixyPTAsbz0wO288NDtvKyspe249KG4rdFtlPShlKzEpJTI1Nl0pJTI1Njt2YXIgaT10W2VdO3RbZV09dFtuXSx0W25dPWkscnw9dFsodFtlXSt0W25dKSUyNTZdPDwyNC04Km99cmV0dXJuIHRoaXMuX2k9ZSx0aGlzLl9qPW4scn12YXIgbj10LHI9bi5saWIuU3RyZWFtQ2lwaGVyLG89bi5hbGdvLGk9by5SQzQ9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2tleSxlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9dGhpcy5fUz1bXSxvPTA7bzwyNTY7bysrKXJbb109bztmb3IodmFyIG89MCxpPTA7bzwyNTY7bysrKXt2YXIgYT1vJW4scz1lW2E+Pj4yXT4+PjI0LWElNCo4JjI1NTtpPShpK3Jbb10rcyklMjU2O3ZhciBjPXJbb107cltvXT1yW2ldLHJbaV09Y310aGlzLl9pPXRoaXMuX2o9MH0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dFtuXV49ZS5jYWxsKHRoaXMpfSxrZXlTaXplOjgsaXZTaXplOjB9KTtuLlJDND1yLl9jcmVhdGVIZWxwZXIoaSk7dmFyIGE9by5SQzREcm9wPWkuZXh0ZW5kKHtjZmc6aS5jZmcuZXh0ZW5kKHtkcm9wOjE5Mn0pLF9kb1Jlc2V0OmZ1bmN0aW9uKCl7aS5fZG9SZXNldC5jYWxsKHRoaXMpO2Zvcih2YXIgdD10aGlzLmNmZy5kcm9wO3Q+MDt0LS0pZS5jYWxsKHRoaXMpfX0pO24uUkM0RHJvcD1yLl9jcmVhdGVIZWxwZXIoYSl9KCksdC5SQzR9KX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1MiwiLi9lbmMtYmFzZTY0Ijo1MywiLi9ldnBrZGYiOjU1LCIuL21kNSI6NjB9XSw3NTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCxlLG4pe3JldHVybiB0XmVebn1mdW5jdGlvbiByKHQsZSxuKXtyZXR1cm4gdCZlfH50Jm59ZnVuY3Rpb24gbyh0LGUsbil7cmV0dXJuKHR8fmUpXm59ZnVuY3Rpb24gaSh0LGUsbil7cmV0dXJuIHQmbnxlJn5ufWZ1bmN0aW9uIGEodCxlLG4pe3JldHVybiB0XihlfH5uKX1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIHQ8PGV8dD4+PjMyLWV9dmFyIGM9dCx1PWMubGliLGY9dS5Xb3JkQXJyYXksbD11Lkhhc2hlcixwPWMuYWxnbyxoPWYuY3JlYXRlKFswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDcsNCwxMywxLDEwLDYsMTUsMywxMiwwLDksNSwyLDE0LDExLDgsMywxMCwxNCw0LDksMTUsOCwxLDIsNywwLDYsMTMsMTEsNSwxMiwxLDksMTEsMTAsMCw4LDEyLDQsMTMsMyw3LDE1LDE0LDUsNiwyLDQsMCw1LDksNywxMiwyLDEwLDE0LDEsMyw4LDExLDYsMTUsMTNdKSxkPWYuY3JlYXRlKFs1LDE0LDcsMCw5LDIsMTEsNCwxMyw2LDE1LDgsMSwxMCwzLDEyLDYsMTEsMyw3LDAsMTMsNSwxMCwxNCwxNSw4LDEyLDQsOSwxLDIsMTUsNSwxLDMsNywxNCw2LDksMTEsOCwxMiwyLDEwLDAsNCwxMyw4LDYsNCwxLDMsMTEsMTUsMCw1LDEyLDIsMTMsOSw3LDEwLDE0LDEyLDE1LDEwLDQsMSw1LDgsNyw2LDIsMTMsMTQsMCwzLDksMTFdKSxtPWYuY3JlYXRlKFsxMSwxNCwxNSwxMiw1LDgsNyw5LDExLDEzLDE0LDE1LDYsNyw5LDgsNyw2LDgsMTMsMTEsOSw3LDE1LDcsMTIsMTUsOSwxMSw3LDEzLDEyLDExLDEzLDYsNywxNCw5LDEzLDE1LDE0LDgsMTMsNiw1LDEyLDcsNSwxMSwxMiwxNCwxNSwxNCwxNSw5LDgsOSwxNCw1LDYsOCw2LDUsMTIsOSwxNSw1LDExLDYsOCwxMywxMiw1LDEyLDEzLDE0LDExLDgsNSw2XSkseT1mLmNyZWF0ZShbOCw5LDksMTEsMTMsMTUsMTUsNSw3LDcsOCwxMSwxNCwxNCwxMiw2LDksMTMsMTUsNywxMiw4LDksMTEsNyw3LDEyLDcsNiwxNSwxMywxMSw5LDcsMTUsMTEsOCw2LDYsMTQsMTIsMTMsNSwxNCwxMywxMyw3LDUsMTUsNSw4LDExLDE0LDE0LDYsMTQsNiw5LDEyLDksMTIsNSwxNSw4LDgsNSwxMiw5LDEyLDUsMTQsNiw4LDEzLDYsNSwxNSwxMywxMSwxMV0pLGc9Zi5jcmVhdGUoWzAsMTUxODUwMDI0OSwxODU5Nzc1MzkzLDI0MDA5NTk3MDgsMjg0MDg1MzgzOF0pLHY9Zi5jcmVhdGUoWzEzNTI4Mjk5MjYsMTU0ODYwMzY4NCwxODM2MDcyNjkxLDIwNTM5OTQyMTcsMF0pLGI9cC5SSVBFTUQxNjA9bC5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1mLmNyZWF0ZShbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKEQ9MDtEPDE2O0QrKyl7dmFyIGM9ZStELHU9dFtjXTt0W2NdPTE2NzExOTM1Jih1PDw4fHU+Pj4yNCl8NDI3ODI1NTM2MCYodTw8MjR8dT4+PjgpfXZhciBmLGwscCxiLF8sdyx4LGssQixTLEE9dGhpcy5faGFzaC53b3JkcyxDPWcud29yZHMsRj12LndvcmRzLE89aC53b3JkcyxJPWQud29yZHMsTj1tLndvcmRzLFQ9eS53b3Jkczt3PWY9QVswXSx4PWw9QVsxXSxrPXA9QVsyXSxCPWI9QVszXSxTPV89QVs0XTtmb3IodmFyIFAsRD0wO0Q8ODA7RCs9MSlQPWYrdFtlK09bRF1dfDAsUCs9RDwxNj9uKGwscCxiKStDWzBdOkQ8MzI/cihsLHAsYikrQ1sxXTpEPDQ4P28obCxwLGIpK0NbMl06RDw2ND9pKGwscCxiKStDWzNdOmEobCxwLGIpK0NbNF0sUD0oUD1zKFB8PTAsTltEXSkpK198MCxmPV8sXz1iLGI9cyhwLDEwKSxwPWwsbD1QLFA9dyt0W2UrSVtEXV18MCxQKz1EPDE2P2EoeCxrLEIpK0ZbMF06RDwzMj9pKHgsayxCKStGWzFdOkQ8NDg/byh4LGssQikrRlsyXTpEPDY0P3IoeCxrLEIpK0ZbM106bih4LGssQikrRls0XSxQPShQPXMoUHw9MCxUW0RdKSkrU3wwLHc9UyxTPUIsQj1zKGssMTApLGs9eCx4PVA7UD1BWzFdK3ArQnwwLEFbMV09QVsyXStiK1N8MCxBWzJdPUFbM10rXyt3fDAsQVszXT1BWzRdK2YreHwwLEFbNF09QVswXStsK2t8MCxBWzBdPVB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxlPXQud29yZHMsbj04KnRoaXMuX25EYXRhQnl0ZXMscj04KnQuc2lnQnl0ZXM7ZVtyPj4+NV18PTEyODw8MjQtciUzMixlWzE0KyhyKzY0Pj4+OTw8NCldPTE2NzExOTM1JihuPDw4fG4+Pj4yNCl8NDI3ODI1NTM2MCYobjw8MjR8bj4+PjgpLHQuc2lnQnl0ZXM9NCooZS5sZW5ndGgrMSksdGhpcy5fcHJvY2VzcygpO2Zvcih2YXIgbz10aGlzLl9oYXNoLGk9by53b3JkcyxhPTA7YTw1O2ErKyl7dmFyIHM9aVthXTtpW2FdPTE2NzExOTM1JihzPDw4fHM+Pj4yNCl8NDI3ODI1NTM2MCYoczw8MjR8cz4+PjgpfXJldHVybiBvfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWwuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTtjLlJJUEVNRDE2MD1sLl9jcmVhdGVIZWxwZXIoYiksYy5IbWFjUklQRU1EMTYwPWwuX2NyZWF0ZUhtYWNIZWxwZXIoYil9KE1hdGgpLHQuUklQRU1EMTYwfSl9LHsiLi9jb3JlIjo1Mn1dLDc2OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LG49ZS5saWIscj1uLldvcmRBcnJheSxvPW4uSGFzaGVyLGk9W10sYT1lLmFsZ28uU0hBMT1vLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyByLmluaXQoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OCwzMjg1Mzc3NTIwXSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLl9oYXNoLndvcmRzLHI9blswXSxvPW5bMV0sYT1uWzJdLHM9blszXSxjPW5bNF0sdT0wO3U8ODA7dSsrKXtpZih1PDE2KWlbdV09MHx0W2UrdV07ZWxzZXt2YXIgZj1pW3UtM11eaVt1LThdXmlbdS0xNF1eaVt1LTE2XTtpW3VdPWY8PDF8Zj4+PjMxfXZhciBsPShyPDw1fHI+Pj4yNykrYytpW3VdO2wrPXU8MjA/MTUxODUwMDI0OSsobyZhfH5vJnMpOnU8NDA/MTg1OTc3NTM5Mysob15hXnMpOnU8NjA/KG8mYXxvJnN8YSZzKS0xODk0MDA3NTg4OihvXmFecyktODk5NDk3NTE0LGM9cyxzPWEsYT1vPDwzMHxvPj4+MixvPXIscj1sfW5bMF09blswXStyfDAsblsxXT1uWzFdK298MCxuWzJdPW5bMl0rYXwwLG5bM109blszXStzfDAsbls0XT1uWzRdK2N8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLGU9dC53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxyPTgqdC5zaWdCeXRlcztyZXR1cm4gZVtyPj4+NV18PTEyODw8MjQtciUzMixlWzE0KyhyKzY0Pj4+OTw8NCldPU1hdGguZmxvb3Iobi80Mjk0OTY3Mjk2KSxlWzE1KyhyKzY0Pj4+OTw8NCldPW4sdC5zaWdCeXRlcz00KmUubGVuZ3RoLHRoaXMuX3Byb2Nlc3MoKSx0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PW8uY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTtlLlNIQTE9by5fY3JlYXRlSGVscGVyKGEpLGUuSG1hY1NIQTE9by5fY3JlYXRlSG1hY0hlbHBlcihhKX0oKSx0LlNIQTF9KX0seyIuL2NvcmUiOjUyfV0sNzc6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vc2hhMjU2IikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9zaGEyNTYiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYi5Xb3JkQXJyYXkscj1lLmFsZ28sbz1yLlNIQTI1NixpPXIuU0hBMjI0PW8uZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IG4uaW5pdChbMzIzODM3MTAzMiw5MTQxNTA2NjMsODEyNzAyOTk5LDQxNDQ5MTI2OTcsNDI5MDc3NTg1NywxNzUwNjAzMDI1LDE2OTQwNzY4MzksMzIwNDA3NTQyOF0pfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PW8uX2RvRmluYWxpemUuY2FsbCh0aGlzKTtyZXR1cm4gdC5zaWdCeXRlcy09NCx0fX0pO2UuU0hBMjI0PW8uX2NyZWF0ZUhlbHBlcihpKSxlLkhtYWNTSEEyMjQ9by5fY3JlYXRlSG1hY0hlbHBlcihpKX0oKSx0LlNIQTIyNH0pfSx7Ii4vY29yZSI6NTIsIi4vc2hhMjU2Ijo3OH1dLDc4OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49dCxyPW4ubGliLG89ci5Xb3JkQXJyYXksaT1yLkhhc2hlcixhPW4uYWxnbyxzPVtdLGM9W107IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gNDI5NDk2NzI5NioodC0oMHx0KSl8MH1mb3IodmFyIG49MixyPTA7cjw2NDspKGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1lLnNxcnQodCkscj0yO3I8PW47cisrKWlmKCEodCVyKSlyZXR1cm4hMTtyZXR1cm4hMH0pKG4pJiYocjw4JiYoc1tyXT10KGUucG93KG4sLjUpKSksY1tyXT10KGUucG93KG4sMS8zKSkscisrKSxuKyt9KCk7dmFyIHU9W10sZj1hLlNIQTI1Nj1pLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBvLmluaXQocy5zbGljZSgwKSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLl9oYXNoLndvcmRzLHI9blswXSxvPW5bMV0saT1uWzJdLGE9blszXSxzPW5bNF0sZj1uWzVdLGw9bls2XSxwPW5bN10saD0wO2g8NjQ7aCsrKXtpZihoPDE2KXVbaF09MHx0W2UraF07ZWxzZXt2YXIgZD11W2gtMTVdLG09KGQ8PDI1fGQ+Pj43KV4oZDw8MTR8ZD4+PjE4KV5kPj4+Myx5PXVbaC0yXSxnPSh5PDwxNXx5Pj4+MTcpXih5PDwxM3x5Pj4+MTkpXnk+Pj4xMDt1W2hdPW0rdVtoLTddK2crdVtoLTE2XX12YXIgdj1yJm9eciZpXm8maSxiPShyPDwzMHxyPj4+MileKHI8PDE5fHI+Pj4xMyleKHI8PDEwfHI+Pj4yMiksXz1wKygoczw8MjZ8cz4+PjYpXihzPDwyMXxzPj4+MTEpXihzPDw3fHM+Pj4yNSkpKyhzJmZefnMmbCkrY1toXSt1W2hdO3A9bCxsPWYsZj1zLHM9YStffDAsYT1pLGk9byxvPXIscj1fKyhiK3YpfDB9blswXT1uWzBdK3J8MCxuWzFdPW5bMV0rb3wwLG5bMl09blsyXStpfDAsblszXT1uWzNdK2F8MCxuWzRdPW5bNF0rc3wwLG5bNV09bls1XStmfDAsbls2XT1uWzZdK2x8MCxuWzddPW5bN10rcHwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RhdGEsbj10LndvcmRzLHI9OCp0aGlzLl9uRGF0YUJ5dGVzLG89OCp0LnNpZ0J5dGVzO3JldHVybiBuW28+Pj41XXw9MTI4PDwyNC1vJTMyLG5bMTQrKG8rNjQ+Pj45PDw0KV09ZS5mbG9vcihyLzQyOTQ5NjcyOTYpLG5bMTUrKG8rNjQ+Pj45PDw0KV09cix0LnNpZ0J5dGVzPTQqbi5sZW5ndGgsdGhpcy5fcHJvY2VzcygpLHRoaXMuX2hhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9aS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0Ll9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSx0fX0pO24uU0hBMjU2PWkuX2NyZWF0ZUhlbHBlcihmKSxuLkhtYWNTSEEyNTY9aS5fY3JlYXRlSG1hY0hlbHBlcihmKX0oTWF0aCksdC5TSEEyNTZ9KX0seyIuL2NvcmUiOjUyfV0sNzk6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4veDY0LWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3g2NC1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49dCxyPW4ubGliLG89ci5Xb3JkQXJyYXksaT1yLkhhc2hlcixhPW4ueDY0LldvcmQscz1uLmFsZ28sYz1bXSx1PVtdLGY9W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTEsZT0wLG49MDtuPDI0O24rKyl7Y1t0KzUqZV09KG4rMSkqKG4rMikvMiU2NDt2YXIgcj0oMip0KzMqZSklNTt0PWUlNSxlPXJ9Zm9yKHQ9MDt0PDU7dCsrKWZvcihlPTA7ZTw1O2UrKyl1W3QrNSplXT1lKygyKnQrMyplKSU1KjU7Zm9yKHZhciBvPTEsaT0wO2k8MjQ7aSsrKXtmb3IodmFyIHM9MCxsPTAscD0wO3A8NztwKyspe2lmKDEmbyl7dmFyIGg9KDE8PHApLTE7aDwzMj9sXj0xPDxoOnNePTE8PGgtMzJ9MTI4Jm8/bz1vPDwxXjExMzpvPDw9MX1mW2ldPWEuY3JlYXRlKHMsbCl9fSgpO3ZhciBsPVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8MjU7dCsrKWxbdF09YS5jcmVhdGUoKX0oKTt2YXIgcD1zLlNIQTM9aS5leHRlbmQoe2NmZzppLmNmZy5leHRlbmQoe291dHB1dExlbmd0aDo1MTJ9KSxfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9zdGF0ZT1bXSxlPTA7ZTwyNTtlKyspdFtlXT1uZXcgYS5pbml0O3RoaXMuYmxvY2tTaXplPSgxNjAwLTIqdGhpcy5jZmcub3V0cHV0TGVuZ3RoKS8zMn0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuX3N0YXRlLHI9dGhpcy5ibG9ja1NpemUvMixvPTA7bzxyO28rKyl7dmFyIGk9dFtlKzIqb10sYT10W2UrMipvKzFdO2k9MTY3MTE5MzUmKGk8PDh8aT4+PjI0KXw0Mjc4MjU1MzYwJihpPDwyNHxpPj4+OCksYT0xNjcxMTkzNSYoYTw8OHxhPj4+MjQpfDQyNzgyNTUzNjAmKGE8PDI0fGE+Pj44KSwoRj1uW29dKS5oaWdoXj1hLEYubG93Xj1pfWZvcih2YXIgcz0wO3M8MjQ7cysrKXtmb3IoQz0wO0M8NTtDKyspe2Zvcih2YXIgcD0wLGg9MCxkPTA7ZDw1O2QrKylwXj0oRj1uW0MrNSpkXSkuaGlnaCxoXj1GLmxvdzt2YXIgbT1sW0NdO20uaGlnaD1wLG0ubG93PWh9Zm9yKEM9MDtDPDU7QysrKWZvcih2YXIgeT1sWyhDKzQpJTVdLGc9bFsoQysxKSU1XSx2PWcuaGlnaCxiPWcubG93LHA9eS5oaWdoXih2PDwxfGI+Pj4zMSksaD15Lmxvd14oYjw8MXx2Pj4+MzEpLGQ9MDtkPDU7ZCsrKShGPW5bQys1KmRdKS5oaWdoXj1wLEYubG93Xj1oO2Zvcih2YXIgXz0xO188MjU7XysrKXt2YXIgdz0oRj1uW19dKS5oaWdoLHg9Ri5sb3csaz1jW19dO2lmKGs8MzIpdmFyIHA9dzw8a3x4Pj4+MzItayxoPXg8PGt8dz4+PjMyLWs7ZWxzZSB2YXIgcD14PDxrLTMyfHc+Pj42NC1rLGg9dzw8ay0zMnx4Pj4+NjQtazt2YXIgQj1sW3VbX11dO0IuaGlnaD1wLEIubG93PWh9dmFyIFM9bFswXSxBPW5bMF07Uy5oaWdoPUEuaGlnaCxTLmxvdz1BLmxvdztmb3IodmFyIEM9MDtDPDU7QysrKWZvcihkPTA7ZDw1O2QrKyl7dmFyIEY9bltfPUMrNSpkXSxPPWxbX10sST1sWyhDKzEpJTUrNSpkXSxOPWxbKEMrMiklNSs1KmRdO0YuaGlnaD1PLmhpZ2hefkkuaGlnaCZOLmhpZ2gsRi5sb3c9Ty5sb3defkkubG93Jk4ubG93fXZhciBGPW5bMF0sVD1mW3NdO0YuaGlnaF49VC5oaWdoLEYubG93Xj1ULmxvd319LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxuPXQud29yZHMscj0odGhpcy5fbkRhdGFCeXRlcyw4KnQuc2lnQnl0ZXMpLGk9MzIqdGhpcy5ibG9ja1NpemU7bltyPj4+NV18PTE8PDI0LXIlMzIsblsoZS5jZWlsKChyKzEpL2kpKmk+Pj41KS0xXXw9MTI4LHQuc2lnQnl0ZXM9NCpuLmxlbmd0aCx0aGlzLl9wcm9jZXNzKCk7Zm9yKHZhciBhPXRoaXMuX3N0YXRlLHM9dGhpcy5jZmcub3V0cHV0TGVuZ3RoLzgsYz1zLzgsdT1bXSxmPTA7ZjxjO2YrKyl7dmFyIGw9YVtmXSxwPWwuaGlnaCxoPWwubG93O3A9MTY3MTE5MzUmKHA8PDh8cD4+PjI0KXw0Mjc4MjU1MzYwJihwPDwyNHxwPj4+OCksaD0xNjcxMTkzNSYoaDw8OHxoPj4+MjQpfDQyNzgyNTUzNjAmKGg8PDI0fGg+Pj44KSx1LnB1c2goaCksdS5wdXNoKHApfXJldHVybiBuZXcgby5pbml0KHUscyl9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWkuY2xvbmUuY2FsbCh0aGlzKSxlPXQuX3N0YXRlPXRoaXMuX3N0YXRlLnNsaWNlKDApLG49MDtuPDI1O24rKyllW25dPWVbbl0uY2xvbmUoKTtyZXR1cm4gdH19KTtuLlNIQTM9aS5fY3JlYXRlSGVscGVyKHApLG4uSG1hY1NIQTM9aS5fY3JlYXRlSG1hY0hlbHBlcihwKX0oTWF0aCksdC5TSEEzfSl9LHsiLi9jb3JlIjo1MiwiLi94NjQtY29yZSI6ODN9XSw4MDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi94NjQtY29yZSIpLHQoIi4vc2hhNTEyIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi94NjQtY29yZSIsIi4vc2hhNTEyIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LG49ZS54NjQscj1uLldvcmQsbz1uLldvcmRBcnJheSxpPWUuYWxnbyxhPWkuU0hBNTEyLHM9aS5TSEEzODQ9YS5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgby5pbml0KFtuZXcgci5pbml0KDM0MTgwNzAzNjUsMzIzODM3MTAzMiksbmV3IHIuaW5pdCgxNjU0MjcwMjUwLDkxNDE1MDY2MyksbmV3IHIuaW5pdCgyNDM4NTI5MzcwLDgxMjcwMjk5OSksbmV3IHIuaW5pdCgzNTU0NjIzNjAsNDE0NDkxMjY5NyksbmV3IHIuaW5pdCgxNzMxNDA1NDE1LDQyOTA3NzU4NTcpLG5ldyByLmluaXQoMjM5NDE4MDIzMSwxNzUwNjAzMDI1KSxuZXcgci5pbml0KDM2NzUwMDg1MjUsMTY5NDA3NjgzOSksbmV3IHIuaW5pdCgxMjAzMDYyODEzLDMyMDQwNzU0MjgpXSl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9YS5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO3JldHVybiB0LnNpZ0J5dGVzLT0xNix0fX0pO2UuU0hBMzg0PWEuX2NyZWF0ZUhlbHBlcihzKSxlLkhtYWNTSEEzODQ9YS5fY3JlYXRlSG1hY0hlbHBlcihzKX0oKSx0LlNIQTM4NH0pfSx7Ii4vY29yZSI6NTIsIi4vc2hhNTEyIjo4MSwiLi94NjQtY29yZSI6ODN9XSw4MTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi94NjQtY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4veDY0LWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gaS5jcmVhdGUuYXBwbHkoaSxhcmd1bWVudHMpfXZhciBuPXQscj1uLmxpYi5IYXNoZXIsbz1uLng2NCxpPW8uV29yZCxhPW8uV29yZEFycmF5LHM9bi5hbGdvLGM9W2UoMTExNjM1MjQwOCwzNjA5NzY3NDU4KSxlKDE4OTk0NDc0NDEsNjAyODkxNzI1KSxlKDMwNDkzMjM0NzEsMzk2NDQ4NDM5OSksZSgzOTIxMDA5NTczLDIxNzMyOTU1NDgpLGUoOTYxOTg3MTYzLDQwODE2Mjg0NzIpLGUoMTUwODk3MDk5MywzMDUzODM0MjY1KSxlKDI0NTM2MzU3NDgsMjkzNzY3MTU3OSksZSgyODcwNzYzMjIxLDM2NjQ2MDk1NjApLGUoMzYyNDM4MTA4MCwyNzM0ODgzMzk0KSxlKDMxMDU5ODQwMSwxMTY0OTk2NTQyKSxlKDYwNzIyNTI3OCwxMzIzNjEwNzY0KSxlKDE0MjY4ODE5ODcsMzU5MDMwNDk5NCksZSgxOTI1MDc4Mzg4LDQwNjgxODIzODMpLGUoMjE2MjA3ODIwNiw5OTEzMzYxMTMpLGUoMjYxNDg4ODEwMyw2MzM4MDMzMTcpLGUoMzI0ODIyMjU4MCwzNDc5Nzc0ODY4KSxlKDM4MzUzOTA0MDEsMjY2NjYxMzQ1OCksZSg0MDIyMjI0Nzc0LDk0NDcxMTEzOSksZSgyNjQzNDcwNzgsMjM0MTI2Mjc3MyksZSg2MDQ4MDc2MjgsMjAwNzgwMDkzMyksZSg3NzAyNTU5ODMsMTQ5NTk5MDkwMSksZSgxMjQ5MTUwMTIyLDE4NTY0MzEyMzUpLGUoMTU1NTA4MTY5MiwzMTc1MjE4MTMyKSxlKDE5OTYwNjQ5ODYsMjE5ODk1MDgzNyksZSgyNTU0MjIwODgyLDM5OTk3MTkzMzkpLGUoMjgyMTgzNDM0OSw3NjY3ODQwMTYpLGUoMjk1Mjk5NjgwOCwyNTY2NTk0ODc5KSxlKDMyMTAzMTM2NzEsMzIwMzMzNzk1NiksZSgzMzM2NTcxODkxLDEwMzQ0NTcwMjYpLGUoMzU4NDUyODcxMSwyNDY2OTQ4OTAxKSxlKDExMzkyNjk5MywzNzU4MzI2MzgzKSxlKDMzODI0MTg5NSwxNjg3MTc5MzYpLGUoNjY2MzA3MjA1LDExODgxNzk5NjQpLGUoNzczNTI5OTEyLDE1NDYwNDU3MzQpLGUoMTI5NDc1NzM3MiwxNTIyODA1NDg1KSxlKDEzOTYxODIyOTEsMjY0MzgzMzgyMyksZSgxNjk1MTgzNzAwLDIzNDM1MjczOTApLGUoMTk4NjY2MTA1MSwxMDE0NDc3NDgwKSxlKDIxNzcwMjYzNTAsMTIwNjc1OTE0MiksZSgyNDU2OTU2MDM3LDM0NDA3NzYyNyksZSgyNzMwNDg1OTIxLDEyOTA4NjM0NjApLGUoMjgyMDMwMjQxMSwzMTU4NDU0MjczKSxlKDMyNTk3MzA4MDAsMzUwNTk1MjY1NyksZSgzMzQ1NzY0NzcxLDEwNjIxNzAwOCksZSgzNTE2MDY1ODE3LDM2MDYwMDgzNDQpLGUoMzYwMDM1MjgwNCwxNDMyNzI1Nzc2KSxlKDQwOTQ1NzE5MDksMTQ2NzAzMTU5NCksZSgyNzU0MjMzNDQsODUxMTY5NzIwKSxlKDQzMDIyNzczNCwzMTAwODIzNzUyKSxlKDUwNjk0ODYxNiwxMzYzMjU4MTk1KSxlKDY1OTA2MDU1NiwzNzUwNjg1NTkzKSxlKDg4Mzk5Nzg3NywzNzg1MDUwMjgwKSxlKDk1ODEzOTU3MSwzMzE4MzA3NDI3KSxlKDEzMjI4MjIyMTgsMzgxMjcyMzQwMyksZSgxNTM3MDAyMDYzLDIwMDMwMzQ5OTUpLGUoMTc0Nzg3Mzc3OSwzNjAyMDM2ODk5KSxlKDE5NTU1NjIyMjIsMTU3NTk5MDAxMiksZSgyMDI0MTA0ODE1LDExMjU1OTI5MjgpLGUoMjIyNzczMDQ1MiwyNzE2OTA0MzA2KSxlKDIzNjE4NTI0MjQsNDQyNzc2MDQ0KSxlKDI0Mjg0MzY0NzQsNTkzNjk4MzQ0KSxlKDI3NTY3MzQxODcsMzczMzExMDI0OSksZSgzMjA0MDMxNDc5LDI5OTkzNTE1NzMpLGUoMzMyOTMyNTI5OCwzODE1OTIwNDI3KSxlKDMzOTE1Njk2MTQsMzkyODM4MzkwMCksZSgzNTE1MjY3MjcxLDU2NjI4MDcxMSksZSgzOTQwMTg3NjA2LDM0NTQwNjk1MzQpLGUoNDExODYzMDI3MSw0MDAwMjM5OTkyKSxlKDExNjQxODQ3NCwxOTE0MTM4NTU0KSxlKDE3NDI5MjQyMSwyNzMxMDU1MjcwKSxlKDI4OTM4MDM1NiwzMjAzOTkzMDA2KSxlKDQ2MDM5MzI2OSwzMjA2MjAzMTUpLGUoNjg1NDcxNzMzLDU4NzQ5NjgzNiksZSg4NTIxNDI5NzEsMTA4Njc5Mjg1MSksZSgxMDE3MDM2Mjk4LDM2NTU0MzEwMCksZSgxMTI2MDAwNTgwLDI2MTgyOTc2NzYpLGUoMTI4ODAzMzQ3MCwzNDA5ODU1MTU4KSxlKDE1MDE1MDU5NDgsNDIzNDUwOTg2NiksZSgxNjA3MTY3OTE1LDk4NzE2NzQ2OCksZSgxODE2NDAyMzE2LDEyNDYxODk1OTEpXSx1PVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8ODA7dCsrKXVbdF09ZSgpfSgpO3ZhciBmPXMuU0hBNTEyPXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IGEuaW5pdChbbmV3IGkuaW5pdCgxNzc5MDMzNzAzLDQwODkyMzU3MjApLG5ldyBpLmluaXQoMzE0NDEzNDI3NywyMjI3ODczNTk1KSxuZXcgaS5pbml0KDEwMTM5MDQyNDIsNDI3MTE3NTcyMyksbmV3IGkuaW5pdCgyNzczNDgwNzYyLDE1OTU3NTAxMjkpLG5ldyBpLmluaXQoMTM1OTg5MzExOSwyOTE3NTY1MTM3KSxuZXcgaS5pbml0KDI2MDA4MjI5MjQsNzI1NTExMTk5KSxuZXcgaS5pbml0KDUyODczNDYzNSw0MjE1Mzg5NTQ3KSxuZXcgaS5pbml0KDE1NDE0NTkyMjUsMzI3MDMzMjA5KV0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5faGFzaC53b3JkcyxyPW5bMF0sbz1uWzFdLGk9blsyXSxhPW5bM10scz1uWzRdLGY9bls1XSxsPW5bNl0scD1uWzddLGg9ci5oaWdoLGQ9ci5sb3csbT1vLmhpZ2gseT1vLmxvdyxnPWkuaGlnaCx2PWkubG93LGI9YS5oaWdoLF89YS5sb3csdz1zLmhpZ2gseD1zLmxvdyxrPWYuaGlnaCxCPWYubG93LFM9bC5oaWdoLEE9bC5sb3csQz1wLmhpZ2gsRj1wLmxvdyxPPWgsST1kLE49bSxUPXksUD1nLEQ9dixSPWIsRT1fLE09dyxIPXgsaj1rLHE9Qix6PVMsTD1BLFU9QyxXPUYsSj0wO0o8ODA7SisrKXt2YXIgSz11W0pdO2lmKEo8MTYpdmFyIEc9Sy5oaWdoPTB8dFtlKzIqSl0sWD1LLmxvdz0wfHRbZSsyKkorMV07ZWxzZXt2YXIgJD11W0otMTVdLFY9JC5oaWdoLFo9JC5sb3csWT0oVj4+PjF8Wjw8MzEpXihWPj4+OHxaPDwyNCleVj4+PjcsUT0oWj4+PjF8Vjw8MzEpXihaPj4+OHxWPDwyNCleKFo+Pj43fFY8PDI1KSx0dD11W0otMl0sZXQ9dHQuaGlnaCxudD10dC5sb3cscnQ9KGV0Pj4+MTl8bnQ8PDEzKV4oZXQ8PDN8bnQ+Pj4yOSleZXQ+Pj42LG90PShudD4+PjE5fGV0PDwxMyleKG50PDwzfGV0Pj4+MjkpXihudD4+PjZ8ZXQ8PDI2KSxpdD11W0otN10sYXQ9aXQuaGlnaCxzdD1pdC5sb3csY3Q9dVtKLTE2XSx1dD1jdC5oaWdoLGZ0PWN0LmxvdyxHPShHPShHPVkrYXQrKChYPVErc3QpPj4+MDxRPj4+MD8xOjApKStydCsoKFg9WCtvdCk+Pj4wPG90Pj4+MD8xOjApKSt1dCsoKFg9WCtmdCk+Pj4wPGZ0Pj4+MD8xOjApO0suaGlnaD1HLEsubG93PVh9dmFyIGx0PU0mal5+TSZ6LHB0PUgmcV5+SCZMLGh0PU8mTl5PJlBeTiZQLGR0PUkmVF5JJkReVCZELG10PShPPj4+Mjh8STw8NCleKE88PDMwfEk+Pj4yKV4oTzw8MjV8ST4+PjcpLHl0PShJPj4+Mjh8Tzw8NCleKEk8PDMwfE8+Pj4yKV4oSTw8MjV8Tz4+PjcpLGd0PShNPj4+MTR8SDw8MTgpXihNPj4+MTh8SDw8MTQpXihNPDwyM3xIPj4+OSksdnQ9KEg+Pj4xNHxNPDwxOCleKEg+Pj4xOHxNPDwxNCleKEg8PDIzfE0+Pj45KSxidD1jW0pdLF90PWJ0LmhpZ2gsd3Q9YnQubG93LHh0PVcrdnQsa3Q9KGt0PShrdD0oa3Q9VStndCsoeHQ+Pj4wPFc+Pj4wPzE6MCkpK2x0KygoeHQ9eHQrcHQpPj4+MDxwdD4+PjA/MTowKSkrX3QrKCh4dD14dCt3dCk+Pj4wPHd0Pj4+MD8xOjApKStHKygoeHQ9eHQrWCk+Pj4wPFg+Pj4wPzE6MCksQnQ9eXQrZHQsU3Q9bXQraHQrKEJ0Pj4+MDx5dD4+PjA/MTowKTtVPXosVz1MLHo9aixMPXEsaj1NLHE9SCxNPVIra3QrKChIPUUreHR8MCk+Pj4wPEU+Pj4wPzE6MCl8MCxSPVAsRT1ELFA9TixEPVQsTj1PLFQ9SSxPPWt0K1N0KygoST14dCtCdHwwKT4+PjA8eHQ+Pj4wPzE6MCl8MH1kPXIubG93PWQrSSxyLmhpZ2g9aCtPKyhkPj4+MDxJPj4+MD8xOjApLHk9by5sb3c9eStULG8uaGlnaD1tK04rKHk+Pj4wPFQ+Pj4wPzE6MCksdj1pLmxvdz12K0QsaS5oaWdoPWcrUCsodj4+PjA8RD4+PjA/MTowKSxfPWEubG93PV8rRSxhLmhpZ2g9YitSKyhfPj4+MDxFPj4+MD8xOjApLHg9cy5sb3c9eCtILHMuaGlnaD13K00rKHg+Pj4wPEg+Pj4wPzE6MCksQj1mLmxvdz1CK3EsZi5oaWdoPWsraisoQj4+PjA8cT4+PjA/MTowKSxBPWwubG93PUErTCxsLmhpZ2g9Uyt6KyhBPj4+MDxMPj4+MD8xOjApLEY9cC5sb3c9RitXLHAuaGlnaD1DK1UrKEY+Pj4wPFc+Pj4wPzE6MCl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxlPXQud29yZHMsbj04KnRoaXMuX25EYXRhQnl0ZXMscj04KnQuc2lnQnl0ZXM7cmV0dXJuIGVbcj4+PjVdfD0xMjg8PDI0LXIlMzIsZVszMCsocisxMjg+Pj4xMDw8NSldPU1hdGguZmxvb3Iobi80Mjk0OTY3Mjk2KSxlWzMxKyhyKzEyOD4+PjEwPDw1KV09bix0LnNpZ0J5dGVzPTQqZS5sZW5ndGgsdGhpcy5fcHJvY2VzcygpLHRoaXMuX2hhc2gudG9YMzIoKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1yLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9LGJsb2NrU2l6ZTozMn0pO24uU0hBNTEyPXIuX2NyZWF0ZUhlbHBlcihmKSxuLkhtYWNTSEE1MTI9ci5fY3JlYXRlSG1hY0hlbHBlcihmKX0oKSx0LlNIQTUxMn0pfSx7Ii4vY29yZSI6NTIsIi4veDY0LWNvcmUiOjgzfV0sODI6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vZW5jLWJhc2U2NCIpLHQoIi4vbWQ1IiksdCgiLi9ldnBrZGYiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxlKXt2YXIgbj0odGhpcy5fbEJsb2NrPj4+dF50aGlzLl9yQmxvY2spJmU7dGhpcy5fckJsb2NrXj1uLHRoaXMuX2xCbG9ja149bjw8dH1mdW5jdGlvbiBuKHQsZSl7dmFyIG49KHRoaXMuX3JCbG9jaz4+PnRedGhpcy5fbEJsb2NrKSZlO3RoaXMuX2xCbG9ja149bix0aGlzLl9yQmxvY2tePW48PHR9dmFyIHI9dCxvPXIubGliLGk9by5Xb3JkQXJyYXksYT1vLkJsb2NrQ2lwaGVyLHM9ci5hbGdvLGM9WzU3LDQ5LDQxLDMzLDI1LDE3LDksMSw1OCw1MCw0MiwzNCwyNiwxOCwxMCwyLDU5LDUxLDQzLDM1LDI3LDE5LDExLDMsNjAsNTIsNDQsMzYsNjMsNTUsNDcsMzksMzEsMjMsMTUsNyw2Miw1NCw0NiwzOCwzMCwyMiwxNCw2LDYxLDUzLDQ1LDM3LDI5LDIxLDEzLDUsMjgsMjAsMTIsNF0sdT1bMTQsMTcsMTEsMjQsMSw1LDMsMjgsMTUsNiwyMSwxMCwyMywxOSwxMiw0LDI2LDgsMTYsNywyNywyMCwxMywyLDQxLDUyLDMxLDM3LDQ3LDU1LDMwLDQwLDUxLDQ1LDMzLDQ4LDQ0LDQ5LDM5LDU2LDM0LDUzLDQ2LDQyLDUwLDM2LDI5LDMyXSxmPVsxLDIsNCw2LDgsMTAsMTIsMTQsMTUsMTcsMTksMjEsMjMsMjUsMjcsMjhdLGw9W3swOjg0MjE4ODgsMjY4NDM1NDU2OjMyNzY4LDUzNjg3MDkxMjo4NDIxMzc4LDgwNTMwNjM2ODoyLDEwNzM3NDE4MjQ6NTEyLDEzNDIxNzcyODA6ODQyMTg5MCwxNjEwNjEyNzM2OjgzODkxMjIsMTg3OTA0ODE5Mjo4Mzg4NjA4LDIxNDc0ODM2NDg6NTE0LDI0MTU5MTkxMDQ6ODM4OTEyMCwyNjg0MzU0NTYwOjMzMjgwLDI5NTI3OTAwMTY6ODQyMTM3NiwzMjIxMjI1NDcyOjMyNzcwLDM0ODk2NjA5Mjg6ODM4ODYxMCwzNzU4MDk2Mzg0OjAsNDAyNjUzMTg0MDozMzI4MiwxMzQyMTc3Mjg6MCw0MDI2NTMxODQ6ODQyMTg5MCw2NzEwODg2NDA6MzMyODIsOTM5NTI0MDk2OjMyNzY4LDEyMDc5NTk1NTI6ODQyMTg4OCwxNDc2Mzk1MDA4OjUxMiwxNzQ0ODMwNDY0Ojg0MjEzNzgsMjAxMzI2NTkyMDoyLDIyODE3MDEzNzY6ODM4OTEyMCwyNTUwMTM2ODMyOjMzMjgwLDI4MTg1NzIyODg6ODQyMTM3NiwzMDg3MDA3NzQ0OjgzODkxMjIsMzM1NTQ0MzIwMDo4Mzg4NjEwLDM2MjM4Nzg2NTY6MzI3NzAsMzg5MjMxNDExMjo1MTQsNDE2MDc0OTU2ODo4Mzg4NjA4LDE6MzI3NjgsMjY4NDM1NDU3OjIsNTM2ODcwOTEzOjg0MjE4ODgsODA1MzA2MzY5OjgzODg2MDgsMTA3Mzc0MTgyNTo4NDIxMzc4LDEzNDIxNzcyODE6MzMyODAsMTYxMDYxMjczNzo1MTIsMTg3OTA0ODE5Mzo4Mzg5MTIyLDIxNDc0ODM2NDk6ODQyMTg5MCwyNDE1OTE5MTA1Ojg0MjEzNzYsMjY4NDM1NDU2MTo4Mzg4NjEwLDI5NTI3OTAwMTc6MzMyODIsMzIyMTIyNTQ3Mzo1MTQsMzQ4OTY2MDkyOTo4Mzg5MTIwLDM3NTgwOTYzODU6MzI3NzAsNDAyNjUzMTg0MTowLDEzNDIxNzcyOTo4NDIxODkwLDQwMjY1MzE4NTo4NDIxMzc2LDY3MTA4ODY0MTo4Mzg4NjA4LDkzOTUyNDA5Nzo1MTIsMTIwNzk1OTU1MzozMjc2OCwxNDc2Mzk1MDA5OjgzODg2MTAsMTc0NDgzMDQ2NToyLDIwMTMyNjU5MjE6MzMyODIsMjI4MTcwMTM3NzozMjc3MCwyNTUwMTM2ODMzOjgzODkxMjIsMjgxODU3MjI4OTo1MTQsMzA4NzAwNzc0NTo4NDIxODg4LDMzNTU0NDMyMDE6ODM4OTEyMCwzNjIzODc4NjU3OjAsMzg5MjMxNDExMzozMzI4MCw0MTYwNzQ5NTY5Ojg0MjEzNzh9LHswOjEwNzQyODI1MTIsMTY3NzcyMTY6MTYzODQsMzM1NTQ0MzI6NTI0Mjg4LDUwMzMxNjQ4OjEwNzQyNjYxMjgsNjcxMDg4NjQ6MTA3Mzc0MTg0MCw4Mzg4NjA4MDoxMDc0MjgyNDk2LDEwMDY2MzI5NjoxMDczNzU4MjA4LDExNzQ0MDUxMjoxNiwxMzQyMTc3Mjg6NTQwNjcyLDE1MDk5NDk0NDoxMDczNzU4MjI0LDE2Nzc3MjE2MDoxMDczNzQxODI0LDE4NDU0OTM3Njo1NDA2ODgsMjAxMzI2NTkyOjUyNDMwNCwyMTgxMDM4MDg6MCwyMzQ4ODEwMjQ6MTY0MDAsMjUxNjU4MjQwOjEwNzQyNjYxMTIsODM4ODYwODoxMDczNzU4MjA4LDI1MTY1ODI0OjU0MDY4OCw0MTk0MzA0MDoxNiw1ODcyMDI1NjoxMDczNzU4MjI0LDc1NDk3NDcyOjEwNzQyODI1MTIsOTIyNzQ2ODg6MTA3Mzc0MTgyNCwxMDkwNTE5MDQ6NTI0Mjg4LDEyNTgyOTEyMDoxMDc0MjY2MTI4LDE0MjYwNjMzNjo1MjQzMDQsMTU5MzgzNTUyOjAsMTc2MTYwNzY4OjE2Mzg0LDE5MjkzNzk4NDoxMDc0MjY2MTEyLDIwOTcxNTIwMDoxMDczNzQxODQwLDIyNjQ5MjQxNjo1NDA2NzIsMjQzMjY5NjMyOjEwNzQyODI0OTYsMjYwMDQ2ODQ4OjE2NDAwLDI2ODQzNTQ1NjowLDI4NTIxMjY3MjoxMDc0MjY2MTI4LDMwMTk4OTg4ODoxMDczNzU4MjI0LDMxODc2NzEwNDoxMDc0MjgyNDk2LDMzNTU0NDMyMDoxMDc0MjY2MTEyLDM1MjMyMTUzNjoxNiwzNjkwOTg3NTI6NTQwNjg4LDM4NTg3NTk2ODoxNjM4NCw0MDI2NTMxODQ6MTY0MDAsNDE5NDMwNDAwOjUyNDI4OCw0MzYyMDc2MTY6NTI0MzA0LDQ1Mjk4NDgzMjoxMDczNzQxODQwLDQ2OTc2MjA0ODo1NDA2NzIsNDg2NTM5MjY0OjEwNzM3NTgyMDgsNTAzMzE2NDgwOjEwNzM3NDE4MjQsNTIwMDkzNjk2OjEwNzQyODI1MTIsMjc2ODI0MDY0OjU0MDY4OCwyOTM2MDEyODA6NTI0Mjg4LDMxMDM3ODQ5NjoxMDc0MjY2MTEyLDMyNzE1NTcxMjoxNjM4NCwzNDM5MzI5Mjg6MTA3Mzc1ODIwOCwzNjA3MTAxNDQ6MTA3NDI4MjUxMiwzNzc0ODczNjA6MTYsMzk0MjY0NTc2OjEwNzM3NDE4MjQsNDExMDQxNzkyOjEwNzQyODI0OTYsNDI3ODE5MDA4OjEwNzM3NDE4NDAsNDQ0NTk2MjI0OjEwNzM3NTgyMjQsNDYxMzczNDQwOjUyNDMwNCw0NzgxNTA2NTY6MCw0OTQ5Mjc4NzI6MTY0MDAsNTExNzA1MDg4OjEwNzQyNjYxMjgsNTI4NDgyMzA0OjU0MDY3Mn0sezA6MjYwLDEwNDg1NzY6MCwyMDk3MTUyOjY3MTA5MTIwLDMxNDU3Mjg6NjU3OTYsNDE5NDMwNDo2NTU0MCw1MjQyODgwOjY3MTA4ODY4LDYyOTE0NTY6NjcxNzQ2NjAsNzM0MDAzMjo2NzE3NDQwMCw4Mzg4NjA4OjY3MTA4ODY0LDk0MzcxODQ6NjcxNzQ2NTYsMTA0ODU3NjA6NjU3OTIsMTE1MzQzMzY6NjcxNzQ0MDQsMTI1ODI5MTI6NjcxMDkxMjQsMTM2MzE0ODg6NjU1MzYsMTQ2ODAwNjQ6NCwxNTcyODY0MDoyNTYsNTI0Mjg4OjY3MTc0NjU2LDE1NzI4NjQ6NjcxNzQ0MDQsMjYyMTQ0MDowLDM2NzAwMTY6NjcxMDkxMjAsNDcxODU5Mjo2NzEwODg2OCw1NzY3MTY4OjY1NTM2LDY4MTU3NDQ6NjU1NDAsNzg2NDMyMDoyNjAsODkxMjg5Njo0LDk5NjE0NzI6MjU2LDExMDEwMDQ4OjY3MTc0NDAwLDEyMDU4NjI0OjY1Nzk2LDEzMTA3MjAwOjY1NzkyLDE0MTU1Nzc2OjY3MTA5MTI0LDE1MjA0MzUyOjY3MTc0NjYwLDE2MjUyOTI4OjY3MTA4ODY0LDE2Nzc3MjE2OjY3MTc0NjU2LDE3ODI1NzkyOjY1NTQwLDE4ODc0MzY4OjY1NTM2LDE5OTIyOTQ0OjY3MTA5MTIwLDIwOTcxNTIwOjI1NiwyMjAyMDA5Njo2NzE3NDY2MCwyMzA2ODY3Mjo2NzEwODg2OCwyNDExNzI0ODowLDI1MTY1ODI0OjY3MTA5MTI0LDI2MjE0NDAwOjY3MTA4ODY0LDI3MjYyOTc2OjQsMjgzMTE1NTI6NjU3OTIsMjkzNjAxMjg6NjcxNzQ0MDAsMzA0MDg3MDQ6MjYwLDMxNDU3MjgwOjY1Nzk2LDMyNTA1ODU2OjY3MTc0NDA0LDE3MzAxNTA0OjY3MTA4ODY0LDE4MzUwMDgwOjI2MCwxOTM5ODY1Njo2NzE3NDY1NiwyMDQ0NzIzMjowLDIxNDk1ODA4OjY1NTQwLDIyNTQ0Mzg0OjY3MTA5MTIwLDIzNTkyOTYwOjI1NiwyNDY0MTUzNjo2NzE3NDQwNCwyNTY5MDExMjo2NTUzNiwyNjczODY4ODo2NzE3NDY2MCwyNzc4NzI2NDo2NTc5NiwyODgzNTg0MDo2NzEwODg2OCwyOTg4NDQxNjo2NzEwOTEyNCwzMDkzMjk5Mjo2NzE3NDQwMCwzMTk4MTU2ODo0LDMzMDMwMTQ0OjY1NzkyfSx7MDoyMTUxNjgyMDQ4LDY1NTM2OjIxNDc0ODc4MDgsMTMxMDcyOjQxOTg0NjQsMTk2NjA4OjIxNTE2Nzc5NTIsMjYyMTQ0OjAsMzI3NjgwOjQxOTg0MDAsMzkzMjE2OjIxNDc0ODM3MTIsNDU4NzUyOjQxOTQzNjgsNTI0Mjg4OjIxNDc0ODM2NDgsNTg5ODI0OjQxOTQzMDQsNjU1MzYwOjY0LDcyMDg5NjoyMTQ3NDg3NzQ0LDc4NjQzMjoyMTUxNjc4MDE2LDg1MTk2ODo0MTYwLDkxNzUwNDo0MDk2LDk4MzA0MDoyMTUxNjgyMTEyLDMyNzY4OjIxNDc0ODc4MDgsOTgzMDQ6NjQsMTYzODQwOjIxNTE2NzgwMTYsMjI5Mzc2OjIxNDc0ODc3NDQsMjk0OTEyOjQxOTg0MDAsMzYwNDQ4OjIxNTE2ODIxMTIsNDI1OTg0OjAsNDkxNTIwOjIxNTE2Nzc5NTIsNTU3MDU2OjQwOTYsNjIyNTkyOjIxNTE2ODIwNDgsNjg4MTI4OjQxOTQzMDQsNzUzNjY0OjQxNjAsODE5MjAwOjIxNDc0ODM2NDgsODg0NzM2OjQxOTQzNjgsOTUwMjcyOjQxOTg0NjQsMTAxNTgwODoyMTQ3NDgzNzEyLDEwNDg1NzY6NDE5NDM2OCwxMTE0MTEyOjQxOTg0MDAsMTE3OTY0ODoyMTQ3NDgzNzEyLDEyNDUxODQ6MCwxMzEwNzIwOjQxNjAsMTM3NjI1NjoyMTUxNjc4MDE2LDE0NDE3OTI6MjE1MTY4MjA0OCwxNTA3MzI4OjIxNDc0ODc4MDgsMTU3Mjg2NDoyMTUxNjgyMTEyLDE2Mzg0MDA6MjE0NzQ4MzY0OCwxNzAzOTM2OjIxNTE2Nzc5NTIsMTc2OTQ3Mjo0MTk4NDY0LDE4MzUwMDg6MjE0NzQ4Nzc0NCwxOTAwNTQ0OjQxOTQzMDQsMTk2NjA4MDo2NCwyMDMxNjE2OjQwOTYsMTA4MTM0NDoyMTUxNjc3OTUyLDExNDY4ODA6MjE1MTY4MjExMiwxMjEyNDE2OjAsMTI3Nzk1Mjo0MTk4NDAwLDEzNDM0ODg6NDE5NDM2OCwxNDA5MDI0OjIxNDc0ODM2NDgsMTQ3NDU2MDoyMTQ3NDg3ODA4LDE1NDAwOTY6NjQsMTYwNTYzMjoyMTQ3NDgzNzEyLDE2NzExNjg6NDA5NiwxNzM2NzA0OjIxNDc0ODc3NDQsMTgwMjI0MDoyMTUxNjc4MDE2LDE4Njc3NzY6NDE2MCwxOTMzMzEyOjIxNTE2ODIwNDgsMTk5ODg0ODo0MTk0MzA0LDIwNjQzODQ6NDE5ODQ2NH0sezA6MTI4LDQwOTY6MTcwMzkzNjAsODE5MjoyNjIxNDQsMTIyODg6NTM2ODcwOTEyLDE2Mzg0OjUzNzEzMzE4NCwyMDQ4MDoxNjc3NzM0NCwyNDU3Njo1NTM2NDgyNTYsMjg2NzI6MjYyMjcyLDMyNzY4OjE2Nzc3MjE2LDM2ODY0OjUzNzEzMzA1Niw0MDk2MDo1MzY4NzEwNDAsNDUwNTY6NTUzOTEwNDAwLDQ5MTUyOjU1MzkxMDI3Miw1MzI0ODowLDU3MzQ0OjE3MDM5NDg4LDYxNDQwOjU1MzY0ODEyOCwyMDQ4OjE3MDM5NDg4LDYxNDQ6NTUzNjQ4MjU2LDEwMjQwOjEyOCwxNDMzNjoxNzAzOTM2MCwxODQzMjoyNjIxNDQsMjI1Mjg6NTM3MTMzMTg0LDI2NjI0OjU1MzkxMDI3MiwzMDcyMDo1MzY4NzA5MTIsMzQ4MTY6NTM3MTMzMDU2LDM4OTEyOjAsNDMwMDg6NTUzOTEwNDAwLDQ3MTA0OjE2Nzc3MzQ0LDUxMjAwOjUzNjg3MTA0MCw1NTI5Njo1NTM2NDgxMjgsNTkzOTI6MTY3NzcyMTYsNjM0ODg6MjYyMjcyLDY1NTM2OjI2MjE0NCw2OTYzMjoxMjgsNzM3Mjg6NTM2ODcwOTEyLDc3ODI0OjU1MzY0ODI1Niw4MTkyMDoxNjc3NzM0NCw4NjAxNjo1NTM5MTAyNzIsOTAxMTI6NTM3MTMzMTg0LDk0MjA4OjE2Nzc3MjE2LDk4MzA0OjU1MzkxMDQwMCwxMDI0MDA6NTUzNjQ4MTI4LDEwNjQ5NjoxNzAzOTM2MCwxMTA1OTI6NTM3MTMzMDU2LDExNDY4ODoyNjIyNzIsMTE4Nzg0OjUzNjg3MTA0MCwxMjI4ODA6MCwxMjY5NzY6MTcwMzk0ODgsNjc1ODQ6NTUzNjQ4MjU2LDcxNjgwOjE2Nzc3MjE2LDc1Nzc2OjE3MDM5MzYwLDc5ODcyOjUzNzEzMzE4NCw4Mzk2ODo1MzY4NzA5MTIsODgwNjQ6MTcwMzk0ODgsOTIxNjA6MTI4LDk2MjU2OjU1MzkxMDI3MiwxMDAzNTI6MjYyMjcyLDEwNDQ0ODo1NTM5MTA0MDAsMTA4NTQ0OjAsMTEyNjQwOjU1MzY0ODEyOCwxMTY3MzY6MTY3NzczNDQsMTIwODMyOjI2MjE0NCwxMjQ5Mjg6NTM3MTMzMDU2LDEyOTAyNDo1MzY4NzEwNDB9LHswOjI2ODQzNTQ2NCwyNTY6ODE5Miw1MTI6MjcwNTMyNjA4LDc2ODoyNzA1NDA4MDgsMTAyNDoyNjg0NDM2NDgsMTI4MDoyMDk3MTUyLDE1MzY6MjA5NzE2MCwxNzkyOjI2ODQzNTQ1NiwyMDQ4OjAsMjMwNDoyNjg0NDM2NTYsMjU2MDoyMTA1MzQ0LDI4MTY6OCwzMDcyOjI3MDUzMjYxNiwzMzI4OjIxMDUzNTIsMzU4NDo4MjAwLDM4NDA6MjcwNTQwODAwLDEyODoyNzA1MzI2MDgsMzg0OjI3MDU0MDgwOCw2NDA6OCw4OTY6MjA5NzE1MiwxMTUyOjIxMDUzNTIsMTQwODoyNjg0MzU0NjQsMTY2NDoyNjg0NDM2NDgsMTkyMDo4MjAwLDIxNzY6MjA5NzE2MCwyNDMyOjgxOTIsMjY4ODoyNjg0NDM2NTYsMjk0NDoyNzA1MzI2MTYsMzIwMDowLDM0NTY6MjcwNTQwODAwLDM3MTI6MjEwNTM0NCwzOTY4OjI2ODQzNTQ1Niw0MDk2OjI2ODQ0MzY0OCw0MzUyOjI3MDUzMjYxNiw0NjA4OjI3MDU0MDgwOCw0ODY0OjgyMDAsNTEyMDoyMDk3MTUyLDUzNzY6MjY4NDM1NDU2LDU2MzI6MjY4NDM1NDY0LDU4ODg6MjEwNTM0NCw2MTQ0OjIxMDUzNTIsNjQwMDowLDY2NTY6OCw2OTEyOjI3MDUzMjYwOCw3MTY4OjgxOTIsNzQyNDoyNjg0NDM2NTYsNzY4MDoyNzA1NDA4MDAsNzkzNjoyMDk3MTYwLDQyMjQ6OCw0NDgwOjIxMDUzNDQsNDczNjoyMDk3MTUyLDQ5OTI6MjY4NDM1NDY0LDUyNDg6MjY4NDQzNjQ4LDU1MDQ6ODIwMCw1NzYwOjI3MDU0MDgwOCw2MDE2OjI3MDUzMjYwOCw2MjcyOjI3MDU0MDgwMCw2NTI4OjI3MDUzMjYxNiw2Nzg0OjgxOTIsNzA0MDoyMTA1MzUyLDcyOTY6MjA5NzE2MCw3NTUyOjAsNzgwODoyNjg0MzU0NTYsODA2NDoyNjg0NDM2NTZ9LHswOjEwNDg1NzYsMTY6MzM1NTU0NTcsMzI6MTAyNCw0ODoxMDQ5NjAxLDY0OjM0NjA0MDMzLDgwOjAsOTY6MSwxMTI6MzQ2MDMwMDksMTI4OjMzNTU1NDU2LDE0NDoxMDQ4NTc3LDE2MDozMzU1NDQzMywxNzY6MzQ2MDQwMzIsMTkyOjM0NjAzMDA4LDIwODoxMDI1LDIyNDoxMDQ5NjAwLDI0MDozMzU1NDQzMiw4OjM0NjAzMDA5LDI0OjAsNDA6MzM1NTU0NTcsNTY6MzQ2MDQwMzIsNzI6MTA0ODU3Niw4ODozMzU1NDQzMywxMDQ6MzM1NTQ0MzIsMTIwOjEwMjUsMTM2OjEwNDk2MDEsMTUyOjMzNTU1NDU2LDE2ODozNDYwMzAwOCwxODQ6MTA0ODU3NywyMDA6MTAyNCwyMTY6MzQ2MDQwMzMsMjMyOjEsMjQ4OjEwNDk2MDAsMjU2OjMzNTU0NDMyLDI3MjoxMDQ4NTc2LDI4ODozMzU1NTQ1NywzMDQ6MzQ2MDMwMDksMzIwOjEwNDg1NzcsMzM2OjMzNTU1NDU2LDM1MjozNDYwNDAzMiwzNjg6MTA0OTYwMSwzODQ6MTAyNSw0MDA6MzQ2MDQwMzMsNDE2OjEwNDk2MDAsNDMyOjEsNDQ4OjAsNDY0OjM0NjAzMDA4LDQ4MDozMzU1NDQzMyw0OTY6MTAyNCwyNjQ6MTA0OTYwMCwyODA6MzM1NTU0NTcsMjk2OjM0NjAzMDA5LDMxMjoxLDMyODozMzU1NDQzMiwzNDQ6MTA0ODU3NiwzNjA6MTAyNSwzNzY6MzQ2MDQwMzIsMzkyOjMzNTU0NDMzLDQwODozNDYwMzAwOCw0MjQ6MCw0NDA6MzQ2MDQwMzMsNDU2OjEwNDk2MDEsNDcyOjEwMjQsNDg4OjMzNTU1NDU2LDUwNDoxMDQ4NTc3fSx7MDoxMzQyMTk4MDgsMToxMzEwNzIsMjoxMzQyMTc3MjgsMzozMiw0OjEzMTEwNCw1OjEzNDM1MDg4MCw2OjEzNDM1MDg0OCw3OjIwNDgsODoxMzQzNDg4MDAsOToxMzQyMTk3NzYsMTA6MTMzMTIwLDExOjEzNDM0ODgzMiwxMjoyMDgwLDEzOjAsMTQ6MTM0MjE3NzYwLDE1OjEzMzE1MiwyMTQ3NDgzNjQ4OjIwNDgsMjE0NzQ4MzY0OToxMzQzNTA4ODAsMjE0NzQ4MzY1MDoxMzQyMTk4MDgsMjE0NzQ4MzY1MToxMzQyMTc3MjgsMjE0NzQ4MzY1MjoxMzQzNDg4MDAsMjE0NzQ4MzY1MzoxMzMxMjAsMjE0NzQ4MzY1NDoxMzMxNTIsMjE0NzQ4MzY1NTozMiwyMTQ3NDgzNjU2OjEzNDIxNzc2MCwyMTQ3NDgzNjU3OjIwODAsMjE0NzQ4MzY1ODoxMzExMDQsMjE0NzQ4MzY1OToxMzQzNTA4NDgsMjE0NzQ4MzY2MDowLDIxNDc0ODM2NjE6MTM0MzQ4ODMyLDIxNDc0ODM2NjI6MTM0MjE5Nzc2LDIxNDc0ODM2NjM6MTMxMDcyLDE2OjEzMzE1MiwxNzoxMzQzNTA4NDgsMTg6MzIsMTk6MjA0OCwyMDoxMzQyMTk3NzYsMjE6MTM0MjE3NzYwLDIyOjEzNDM0ODgzMiwyMzoxMzEwNzIsMjQ6MCwyNToxMzExMDQsMjY6MTM0MzQ4ODAwLDI3OjEzNDIxOTgwOCwyODoxMzQzNTA4ODAsMjk6MTMzMTIwLDMwOjIwODAsMzE6MTM0MjE3NzI4LDIxNDc0ODM2NjQ6MTMxMDcyLDIxNDc0ODM2NjU6MjA0OCwyMTQ3NDgzNjY2OjEzNDM0ODgzMiwyMTQ3NDgzNjY3OjEzMzE1MiwyMTQ3NDgzNjY4OjMyLDIxNDc0ODM2Njk6MTM0MzQ4ODAwLDIxNDc0ODM2NzA6MTM0MjE3NzI4LDIxNDc0ODM2NzE6MTM0MjE5ODA4LDIxNDc0ODM2NzI6MTM0MzUwODgwLDIxNDc0ODM2NzM6MTM0MjE3NzYwLDIxNDc0ODM2NzQ6MTM0MjE5Nzc2LDIxNDc0ODM2NzU6MCwyMTQ3NDgzNjc2OjEzMzEyMCwyMTQ3NDgzNjc3OjIwODAsMjE0NzQ4MzY3ODoxMzExMDQsMjE0NzQ4MzY3OToxMzQzNTA4NDh9XSxwPVs0MTYwNzQ5NTY5LDUyODQ4MjMwNCwzMzAzMDE0NCwyMDY0Mzg0LDEyOTAyNCw4MDY0LDUwNCwyMTQ3NDgzNjc5XSxoPXMuREVTPWEuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9rZXkud29yZHMsZT1bXSxuPTA7bjw1NjtuKyspe3ZhciByPWNbbl0tMTtlW25dPXRbcj4+PjVdPj4+MzEtciUzMiYxfWZvcih2YXIgbz10aGlzLl9zdWJLZXlzPVtdLGk9MDtpPDE2O2krKyl7Zm9yKHZhciBhPW9baV09W10scz1mW2ldLG49MDtuPDI0O24rKylhW24vNnwwXXw9ZVsodVtuXS0xK3MpJTI4XTw8MzEtbiU2LGFbNCsobi82fDApXXw9ZVsyOCsodVtuKzI0XS0xK3MpJTI4XTw8MzEtbiU2O2FbMF09YVswXTw8MXxhWzBdPj4+MzE7Zm9yKG49MTtuPDc7bisrKWFbbl09YVtuXT4+PjQqKG4tMSkrMzthWzddPWFbN108PDV8YVs3XT4+PjI3fWZvcih2YXIgbD10aGlzLl9pbnZTdWJLZXlzPVtdLG49MDtuPDE2O24rKylsW25dPW9bMTUtbl19LGVuY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5fc3ViS2V5cyl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5faW52U3ViS2V5cyl9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24odCxyLG8pe3RoaXMuX2xCbG9jaz10W3JdLHRoaXMuX3JCbG9jaz10W3IrMV0sZS5jYWxsKHRoaXMsNCwyNTI2NDUxMzUpLGUuY2FsbCh0aGlzLDE2LDY1NTM1KSxuLmNhbGwodGhpcywyLDg1ODk5MzQ1OSksbi5jYWxsKHRoaXMsOCwxNjcxMTkzNSksZS5jYWxsKHRoaXMsMSwxNDMxNjU1NzY1KTtmb3IodmFyIGk9MDtpPDE2O2krKyl7Zm9yKHZhciBhPW9baV0scz10aGlzLl9sQmxvY2ssYz10aGlzLl9yQmxvY2ssdT0wLGY9MDtmPDg7ZisrKXV8PWxbZl1bKChjXmFbZl0pJnBbZl0pPj4+MF07dGhpcy5fbEJsb2NrPWMsdGhpcy5fckJsb2NrPXNedX12YXIgaD10aGlzLl9sQmxvY2s7dGhpcy5fbEJsb2NrPXRoaXMuX3JCbG9jayx0aGlzLl9yQmxvY2s9aCxlLmNhbGwodGhpcywxLDE0MzE2NTU3NjUpLG4uY2FsbCh0aGlzLDgsMTY3MTE5MzUpLG4uY2FsbCh0aGlzLDIsODU4OTkzNDU5KSxlLmNhbGwodGhpcywxNiw2NTUzNSksZS5jYWxsKHRoaXMsNCwyNTI2NDUxMzUpLHRbcl09dGhpcy5fbEJsb2NrLHRbcisxXT10aGlzLl9yQmxvY2t9LGtleVNpemU6MixpdlNpemU6MixibG9ja1NpemU6Mn0pO3IuREVTPWEuX2NyZWF0ZUhlbHBlcihoKTt2YXIgZD1zLlRyaXBsZURFUz1hLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9rZXkud29yZHM7dGhpcy5fZGVzMT1oLmNyZWF0ZUVuY3J5cHRvcihpLmNyZWF0ZSh0LnNsaWNlKDAsMikpKSx0aGlzLl9kZXMyPWguY3JlYXRlRW5jcnlwdG9yKGkuY3JlYXRlKHQuc2xpY2UoMiw0KSkpLHRoaXMuX2RlczM9aC5jcmVhdGVFbmNyeXB0b3IoaS5jcmVhdGUodC5zbGljZSg0LDYpKSl9LGVuY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RlczEuZW5jcnlwdEJsb2NrKHQsZSksdGhpcy5fZGVzMi5kZWNyeXB0QmxvY2sodCxlKSx0aGlzLl9kZXMzLmVuY3J5cHRCbG9jayh0LGUpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayh0LGUpLHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKHQsZSksdGhpcy5fZGVzMS5kZWNyeXB0QmxvY2sodCxlKX0sa2V5U2l6ZTo2LGl2U2l6ZToyLGJsb2NrU2l6ZToyfSk7ci5UcmlwbGVERVM9YS5fY3JlYXRlSGVscGVyKGQpfSgpLHQuVHJpcGxlREVTfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTIsIi4vZW5jLWJhc2U2NCI6NTMsIi4vZXZwa2RmIjo1NSwiLi9tZDUiOjYwfV0sODM6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbj10LHI9bi5saWIsbz1yLkJhc2UsaT1yLldvcmRBcnJheSxhPW4ueDY0PXt9O2EuV29yZD1vLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3RoaXMuaGlnaD10LHRoaXMubG93PWV9fSksYS5Xb3JkQXJyYXk9by5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMud29yZHM9dHx8W10sdGhpcy5zaWdCeXRlcz12b2lkIDAhPWU/ZTo4KnQubGVuZ3RofSx0b1gzMjpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLndvcmRzLGU9dC5sZW5ndGgsbj1bXSxyPTA7cjxlO3IrKyl7dmFyIG89dFtyXTtuLnB1c2goby5oaWdoKSxuLnB1c2goby5sb3cpfXJldHVybiBpLmNyZWF0ZShuLHRoaXMuc2lnQnl0ZXMpfSxjbG9uZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1vLmNsb25lLmNhbGwodGhpcyksZT10LndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCksbj1lLmxlbmd0aCxyPTA7cjxuO3IrKyllW3JdPWVbcl0uY2xvbmUoKTtyZXR1cm4gdH19KX0oKSx0fSl9LHsiLi9jb3JlIjo1Mn1dLDg0OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIodCl7Zm9yKHZhciBlLG4scj1bXSxvPTAsaT10Lmxlbmd0aDtvPGk7KShlPXQuY2hhckNvZGVBdChvKyspKT49NTUyOTYmJmU8PTU2MzE5JiZvPGk/NTYzMjA9PSg2NDUxMiYobj10LmNoYXJDb2RlQXQobysrKSkpP3IucHVzaCgoKDEwMjMmZSk8PDEwKSsoMTAyMyZuKSs2NTUzNik6KHIucHVzaChlKSxvLS0pOnIucHVzaChlKTtyZXR1cm4gcn1mdW5jdGlvbiBvKHQpe2Zvcih2YXIgZSxuPXQubGVuZ3RoLHI9LTEsbz0iIjsrK3I8bjspKGU9dFtyXSk+NjU1MzUmJihvKz15KChlLT02NTUzNik+Pj4xMCYxMDIzfDU1Mjk2KSxlPTU2MzIwfDEwMjMmZSksbys9eShlKTtyZXR1cm4gb31mdW5jdGlvbiBpKHQpe2lmKHQ+PTU1Mjk2JiZ0PD01NzM0Myl0aHJvdyBFcnJvcigiTG9uZSBzdXJyb2dhdGUgVSsiK3QudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrIiBpcyBub3QgYSBzY2FsYXIgdmFsdWUiKX1mdW5jdGlvbiBhKHQsZSl7cmV0dXJuIHkodD4+ZSY2M3wxMjgpfWZ1bmN0aW9uIHModCl7aWYoMD09KDQyOTQ5NjcxNjgmdCkpcmV0dXJuIHkodCk7dmFyIGU9IiI7cmV0dXJuIDA9PSg0Mjk0OTY1MjQ4JnQpP2U9eSh0Pj42JjMxfDE5Mik6MD09KDQyOTQ5MDE3NjAmdCk/KGkodCksZT15KHQ+PjEyJjE1fDIyNCksZSs9YSh0LDYpKTowPT0oNDI5Mjg3MDE0NCZ0KSYmKGU9eSh0Pj4xOCY3fDI0MCksZSs9YSh0LDEyKSxlKz1hKHQsNikpLGUrPXkoNjMmdHwxMjgpfWZ1bmN0aW9uIGMoKXtpZihtPj1kKXRocm93IEVycm9yKCJJbnZhbGlkIGJ5dGUgaW5kZXgiKTt2YXIgdD0yNTUmaFttXTtpZihtKyssMTI4PT0oMTkyJnQpKXJldHVybiA2MyZ0O3Rocm93IEVycm9yKCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlIil9ZnVuY3Rpb24gdSgpe3ZhciB0LGUsbixyLG87aWYobT5kKXRocm93IEVycm9yKCJJbnZhbGlkIGJ5dGUgaW5kZXgiKTtpZihtPT1kKXJldHVybiExO2lmKHQ9MjU1JmhbbV0sbSsrLDA9PSgxMjgmdCkpcmV0dXJuIHQ7aWYoMTkyPT0oMjI0JnQpKXtpZihlPWMoKSwobz0oMzEmdCk8PDZ8ZSk+PTEyOClyZXR1cm4gbzt0aHJvdyBFcnJvcigiSW52YWxpZCBjb250aW51YXRpb24gYnl0ZSIpfWlmKDIyND09KDI0MCZ0KSl7aWYoZT1jKCksbj1jKCksKG89KDE1JnQpPDwxMnxlPDw2fG4pPj0yMDQ4KXJldHVybiBpKG8pLG87dGhyb3cgRXJyb3IoIkludmFsaWQgY29udGludWF0aW9uIGJ5dGUiKX1pZigyNDA9PSgyNDgmdCkmJihlPWMoKSxuPWMoKSxyPWMoKSwobz0oNyZ0KTw8MTh8ZTw8MTJ8bjw8NnxyKT49NjU1MzYmJm88PTExMTQxMTEpKXJldHVybiBvO3Rocm93IEVycm9yKCJJbnZhbGlkIFVURi04IGRldGVjdGVkIil9dmFyIGY9Im9iamVjdCI9PXR5cGVvZiBuJiZuLGw9Im9iamVjdCI9PXR5cGVvZiBlJiZlJiZlLmV4cG9ydHM9PWYmJmUscD0ib2JqZWN0Ij09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsO3AuZ2xvYmFsIT09cCYmcC53aW5kb3chPT1wfHwodD1wKTt2YXIgaCxkLG0seT1TdHJpbmcuZnJvbUNoYXJDb2RlLGc9e3ZlcnNpb246IjIuMS4yIixlbmNvZGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXIodCksbj1lLmxlbmd0aCxvPS0xLGk9IiI7KytvPG47KWkrPXMoZVtvXSk7cmV0dXJuIGl9LGRlY29kZTpmdW5jdGlvbih0KXtoPXIodCksZD1oLmxlbmd0aCxtPTA7Zm9yKHZhciBlLG49W107ITEhPT0oZT11KCkpOyluLnB1c2goZSk7cmV0dXJuIG8obil9fTtpZigiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiYib2JqZWN0Ij09dHlwZW9mIGRlZmluZS5hbWQmJmRlZmluZS5hbWQpZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTtlbHNlIGlmKGYmJiFmLm5vZGVUeXBlKWlmKGwpbC5leHBvcnRzPWc7ZWxzZXt2YXIgdj17fS5oYXNPd25Qcm9wZXJ0eTtmb3IodmFyIGIgaW4gZyl2LmNhbGwoZyxiKSYmKGZbYl09Z1tiXSl9ZWxzZSB0LnV0Zjg9Z30odGhpcyl9LHt9XSw4NTpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz1YTUxIdHRwUmVxdWVzdH0se31dLCJiaWdudW1iZXIuanMiOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBuKHQpe2Z1bmN0aW9uIGUodCxuKXt2YXIgcixvLGksYSxzLGMsdT10aGlzO2lmKCEodSBpbnN0YW5jZW9mIGUpKXJldHVybiBVJiZJKDI2LCJjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgbmV3Iix0KSxuZXcgZSh0LG4pO2lmKG51bGwhPW4mJlcobiwyLDY0LEQsImJhc2UiKSl7aWYobnw9MCxjPXQrIiIsMTA9PW4pcmV0dXJuIHU9bmV3IGUodCBpbnN0YW5jZW9mIGU/dDpjKSxOKHUsTSt1LmUrMSxIKTtpZigoYT0ibnVtYmVyIj09dHlwZW9mIHQpJiYwKnQhPTB8fCFuZXcgUmVnRXhwKCJeLT8iKyhyPSJbIitiLnNsaWNlKDAsbikrIl0rIikrIig/OlxcLiIrcisiKT8kIixuPDM3PyJpIjoiIikudGVzdChjKSlyZXR1cm4gUCh1LGMsYSxuKTthPyh1LnM9MS90PDA/KGM9Yy5zbGljZSgxKSwtMSk6MSxVJiZjLnJlcGxhY2UoL14wXC4wKnxcLi8sIiIpLmxlbmd0aD4xNSYmSShELHYsdCksYT0hMSk6dS5zPTQ1PT09Yy5jaGFyQ29kZUF0KDApPyhjPWMuc2xpY2UoMSksLTEpOjEsYz1wKGMsMTAsbix1LnMpfWVsc2V7aWYodCBpbnN0YW5jZW9mIGUpcmV0dXJuIHUucz10LnMsdS5lPXQuZSx1LmM9KHQ9dC5jKT90LnNsaWNlKCk6dCx2b2lkKEQ9MCk7aWYoKGE9Im51bWJlciI9PXR5cGVvZiB0KSYmMCp0PT0wKXtpZih1LnM9MS90PDA/KHQ9LXQsLTEpOjEsdD09PX5+dCl7Zm9yKG89MCxpPXQ7aT49MTA7aS89MTAsbysrKTtyZXR1cm4gdS5lPW8sdS5jPVt0XSx2b2lkKEQ9MCl9Yz10KyIifWVsc2V7aWYoIWgudGVzdChjPXQrIiIpKXJldHVybiBQKHUsYyxhKTt1LnM9NDU9PT1jLmNoYXJDb2RlQXQoMCk/KGM9Yy5zbGljZSgxKSwtMSk6MX19Zm9yKChvPWMuaW5kZXhPZigiLiIpKT4tMSYmKGM9Yy5yZXBsYWNlKCIuIiwiIikpLChpPWMuc2VhcmNoKC9lL2kpKT4wPyhvPDAmJihvPWkpLG8rPStjLnNsaWNlKGkrMSksYz1jLnN1YnN0cmluZygwLGkpKTpvPDAmJihvPWMubGVuZ3RoKSxpPTA7NDg9PT1jLmNoYXJDb2RlQXQoaSk7aSsrKTtmb3Iocz1jLmxlbmd0aDs0OD09PWMuY2hhckNvZGVBdCgtLXMpOyk7aWYoYz1jLnNsaWNlKGkscysxKSlpZihzPWMubGVuZ3RoLGEmJlUmJnM+MTUmJih0Pnh8fHQhPT1tKHQpKSYmSShELHYsdS5zKnQpLChvPW8taS0xKT5MKXUuYz11LmU9bnVsbDtlbHNlIGlmKG88eil1LmM9W3UuZT0wXTtlbHNle2lmKHUuZT1vLHUuYz1bXSxpPShvKzEpJXcsbzwwJiYoaSs9dyksaTxzKXtmb3IoaSYmdS5jLnB1c2goK2Muc2xpY2UoMCxpKSkscy09dztpPHM7KXUuYy5wdXNoKCtjLnNsaWNlKGksaSs9dykpO2M9Yy5zbGljZShpKSxpPXctYy5sZW5ndGh9ZWxzZSBpLT1zO2Zvcig7aS0tO2MrPSIwIik7dS5jLnB1c2goK2MpfWVsc2UgdS5jPVt1LmU9MF07RD0wfWZ1bmN0aW9uIHAodCxuLHIsaSl7dmFyIGEscyx1LGwscCxoLGQsbT10LmluZGV4T2YoIi4iKSx5PU0sZz1IO2ZvcihyPDM3JiYodD10LnRvTG93ZXJDYXNlKCkpLG0+PTAmJih1PUcsRz0wLHQ9dC5yZXBsYWNlKCIuIiwiIikscD0oZD1uZXcgZShyKSkucG93KHQubGVuZ3RoLW0pLEc9dSxkLmM9YyhmKG8ocC5jKSxwLmUpLDEwLG4pLGQuZT1kLmMubGVuZ3RoKSxzPXU9KGg9Yyh0LHIsbikpLmxlbmd0aDswPT1oWy0tdV07aC5wb3AoKSk7aWYoIWhbMF0pcmV0dXJuIjAiO2lmKG08MD8tLXM6KHAuYz1oLHAuZT1zLHAucz1pLGg9KHA9VChwLGQseSxnLG4pKS5jLGw9cC5yLHM9cC5lKSxhPXMreSsxLG09aFthXSx1PW4vMixsPWx8fGE8MHx8bnVsbCE9aFthKzFdLGw9Zzw0PyhudWxsIT1tfHxsKSYmKDA9PWd8fGc9PShwLnM8MD8zOjIpKTptPnV8fG09PXUmJig0PT1nfHxsfHw2PT1nJiYxJmhbYS0xXXx8Zz09KHAuczwwPzg6NykpLGE8MXx8IWhbMF0pdD1sP2YoIjEiLC15KToiMCI7ZWxzZXtpZihoLmxlbmd0aD1hLGwpZm9yKC0tbjsrK2hbLS1hXT5uOyloW2FdPTAsYXx8KCsrcyxoLnVuc2hpZnQoMSkpO2Zvcih1PWgubGVuZ3RoOyFoWy0tdV07KTtmb3IobT0wLHQ9IiI7bTw9dTt0Kz1iLmNoYXJBdChoW20rK10pKTt0PWYodCxzKX1yZXR1cm4gdH1mdW5jdGlvbiBBKHQsbixyLGkpe3ZhciBhLHMsYyxsLHA7aWYocj1udWxsIT1yJiZXKHIsMCw4LGksZyk/MHxyOkgsIXQuYylyZXR1cm4gdC50b1N0cmluZygpO2lmKGE9dC5jWzBdLGM9dC5lLG51bGw9PW4pcD1vKHQuYykscD0xOT09aXx8MjQ9PWkmJmM8PWo/dShwLGMpOmYocCxjKTtlbHNlIGlmKHQ9TihuZXcgZSh0KSxuLHIpLHM9dC5lLHA9byh0LmMpLGw9cC5sZW5ndGgsMTk9PWl8fDI0PT1pJiYobjw9c3x8czw9aikpe2Zvcig7bDxuO3ArPSIwIixsKyspO3A9dShwLHMpfWVsc2UgaWYobi09YyxwPWYocCxzKSxzKzE+bCl7aWYoLS1uPjApZm9yKHArPSIuIjtuLS07cCs9IjAiKTt9ZWxzZSBpZigobis9cy1sKT4wKWZvcihzKzE9PWwmJihwKz0iLiIpO24tLTtwKz0iMCIpO3JldHVybiB0LnM8MCYmYT8iLSIrcDpwfWZ1bmN0aW9uIEModCxuKXt2YXIgcixvLGk9MDtmb3Iocyh0WzBdKSYmKHQ9dFswXSkscj1uZXcgZSh0WzBdKTsrK2k8dC5sZW5ndGg7KXtpZighKG89bmV3IGUodFtpXSkpLnMpe3I9bzticmVha31uLmNhbGwocixvKSYmKHI9byl9cmV0dXJuIHJ9ZnVuY3Rpb24gRih0LGUsbixyLG8pe3JldHVybih0PGV8fHQ+bnx8dCE9bCh0KSkmJkkociwob3x8ImRlY2ltYWwgcGxhY2VzIikrKHQ8ZXx8dD5uPyIgb3V0IG9mIHJhbmdlIjoiIG5vdCBhbiBpbnRlZ2VyIiksdCksITB9ZnVuY3Rpb24gTyh0LGUsbil7Zm9yKHZhciByPTEsbz1lLmxlbmd0aDshZVstLW9dO2UucG9wKCkpO2ZvcihvPWVbMF07bz49MTA7by89MTAscisrKTtyZXR1cm4obj1yK24qdy0xKT5MP3QuYz10LmU9bnVsbDpuPHo/dC5jPVt0LmU9MF06KHQuZT1uLHQuYz1lKSx0fWZ1bmN0aW9uIEkodCxlLG4pe3ZhciByPW5ldyBFcnJvcihbIm5ldyBCaWdOdW1iZXIiLCJjbXAiLCJjb25maWciLCJkaXYiLCJkaXZUb0ludCIsImVxIiwiZ3QiLCJndGUiLCJsdCIsImx0ZSIsIm1pbnVzIiwibW9kIiwicGx1cyIsInByZWNpc2lvbiIsInJhbmRvbSIsInJvdW5kIiwic2hpZnQiLCJ0aW1lcyIsInRvRGlnaXRzIiwidG9FeHBvbmVudGlhbCIsInRvRml4ZWQiLCJ0b0Zvcm1hdCIsInRvRnJhY3Rpb24iLCJwb3ciLCJ0b1ByZWNpc2lvbiIsInRvU3RyaW5nIiwiQmlnTnVtYmVyIl1bdF0rIigpICIrZSsiOiAiK24pO3Rocm93IHIubmFtZT0iQmlnTnVtYmVyIEVycm9yIixEPTAscn1mdW5jdGlvbiBOKHQsZSxuLHIpe3ZhciBvLGksYSxzLGMsdSxmLGw9dC5jLHA9aztpZihsKXt0Ontmb3Iobz0xLHM9bFswXTtzPj0xMDtzLz0xMCxvKyspO2lmKChpPWUtbyk8MClpKz13LGE9ZSxmPShjPWxbdT0wXSkvcFtvLWEtMV0lMTB8MDtlbHNlIGlmKCh1PWQoKGkrMSkvdykpPj1sLmxlbmd0aCl7aWYoIXIpYnJlYWsgdDtmb3IoO2wubGVuZ3RoPD11O2wucHVzaCgwKSk7Yz1mPTAsbz0xLGE9KGklPXcpLXcrMX1lbHNle2ZvcihjPXM9bFt1XSxvPTE7cz49MTA7cy89MTAsbysrKTtmPShhPShpJT13KS13K28pPDA/MDpjL3Bbby1hLTFdJTEwfDB9aWYocj1yfHxlPDB8fG51bGwhPWxbdSsxXXx8KGE8MD9jOmMlcFtvLWEtMV0pLHI9bjw0PyhmfHxyKSYmKDA9PW58fG49PSh0LnM8MD8zOjIpKTpmPjV8fDU9PWYmJig0PT1ufHxyfHw2PT1uJiYoaT4wP2E+MD9jL3Bbby1hXTowOmxbdS0xXSklMTAmMXx8bj09KHQuczwwPzg6NykpLGU8MXx8IWxbMF0pcmV0dXJuIGwubGVuZ3RoPTAscj8oZS09dC5lKzEsbFswXT1wWyh3LWUldykld10sdC5lPS1lfHwwKTpsWzBdPXQuZT0wLHQ7aWYoMD09aT8obC5sZW5ndGg9dSxzPTEsdS0tKToobC5sZW5ndGg9dSsxLHM9cFt3LWldLGxbdV09YT4wP20oYy9wW28tYV0lcFthXSkqczowKSxyKWZvcig7Oyl7aWYoMD09dSl7Zm9yKGk9MSxhPWxbMF07YT49MTA7YS89MTAsaSsrKTtmb3IoYT1sWzBdKz1zLHM9MTthPj0xMDthLz0xMCxzKyspO2khPXMmJih0LmUrKyxsWzBdPT1fJiYobFswXT0xKSk7YnJlYWt9aWYobFt1XSs9cyxsW3VdIT1fKWJyZWFrO2xbdS0tXT0wLHM9MX1mb3IoaT1sLmxlbmd0aDswPT09bFstLWldO2wucG9wKCkpO310LmU+TD90LmM9dC5lPW51bGw6dC5lPHomJih0LmM9W3QuZT0wXSl9cmV0dXJuIHR9dmFyIFQsUCxEPTAsUj1lLnByb3RvdHlwZSxFPW5ldyBlKDEpLE09MjAsSD00LGo9LTcscT0yMSx6PS0xZTcsTD0xZTcsVT0hMCxXPUYsSj0hMSxLPTEsRz0wLFg9e2RlY2ltYWxTZXBhcmF0b3I6Ii4iLGdyb3VwU2VwYXJhdG9yOiIsIixncm91cFNpemU6MyxzZWNvbmRhcnlHcm91cFNpemU6MCxmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiLCoCIsZnJhY3Rpb25Hcm91cFNpemU6MH07cmV0dXJuIGUuYW5vdGhlcj1uLGUuUk9VTkRfVVA9MCxlLlJPVU5EX0RPV049MSxlLlJPVU5EX0NFSUw9MixlLlJPVU5EX0ZMT09SPTMsZS5ST1VORF9IQUxGX1VQPTQsZS5ST1VORF9IQUxGX0RPV049NSxlLlJPVU5EX0hBTEZfRVZFTj02LGUuUk9VTkRfSEFMRl9DRUlMPTcsZS5ST1VORF9IQUxGX0ZMT09SPTgsZS5FVUNMSUQ9OSxlLmNvbmZpZz1lLnNldD1mdW5jdGlvbigpe3ZhciB0LGUsbj0wLHI9e30sbz1hcmd1bWVudHMsaT1vWzBdLGM9aSYmIm9iamVjdCI9PXR5cGVvZiBpP2Z1bmN0aW9uKCl7aWYoaS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gbnVsbCE9KHQ9aVtlXSl9OmZ1bmN0aW9uKCl7aWYoby5sZW5ndGg+bilyZXR1cm4gbnVsbCE9KHQ9b1tuKytdKX07cmV0dXJuIGMoZT0iREVDSU1BTF9QTEFDRVMiKSYmVyh0LDAsUywyLGUpJiYoTT0wfHQpLHJbZV09TSxjKGU9IlJPVU5ESU5HX01PREUiKSYmVyh0LDAsOCwyLGUpJiYoSD0wfHQpLHJbZV09SCxjKGU9IkVYUE9ORU5USUFMX0FUIikmJihzKHQpP1codFswXSwtUywwLDIsZSkmJlcodFsxXSwwLFMsMixlKSYmKGo9MHx0WzBdLHE9MHx0WzFdKTpXKHQsLVMsUywyLGUpJiYoaj0tKHE9MHwodDwwPy10OnQpKSkpLHJbZV09W2oscV0sYyhlPSJSQU5HRSIpJiYocyh0KT9XKHRbMF0sLVMsLTEsMixlKSYmVyh0WzFdLDEsUywyLGUpJiYoej0wfHRbMF0sTD0wfHRbMV0pOlcodCwtUyxTLDIsZSkmJigwfHQ/ej0tKEw9MHwodDwwPy10OnQpKTpVJiZJKDIsZSsiIGNhbm5vdCBiZSB6ZXJvIix0KSkpLHJbZV09W3osTF0sYyhlPSJFUlJPUlMiKSYmKHQ9PT0hIXR8fDE9PT10fHwwPT09dD8oRD0wLFc9KFU9ISF0KT9GOmEpOlUmJkkoMixlK3ksdCkpLHJbZV09VSxjKGU9IkNSWVBUTyIpJiYoITA9PT10fHwhMT09PXR8fDE9PT10fHwwPT09dD90PyEodD0idW5kZWZpbmVkIj09dHlwZW9mIGNyeXB0bykmJmNyeXB0byYmKGNyeXB0by5nZXRSYW5kb21WYWx1ZXN8fGNyeXB0by5yYW5kb21CeXRlcyk/Sj0hMDpVP0koMiwiY3J5cHRvIHVuYXZhaWxhYmxlIix0P3ZvaWQgMDpjcnlwdG8pOko9ITE6Sj0hMTpVJiZJKDIsZSt5LHQpKSxyW2VdPUosYyhlPSJNT0RVTE9fTU9ERSIpJiZXKHQsMCw5LDIsZSkmJihLPTB8dCkscltlXT1LLGMoZT0iUE9XX1BSRUNJU0lPTiIpJiZXKHQsMCxTLDIsZSkmJihHPTB8dCkscltlXT1HLGMoZT0iRk9STUFUIikmJigib2JqZWN0Ij09dHlwZW9mIHQ/WD10OlUmJkkoMixlKyIgbm90IGFuIG9iamVjdCIsdCkpLHJbZV09WCxyfSxlLm1heD1mdW5jdGlvbigpe3JldHVybiBDKGFyZ3VtZW50cyxSLmx0KX0sZS5taW49ZnVuY3Rpb24oKXtyZXR1cm4gQyhhcmd1bWVudHMsUi5ndCl9LGUucmFuZG9tPWZ1bmN0aW9uKCl7dmFyIHQ9OTAwNzE5OTI1NDc0MDk5MipNYXRoLnJhbmRvbSgpJjIwOTcxNTE/ZnVuY3Rpb24oKXtyZXR1cm4gbSg5MDA3MTk5MjU0NzQwOTkyKk1hdGgucmFuZG9tKCkpfTpmdW5jdGlvbigpe3JldHVybiA4Mzg4NjA4KigxMDczNzQxODI0Kk1hdGgucmFuZG9tKCl8MCkrKDgzODg2MDgqTWF0aC5yYW5kb20oKXwwKX07cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByLG8saSxhLHMsYz0wLHU9W10sZj1uZXcgZShFKTtpZihuPW51bGwhPW4mJlcobiwwLFMsMTQpPzB8bjpNLGE9ZChuL3cpLEopaWYoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7Zm9yKHI9Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoYSo9MikpO2M8YTspKHM9MTMxMDcyKnJbY10rKHJbYysxXT4+PjExKSk+PTllMTU/KG89Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpLHJbY109b1swXSxyW2MrMV09b1sxXSk6KHUucHVzaChzJTFlMTQpLGMrPTIpO2M9YS8yfWVsc2UgaWYoY3J5cHRvLnJhbmRvbUJ5dGVzKXtmb3Iocj1jcnlwdG8ucmFuZG9tQnl0ZXMoYSo9Nyk7YzxhOykocz0yODE0NzQ5NzY3MTA2NTYqKDMxJnJbY10pKzEwOTk1MTE2Mjc3NzYqcltjKzFdKzQyOTQ5NjcyOTYqcltjKzJdKzE2Nzc3MjE2KnJbYyszXSsocltjKzRdPDwxNikrKHJbYys1XTw8OCkrcltjKzZdKT49OWUxNT9jcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShyLGMpOih1LnB1c2gocyUxZTE0KSxjKz03KTtjPWEvN31lbHNlIEo9ITEsVSYmSSgxNCwiY3J5cHRvIHVuYXZhaWxhYmxlIixjcnlwdG8pO2lmKCFKKWZvcig7YzxhOykocz10KCkpPDllMTUmJih1W2MrK109cyUxZTE0KTtmb3IoYT11Wy0tY10sbiU9dyxhJiZuJiYocz1rW3ctbl0sdVtjXT1tKGEvcykqcyk7MD09PXVbY107dS5wb3AoKSxjLS0pO2lmKGM8MCl1PVtpPTBdO2Vsc2V7Zm9yKGk9LTE7MD09PXVbMF07dS5zaGlmdCgpLGktPXcpO2ZvcihjPTEscz11WzBdO3M+PTEwO3MvPTEwLGMrKyk7Yzx3JiYoaS09dy1jKX1yZXR1cm4gZi5lPWksZi5jPXUsZn19KCksVD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3ZhciByLG8saSxhLHM9MCxjPXQubGVuZ3RoLHU9ZSVCLGY9ZS9CfDA7Zm9yKHQ9dC5zbGljZSgpO2MtLTspcz0oKG89dSooaT10W2NdJUIpKyhyPWYqaSsoYT10W2NdL0J8MCkqdSklQipCK3MpL258MCkrKHIvQnwwKStmKmEsdFtjXT1vJW47cmV0dXJuIHMmJnQudW5zaGlmdChzKSx0fWZ1bmN0aW9uIG4odCxlLG4scil7dmFyIG8saTtpZihuIT1yKWk9bj5yPzE6LTE7ZWxzZSBmb3Iobz1pPTA7bzxuO28rKylpZih0W29dIT1lW29dKXtpPXRbb10+ZVtvXT8xOi0xO2JyZWFrfXJldHVybiBpfWZ1bmN0aW9uIG8odCxlLG4scil7Zm9yKHZhciBvPTA7bi0tOyl0W25dLT1vLG89dFtuXTxlW25dPzE6MCx0W25dPW8qcit0W25dLWVbbl07Zm9yKDshdFswXSYmdC5sZW5ndGg+MTt0LnNoaWZ0KCkpO31yZXR1cm4gZnVuY3Rpb24oaSxhLHMsYyx1KXt2YXIgZixsLHAsaCxkLHksZyx2LGIseCxrLEIsUyxBLEMsRixPLEk9aS5zPT1hLnM/MTotMSxUPWkuYyxQPWEuYztpZighKFQmJlRbMF0mJlAmJlBbMF0pKXJldHVybiBuZXcgZShpLnMmJmEucyYmKFQ/IVB8fFRbMF0hPVBbMF06UCk/VCYmMD09VFswXXx8IVA/MCpJOkkvMDpOYU4pO2ZvcihiPSh2PW5ldyBlKEkpKS5jPVtdLEk9cysobD1pLmUtYS5lKSsxLHV8fCh1PV8sbD1yKGkuZS93KS1yKGEuZS93KSxJPUkvd3wwKSxwPTA7UFtwXT09KFRbcF18fDApO3ArKyk7aWYoUFtwXT4oVFtwXXx8MCkmJmwtLSxJPDApYi5wdXNoKDEpLGg9ITA7ZWxzZXtmb3IoQT1ULmxlbmd0aCxGPVAubGVuZ3RoLHA9MCxJKz0yLChkPW0odS8oUFswXSsxKSkpPjEmJihQPXQoUCxkLHUpLFQ9dChULGQsdSksRj1QLmxlbmd0aCxBPVQubGVuZ3RoKSxTPUYsaz0oeD1ULnNsaWNlKDAsRikpLmxlbmd0aDtrPEY7eFtrKytdPTApOyhPPVAuc2xpY2UoKSkudW5zaGlmdCgwKSxDPVBbMF0sUFsxXT49dS8yJiZDKys7ZG97aWYoZD0wLChmPW4oUCx4LEYsaykpPDApe2lmKEI9eFswXSxGIT1rJiYoQj1CKnUrKHhbMV18fDApKSwoZD1tKEIvQykpPjEpZm9yKGQ+PXUmJihkPXUtMSksZz0oeT10KFAsZCx1KSkubGVuZ3RoLGs9eC5sZW5ndGg7MT09bih5LHgsZyxrKTspZC0tLG8oeSxGPGc/TzpQLGcsdSksZz15Lmxlbmd0aCxmPTE7ZWxzZSAwPT1kJiYoZj1kPTEpLGc9KHk9UC5zbGljZSgpKS5sZW5ndGg7aWYoZzxrJiZ5LnVuc2hpZnQoMCksbyh4LHksayx1KSxrPXgubGVuZ3RoLC0xPT1mKWZvcig7bihQLHgsRixrKTwxOylkKyssbyh4LEY8az9POlAsayx1KSxrPXgubGVuZ3RofWVsc2UgMD09PWYmJihkKysseD1bMF0pO2JbcCsrXT1kLHhbMF0/eFtrKytdPVRbU118fDA6KHg9W1RbU11dLGs9MSl9d2hpbGUoKFMrKzxBfHxudWxsIT14WzBdKSYmSS0tKTtoPW51bGwhPXhbMF0sYlswXXx8Yi5zaGlmdCgpfWlmKHU9PV8pe2ZvcihwPTEsST1iWzBdO0k+PTEwO0kvPTEwLHArKyk7Tih2LHMrKHYuZT1wK2wqdy0xKSsxLGMsaCl9ZWxzZSB2LmU9bCx2LnI9K2g7cmV0dXJuIHZ9fSgpLFA9ZnVuY3Rpb24oKXt2YXIgdD0vXigtPykwKFt4Ym9dKSg/PVx3W1x3Ll0qJCkvaSxuPS9eKFteLl0rKVwuJC8scj0vXlwuKFteLl0rKSQvLG89L14tPyhJbmZpbml0eXxOYU4pJC8saT0vXlxzKlwrKD89W1x3Ll0pfF5ccyt8XHMrJC9nO3JldHVybiBmdW5jdGlvbihhLHMsYyx1KXt2YXIgZixsPWM/czpzLnJlcGxhY2UoaSwiIik7aWYoby50ZXN0KGwpKWEucz1pc05hTihsKT9udWxsOmw8MD8tMToxO2Vsc2V7aWYoIWMmJihsPWwucmVwbGFjZSh0LGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZj0ieCI9PShuPW4udG9Mb3dlckNhc2UoKSk/MTY6ImIiPT1uPzI6OCx1JiZ1IT1mP3Q6ZX0pLHUmJihmPXUsbD1sLnJlcGxhY2UobiwiJDEiKS5yZXBsYWNlKHIsIjAuJDEiKSkscyE9bCkpcmV0dXJuIG5ldyBlKGwsZik7VSYmSShELCJub3QgYSIrKHU/IiBiYXNlICIrdToiIikrIiBudW1iZXIiLHMpLGEucz1udWxsfWEuYz1hLmU9bnVsbCxEPTB9fSgpLFIuYWJzb2x1dGVWYWx1ZT1SLmFicz1mdW5jdGlvbigpe3ZhciB0PW5ldyBlKHRoaXMpO3JldHVybiB0LnM8MCYmKHQucz0xKSx0fSxSLmNlaWw9ZnVuY3Rpb24oKXtyZXR1cm4gTihuZXcgZSh0aGlzKSx0aGlzLmUrMSwyKX0sUi5jb21wYXJlZFRvPVIuY21wPWZ1bmN0aW9uKHQsbil7cmV0dXJuIEQ9MSxpKHRoaXMsbmV3IGUodCxuKSl9LFIuZGVjaW1hbFBsYWNlcz1SLmRwPWZ1bmN0aW9uKCl7dmFyIHQsZSxuPXRoaXMuYztpZighbilyZXR1cm4gbnVsbDtpZih0PSgoZT1uLmxlbmd0aC0xKS1yKHRoaXMuZS93KSkqdyxlPW5bZV0pZm9yKDtlJTEwPT0wO2UvPTEwLHQtLSk7cmV0dXJuIHQ8MCYmKHQ9MCksdH0sUi5kaXZpZGVkQnk9Ui5kaXY9ZnVuY3Rpb24odCxuKXtyZXR1cm4gRD0zLFQodGhpcyxuZXcgZSh0LG4pLE0sSCl9LFIuZGl2aWRlZFRvSW50ZWdlckJ5PVIuZGl2VG9JbnQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gRD00LFQodGhpcyxuZXcgZSh0LG4pLDAsMSl9LFIuZXF1YWxzPVIuZXE9ZnVuY3Rpb24odCxuKXtyZXR1cm4gRD01LDA9PT1pKHRoaXMsbmV3IGUodCxuKSl9LFIuZmxvb3I9ZnVuY3Rpb24oKXtyZXR1cm4gTihuZXcgZSh0aGlzKSx0aGlzLmUrMSwzKX0sUi5ncmVhdGVyVGhhbj1SLmd0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIEQ9NixpKHRoaXMsbmV3IGUodCxuKSk+MH0sUi5ncmVhdGVyVGhhbk9yRXF1YWxUbz1SLmd0ZT1mdW5jdGlvbih0LG4pe3JldHVybiBEPTcsMT09PShuPWkodGhpcyxuZXcgZSh0LG4pKSl8fDA9PT1ufSxSLmlzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmN9LFIuaXNJbnRlZ2VyPVIuaXNJbnQ9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmcih0aGlzLmUvdyk+dGhpcy5jLmxlbmd0aC0yfSxSLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc30sUi5pc05lZ2F0aXZlPVIuaXNOZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zPDB9LFIuaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmMmJjA9PXRoaXMuY1swXX0sUi5sZXNzVGhhbj1SLmx0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIEQ9OCxpKHRoaXMsbmV3IGUodCxuKSk8MH0sUi5sZXNzVGhhbk9yRXF1YWxUbz1SLmx0ZT1mdW5jdGlvbih0LG4pe3JldHVybiBEPTksLTE9PT0obj1pKHRoaXMsbmV3IGUodCxuKSkpfHwwPT09bn0sUi5taW51cz1SLnN1Yj1mdW5jdGlvbih0LG4pe3ZhciBvLGksYSxzLGM9dGhpcyx1PWMucztpZihEPTEwLHQ9bmV3IGUodCxuKSxuPXQucywhdXx8IW4pcmV0dXJuIG5ldyBlKE5hTik7aWYodSE9bilyZXR1cm4gdC5zPS1uLGMucGx1cyh0KTt2YXIgZj1jLmUvdyxsPXQuZS93LHA9Yy5jLGg9dC5jO2lmKCFmfHwhbCl7aWYoIXB8fCFoKXJldHVybiBwPyh0LnM9LW4sdCk6bmV3IGUoaD9jOk5hTik7aWYoIXBbMF18fCFoWzBdKXJldHVybiBoWzBdPyh0LnM9LW4sdCk6bmV3IGUocFswXT9jOjM9PUg/LTA6MCl9aWYoZj1yKGYpLGw9cihsKSxwPXAuc2xpY2UoKSx1PWYtbCl7Zm9yKChzPXU8MCk/KHU9LXUsYT1wKToobD1mLGE9aCksYS5yZXZlcnNlKCksbj11O24tLTthLnB1c2goMCkpO2EucmV2ZXJzZSgpfWVsc2UgZm9yKGk9KHM9KHU9cC5sZW5ndGgpPChuPWgubGVuZ3RoKSk/dTpuLHU9bj0wO248aTtuKyspaWYocFtuXSE9aFtuXSl7cz1wW25dPGhbbl07YnJlYWt9aWYocyYmKGE9cCxwPWgsaD1hLHQucz0tdC5zKSwobj0oaT1oLmxlbmd0aCktKG89cC5sZW5ndGgpKT4wKWZvcig7bi0tO3BbbysrXT0wKTtmb3Iobj1fLTE7aT51Oyl7aWYocFstLWldPGhbaV0pe2ZvcihvPWk7byYmIXBbLS1vXTtwW29dPW4pOy0tcFtvXSxwW2ldKz1ffXBbaV0tPWhbaV19Zm9yKDswPT1wWzBdO3Auc2hpZnQoKSwtLWwpO3JldHVybiBwWzBdP08odCxwLGwpOih0LnM9Mz09SD8tMToxLHQuYz1bdC5lPTBdLHQpfSxSLm1vZHVsbz1SLm1vZD1mdW5jdGlvbih0LG4pe3ZhciByLG8saT10aGlzO3JldHVybiBEPTExLHQ9bmV3IGUodCxuKSwhaS5jfHwhdC5zfHx0LmMmJiF0LmNbMF0/bmV3IGUoTmFOKTohdC5jfHxpLmMmJiFpLmNbMF0/bmV3IGUoaSk6KDk9PUs/KG89dC5zLHQucz0xLHI9VChpLHQsMCwzKSx0LnM9byxyLnMqPW8pOnI9VChpLHQsMCxLKSxpLm1pbnVzKHIudGltZXModCkpKX0sUi5uZWdhdGVkPVIubmVnPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGUodGhpcyk7cmV0dXJuIHQucz0tdC5zfHxudWxsLHR9LFIucGx1cz1SLmFkZD1mdW5jdGlvbih0LG4pe3ZhciBvLGk9dGhpcyxhPWkucztpZihEPTEyLHQ9bmV3IGUodCxuKSxuPXQucywhYXx8IW4pcmV0dXJuIG5ldyBlKE5hTik7aWYoYSE9bilyZXR1cm4gdC5zPS1uLGkubWludXModCk7dmFyIHM9aS5lL3csYz10LmUvdyx1PWkuYyxmPXQuYztpZighc3x8IWMpe2lmKCF1fHwhZilyZXR1cm4gbmV3IGUoYS8wKTtpZighdVswXXx8IWZbMF0pcmV0dXJuIGZbMF0/dDpuZXcgZSh1WzBdP2k6MCphKX1pZihzPXIocyksYz1yKGMpLHU9dS5zbGljZSgpLGE9cy1jKXtmb3IoYT4wPyhjPXMsbz1mKTooYT0tYSxvPXUpLG8ucmV2ZXJzZSgpO2EtLTtvLnB1c2goMCkpO28ucmV2ZXJzZSgpfWZvcigoYT11Lmxlbmd0aCktKG49Zi5sZW5ndGgpPDAmJihvPWYsZj11LHU9byxuPWEpLGE9MDtuOylhPSh1Wy0tbl09dVtuXStmW25dK2EpL198MCx1W25dPV89PT11W25dPzA6dVtuXSVfO3JldHVybiBhJiYodS51bnNoaWZ0KGEpLCsrYyksTyh0LHUsYyl9LFIucHJlY2lzaW9uPVIuc2Q9ZnVuY3Rpb24odCl7dmFyIGUsbixyPXRoaXMsbz1yLmM7aWYobnVsbCE9dCYmdCE9PSEhdCYmMSE9PXQmJjAhPT10JiYoVSYmSSgxMywiYXJndW1lbnQiK3ksdCksdCE9ISF0JiYodD1udWxsKSksIW8pcmV0dXJuIG51bGw7aWYobj1vLmxlbmd0aC0xLGU9bip3KzEsbj1vW25dKXtmb3IoO24lMTA9PTA7bi89MTAsZS0tKTtmb3Iobj1vWzBdO24+PTEwO24vPTEwLGUrKyk7fXJldHVybiB0JiZyLmUrMT5lJiYoZT1yLmUrMSksZX0sUi5yb3VuZD1mdW5jdGlvbih0LG4pe3ZhciByPW5ldyBlKHRoaXMpO3JldHVybihudWxsPT10fHxXKHQsMCxTLDE1KSkmJk4ocix+fnQrdGhpcy5lKzEsbnVsbCE9biYmVyhuLDAsOCwxNSxnKT8wfG46SCkscn0sUi5zaGlmdD1mdW5jdGlvbih0KXt2YXIgbj10aGlzO3JldHVybiBXKHQsLXgseCwxNiwiYXJndW1lbnQiKT9uLnRpbWVzKCIxZSIrbCh0KSk6bmV3IGUobi5jJiZuLmNbMF0mJih0PC14fHx0PngpP24ucyoodDwwPzA6MS8wKTpuKX0sUi5zcXVhcmVSb290PVIuc3FydD1mdW5jdGlvbigpe3ZhciB0LG4saSxhLHMsYz10aGlzLHU9Yy5jLGY9Yy5zLGw9Yy5lLHA9TSs0LGg9bmV3IGUoIjAuNSIpO2lmKDEhPT1mfHwhdXx8IXVbMF0pcmV0dXJuIG5ldyBlKCFmfHxmPDAmJighdXx8dVswXSk/TmFOOnU/YzoxLzApO2lmKDA9PShmPU1hdGguc3FydCgrYykpfHxmPT0xLzA/KCgobj1vKHUpKS5sZW5ndGgrbCklMj09MCYmKG4rPSIwIiksZj1NYXRoLnNxcnQobiksbD1yKChsKzEpLzIpLShsPDB8fGwlMiksaT1uZXcgZShuPWY9PTEvMD8iMWUiK2w6KG49Zi50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsbi5pbmRleE9mKCJlIikrMSkrbCkpOmk9bmV3IGUoZisiIiksaS5jWzBdKWZvcigoZj0obD1pLmUpK3ApPDMmJihmPTApOzspaWYocz1pLGk9aC50aW1lcyhzLnBsdXMoVChjLHMscCwxKSkpLG8ocy5jKS5zbGljZSgwLGYpPT09KG49byhpLmMpKS5zbGljZSgwLGYpKXtpZihpLmU8bCYmLS1mLCI5OTk5IiE9KG49bi5zbGljZShmLTMsZisxKSkmJihhfHwiNDk5OSIhPW4pKXsrbiYmKCtuLnNsaWNlKDEpfHwiNSIhPW4uY2hhckF0KDApKXx8KE4oaSxpLmUrTSsyLDEpLHQ9IWkudGltZXMoaSkuZXEoYykpO2JyZWFrfWlmKCFhJiYoTihzLHMuZStNKzIsMCkscy50aW1lcyhzKS5lcShjKSkpe2k9czticmVha31wKz00LGYrPTQsYT0xfXJldHVybiBOKGksaS5lK00rMSxILHQpfSxSLnRpbWVzPVIubXVsPWZ1bmN0aW9uKHQsbil7dmFyIG8saSxhLHMsYyx1LGYsbCxwLGgsZCxtLHksZyx2LGI9dGhpcyx4PWIuYyxrPShEPTE3LHQ9bmV3IGUodCxuKSkuYztpZighKHgmJmsmJnhbMF0mJmtbMF0pKXJldHVybiFiLnN8fCF0LnN8fHgmJiF4WzBdJiYha3x8ayYmIWtbMF0mJiF4P3QuYz10LmU9dC5zPW51bGw6KHQucyo9Yi5zLHgmJms/KHQuYz1bMF0sdC5lPTApOnQuYz10LmU9bnVsbCksdDtmb3IoaT1yKGIuZS93KStyKHQuZS93KSx0LnMqPWIucywoZj14Lmxlbmd0aCk8KGg9ay5sZW5ndGgpJiYoeT14LHg9ayxrPXksYT1mLGY9aCxoPWEpLGE9ZitoLHk9W107YS0tO3kucHVzaCgwKSk7Zm9yKGc9Xyx2PUIsYT1oOy0tYT49MDspe2ZvcihvPTAsZD1rW2FdJXYsbT1rW2FdL3Z8MCxzPWErKGM9Zik7cz5hOylvPSgobD1kKihsPXhbLS1jXSV2KSsodT1tKmwrKHA9eFtjXS92fDApKmQpJXYqdit5W3NdK28pL2d8MCkrKHUvdnwwKSttKnAseVtzLS1dPWwlZzt5W3NdPW99cmV0dXJuIG8/KytpOnkuc2hpZnQoKSxPKHQseSxpKX0sUi50b0RpZ2l0cz1mdW5jdGlvbih0LG4pe3ZhciByPW5ldyBlKHRoaXMpO3JldHVybiB0PW51bGwhPXQmJlcodCwxLFMsMTgsInByZWNpc2lvbiIpPzB8dDpudWxsLG49bnVsbCE9biYmVyhuLDAsOCwxOCxnKT8wfG46SCx0P04ocix0LG4pOnJ9LFIudG9FeHBvbmVudGlhbD1mdW5jdGlvbih0LGUpe3JldHVybiBBKHRoaXMsbnVsbCE9dCYmVyh0LDAsUywxOSk/MSt+fnQ6bnVsbCxlLDE5KX0sUi50b0ZpeGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEEodGhpcyxudWxsIT10JiZXKHQsMCxTLDIwKT9+fnQrdGhpcy5lKzE6bnVsbCxlLDIwKX0sUi50b0Zvcm1hdD1mdW5jdGlvbih0LGUpe3ZhciBuPUEodGhpcyxudWxsIT10JiZXKHQsMCxTLDIxKT9+fnQrdGhpcy5lKzE6bnVsbCxlLDIxKTtpZih0aGlzLmMpe3ZhciByLG89bi5zcGxpdCgiLiIpLGk9K1guZ3JvdXBTaXplLGE9K1guc2Vjb25kYXJ5R3JvdXBTaXplLHM9WC5ncm91cFNlcGFyYXRvcixjPW9bMF0sdT1vWzFdLGY9dGhpcy5zPDAsbD1mP2Muc2xpY2UoMSk6YyxwPWwubGVuZ3RoO2lmKGEmJihyPWksaT1hLGE9cixwLT1yKSxpPjAmJnA+MCl7Zm9yKHI9cCVpfHxpLGM9bC5zdWJzdHIoMCxyKTtyPHA7cis9aSljKz1zK2wuc3Vic3RyKHIsaSk7YT4wJiYoYys9cytsLnNsaWNlKHIpKSxmJiYoYz0iLSIrYyl9bj11P2MrWC5kZWNpbWFsU2VwYXJhdG9yKygoYT0rWC5mcmFjdGlvbkdyb3VwU2l6ZSk/dS5yZXBsYWNlKG5ldyBSZWdFeHAoIlxcZHsiK2ErIn1cXEIiLCJnIiksIiQmIitYLmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IpOnUpOmN9cmV0dXJuIG59LFIudG9GcmFjdGlvbj1mdW5jdGlvbih0KXt2YXIgbixyLGksYSxzLGMsdSxmLGwscD1VLGg9dGhpcyxkPWguYyxtPW5ldyBlKEUpLHk9cj1uZXcgZShFKSxnPXU9bmV3IGUoRSk7aWYobnVsbCE9dCYmKFU9ITEsYz1uZXcgZSh0KSxVPXAsKHA9Yy5pc0ludCgpKSYmIWMubHQoRSl8fChVJiZJKDIyLCJtYXggZGVub21pbmF0b3IgIisocD8ib3V0IG9mIHJhbmdlIjoibm90IGFuIGludGVnZXIiKSx0KSx0PSFwJiZjLmMmJk4oYyxjLmUrMSwxKS5ndGUoRSk/YzpudWxsKSksIWQpcmV0dXJuIGgudG9TdHJpbmcoKTtmb3IobD1vKGQpLGE9bS5lPWwubGVuZ3RoLWguZS0xLG0uY1swXT1rWyhzPWEldyk8MD93K3M6c10sdD0hdHx8Yy5jbXAobSk+MD9hPjA/bTp5OmMscz1MLEw9MS8wLGM9bmV3IGUobCksdS5jWzBdPTA7Zj1UKGMsbSwwLDEpLDEhPShpPXIucGx1cyhmLnRpbWVzKGcpKSkuY21wKHQpOylyPWcsZz1pLHk9dS5wbHVzKGYudGltZXMoaT15KSksdT1pLG09Yy5taW51cyhmLnRpbWVzKGk9bSkpLGM9aTtyZXR1cm4gaT1UKHQubWludXMociksZywwLDEpLHU9dS5wbHVzKGkudGltZXMoeSkpLHI9ci5wbHVzKGkudGltZXMoZykpLHUucz15LnM9aC5zLGEqPTIsbj1UKHksZyxhLEgpLm1pbnVzKGgpLmFicygpLmNtcChUKHUscixhLEgpLm1pbnVzKGgpLmFicygpKTwxP1t5LnRvU3RyaW5nKCksZy50b1N0cmluZygpXTpbdS50b1N0cmluZygpLHIudG9TdHJpbmcoKV0sTD1zLG59LFIudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4rdGhpc30sUi50b1Bvd2VyPVIucG93PWZ1bmN0aW9uKHQsbil7dmFyIHIsbyxpLGE9bSh0PDA/LXQ6K3QpLHM9dGhpcztpZihudWxsIT1uJiYoRD0yMyxuPW5ldyBlKG4pKSwhVyh0LC14LHgsMjMsImV4cG9uZW50IikmJighaXNGaW5pdGUodCl8fGE+eCYmKHQvPTApfHxwYXJzZUZsb2F0KHQpIT10JiYhKHQ9TmFOKSl8fDA9PXQpcmV0dXJuIHI9TWF0aC5wb3coK3MsdCksbmV3IGUobj9yJW46cik7Zm9yKG4/dD4xJiZzLmd0KEUpJiZzLmlzSW50KCkmJm4uZ3QoRSkmJm4uaXNJbnQoKT9zPXMubW9kKG4pOihpPW4sbj1udWxsKTpHJiYocj1kKEcvdysyKSksbz1uZXcgZShFKTs7KXtpZihhJTIpe2lmKCEobz1vLnRpbWVzKHMpKS5jKWJyZWFrO3I/by5jLmxlbmd0aD5yJiYoby5jLmxlbmd0aD1yKTpuJiYobz1vLm1vZChuKSl9aWYoIShhPW0oYS8yKSkpYnJlYWs7cz1zLnRpbWVzKHMpLHI/cy5jJiZzLmMubGVuZ3RoPnImJihzLmMubGVuZ3RoPXIpOm4mJihzPXMubW9kKG4pKX1yZXR1cm4gbj9vOih0PDAmJihvPUUuZGl2KG8pKSxpP28ubW9kKGkpOnI/TihvLEcsSCk6byl9LFIudG9QcmVjaXNpb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gQSh0aGlzLG51bGwhPXQmJlcodCwxLFMsMjQsInByZWNpc2lvbiIpPzB8dDpudWxsLGUsMjQpfSxSLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcyxyPW4ucyxpPW4uZTtyZXR1cm4gbnVsbD09PWk/cj8oZT0iSW5maW5pdHkiLHI8MCYmKGU9Ii0iK2UpKTplPSJOYU4iOihlPW8obi5jKSxlPW51bGwhPXQmJlcodCwyLDY0LDI1LCJiYXNlIik/cChmKGUsaSksMHx0LDEwLHIpOmk8PWp8fGk+PXE/dShlLGkpOmYoZSxpKSxyPDAmJm4uY1swXSYmKGU9Ii0iK2UpKSxlfSxSLnRydW5jYXRlZD1SLnRydW5jPWZ1bmN0aW9uKCl7cmV0dXJuIE4obmV3IGUodGhpcyksdGhpcy5lKzEsMSl9LFIudmFsdWVPZj1SLnRvSlNPTj1mdW5jdGlvbigpe3ZhciB0LGU9dGhpcyxuPWUuZTtyZXR1cm4gbnVsbD09PW4/ZS50b1N0cmluZygpOih0PW8oZS5jKSx0PW48PWp8fG4+PXE/dSh0LG4pOmYodCxuKSxlLnM8MD8iLSIrdDp0KX0sUi5pc0JpZ051bWJlcj0hMCxudWxsIT10JiZlLmNvbmZpZyh0KSxlfWZ1bmN0aW9uIHIodCl7dmFyIGU9MHx0O3JldHVybiB0PjB8fHQ9PT1lP2U6ZS0xfWZ1bmN0aW9uIG8odCl7Zm9yKHZhciBlLG4scj0xLG89dC5sZW5ndGgsaT10WzBdKyIiO3I8bzspe2ZvcihlPXRbcisrXSsiIixuPXctZS5sZW5ndGg7bi0tO2U9IjAiK2UpO2krPWV9Zm9yKG89aS5sZW5ndGg7NDg9PT1pLmNoYXJDb2RlQXQoLS1vKTspO3JldHVybiBpLnNsaWNlKDAsbysxfHwxKX1mdW5jdGlvbiBpKHQsZSl7dmFyIG4scixvPXQuYyxpPWUuYyxhPXQucyxzPWUucyxjPXQuZSx1PWUuZTtpZighYXx8IXMpcmV0dXJuIG51bGw7aWYobj1vJiYhb1swXSxyPWkmJiFpWzBdLG58fHIpcmV0dXJuIG4/cj8wOi1zOmE7aWYoYSE9cylyZXR1cm4gYTtpZihuPWE8MCxyPWM9PXUsIW98fCFpKXJldHVybiByPzA6IW9ebj8xOi0xO2lmKCFyKXJldHVybiBjPnVebj8xOi0xO2ZvcihzPShjPW8ubGVuZ3RoKTwodT1pLmxlbmd0aCk/Yzp1LGE9MDthPHM7YSsrKWlmKG9bYV0hPWlbYV0pcmV0dXJuIG9bYV0+aVthXV5uPzE6LTE7cmV0dXJuIGM9PXU/MDpjPnVebj8xOi0xfWZ1bmN0aW9uIGEodCxlLG4pe3JldHVybih0PWwodCkpPj1lJiZ0PD1ufWZ1bmN0aW9uIHModCl7cmV0dXJuIltvYmplY3QgQXJyYXldIj09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfWZ1bmN0aW9uIGModCxlLG4pe2Zvcih2YXIgcixvLGk9WzBdLGE9MCxzPXQubGVuZ3RoO2E8czspe2ZvcihvPWkubGVuZ3RoO28tLTtpW29dKj1lKTtmb3IoaVtyPTBdKz1iLmluZGV4T2YodC5jaGFyQXQoYSsrKSk7cjxpLmxlbmd0aDtyKyspaVtyXT5uLTEmJihudWxsPT1pW3IrMV0mJihpW3IrMV09MCksaVtyKzFdKz1pW3JdL258MCxpW3JdJT1uKX1yZXR1cm4gaS5yZXZlcnNlKCl9ZnVuY3Rpb24gdSh0LGUpe3JldHVybih0Lmxlbmd0aD4xP3QuY2hhckF0KDApKyIuIit0LnNsaWNlKDEpOnQpKyhlPDA/ImUiOiJlKyIpK2V9ZnVuY3Rpb24gZih0LGUpe3ZhciBuLHI7aWYoZTwwKXtmb3Iocj0iMC4iOysrZTtyKz0iMCIpO3Q9cit0fWVsc2UgaWYobj10Lmxlbmd0aCwrK2U+bil7Zm9yKHI9IjAiLGUtPW47LS1lO3IrPSIwIik7dCs9cn1lbHNlIGU8biYmKHQ9dC5zbGljZSgwLGUpKyIuIit0LnNsaWNlKGUpKTtyZXR1cm4gdH1mdW5jdGlvbiBsKHQpe3JldHVybih0PXBhcnNlRmxvYXQodCkpPDA/ZCh0KTptKHQpfXZhciBwLGg9L14tPyhcZCsoXC5cZCopP3xcLlxkKykoZVsrLV0/XGQrKT8kL2ksZD1NYXRoLmNlaWwsbT1NYXRoLmZsb29yLHk9IiBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdCIsZz0icm91bmRpbmcgbW9kZSIsdj0ibnVtYmVyIHR5cGUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHMiLGI9IjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8iLF89MWUxNCx3PTE0LHg9OTAwNzE5OTI1NDc0MDk5MSxrPVsxLDEwLDEwMCwxZTMsMWU0LDFlNSwxZTYsMWU3LDFlOCwxZTksMWUxMCwxZTExLDFlMTIsMWUxM10sQj0xZTcsUz0xZTk7KHA9bigpKS5kZWZhdWx0PXAuQmlnTnVtYmVyPXAsImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gcH0pOnZvaWQgMCE9PWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9cDoodHx8KHQ9InVuZGVmaW5lZCIhPXR5cGVvZiBzZWxmP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKSksdC5CaWdOdW1iZXI9cCl9KHRoaXMpfSx7fV0sd2ViMzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vbGliL3dlYjMiKTsidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdyYmdm9pZCAwPT09d2luZG93LldlYjMmJih3aW5kb3cuV2ViMz1yKSxlLmV4cG9ydHM9cn0seyIuL2xpYi93ZWIzIjoyMn1dfSx7fSxbIndlYjMiXSk7Cn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9LF9kZXJlcV8oImJ1ZmZlciIpLkJ1ZmZlcikKfSx7ImJ1ZmZlciI6MjB9XSwxNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrCi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGEKLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uCi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdAovLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS4KbW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkKZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHsKICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKQoKICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKQogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJykKCiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHsKICAgIHdyYXBwZXJba10gPSBmbltrXQogIH0pCgogIHJldHVybiB3cmFwcGVyCgogIGZ1bmN0aW9uIHdyYXBwZXIoKSB7CiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKQogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7CiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV0KICAgIH0KICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKQogICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXQogICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikgewogICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykgewogICAgICAgIHJldFtrXSA9IGNiW2tdCiAgICAgIH0pCiAgICB9CiAgICByZXR1cm4gcmV0CiAgfQp9Cgp9LHt9XSwxNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGV4dGVuZAoKdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsKCmZ1bmN0aW9uIGV4dGVuZCgpIHsKICAgIHZhciB0YXJnZXQgPSB7fQoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXQoKICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7CiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgewogICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIHJldHVybiB0YXJnZXQKfQoKfSx7fV19LHt9LFsxXSk7Cg==","base64").toString();
var inpageSuffix = '//# sourceURL=' + extension.extension.getURL('scripts/inpage.js') + '\n';
var inpageBundle = inpageContent + inpageSuffix;

// Eventually this streaming injection could be replaced with:
// https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.exportFunction
//
// But for now that is only Firefox
// If we create a FireFox-only code path using that API,
// MetaMask will be much faster loading and performant on Firefox.

if (shouldInjectWeb3()) {
  setupInjection();
  setupStreams();
}

function setupInjection() {
  try {
    // inject in-page script
    var scriptTag = document.createElement('script');
    scriptTag.textContent = inpageBundle;
    scriptTag.onload = function () {
      this.parentNode.removeChild(this);
    };
    var container = document.head || document.documentElement;
    // append as first child
    container.insertBefore(scriptTag, container.children[0]);
  } catch (e) {
    console.error('Metamask injection failed.', e);
  }
}

function setupStreams() {
  // setup communication to page and plugin
  var pageStream = new LocalMessageDuplexStream({
    name: 'contentscript',
    target: 'inpage'
  });
  var pluginPort = extension.runtime.connect({ name: 'contentscript' });
  var pluginStream = new PortStream(pluginPort);

  // forward communication plugin->inpage
  pump(pageStream, pluginStream, pageStream, function (err) {
    return logStreamDisconnectWarning('MetaMask Contentscript Forwarding', err);
  });

  // setup local multistream channels
  var mux = new ObjectMultiplex();
  mux.setMaxListeners(25);

  pump(mux, pageStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask Inpage', err);
  });
  pump(mux, pluginStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask Background', err);
  });

  // connect ping stream
  var pongStream = new PongStream({ objectMode: true });
  pump(mux, pongStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask PingPongStream', err);
  });

  // connect phishing warning stream
  var phishingStream = mux.createStream('phishing');
  phishingStream.once('data', redirectToPhishingWarning);

  // ignore unused channels (handled by background, inpage)
  mux.ignoreStream('provider');
  mux.ignoreStream('publicConfig');
}

function logStreamDisconnectWarning(remoteLabel, err) {
  var warningMsg = 'MetamaskContentscript - lost connection to ' + remoteLabel;
  if (err) warningMsg += '\n' + err.stack;
  console.warn(warningMsg);
}

function shouldInjectWeb3() {
  return doctypeCheck() || suffixCheck();
}

function doctypeCheck() {
  var doctype = window.document.doctype;
  if (doctype) {
    return doctype.name === 'html';
  } else {
    return false;
  }
}

function suffixCheck() {
  var prohibitedTypes = ['xml', 'pdf'];
  var currentUrl = window.location.href;
  var currentRegex;
  for (var i = 0; i < prohibitedTypes.length; i++) {
    currentRegex = new RegExp('\\.' + prohibitedTypes[i] + '$');
    if (currentRegex.test(currentUrl)) {
      return false;
    }
  }
  return true;
}

function redirectToPhishingWarning() {
  console.log('MetaMask - redirecting to phishing warning');
  window.location.href = 'https://metamask.io/phishing.html';
}

}).call(this,_dereq_("buffer").Buffer)
},{"./lib/port-stream.js":2,"buffer":6,"extensionizer":11,"obj-multiplex":16,"path":18,"ping-pong-stream/pong":19,"post-message-stream":20,"pump":22}],2:[function(_dereq_,module,exports){
(function (Buffer){
'use strict';

var Duplex = _dereq_('readable-stream').Duplex;
var inherits = _dereq_('util').inherits;
var noop = function noop() {};

module.exports = PortDuplexStream;

inherits(PortDuplexStream, Duplex);

function PortDuplexStream(port) {
  Duplex.call(this, {
    objectMode: true
  });
  this._port = port;
  port.onMessage.addListener(this._onMessage.bind(this));
  port.onDisconnect.addListener(this._onDisconnect.bind(this));
}

// private

PortDuplexStream.prototype._onMessage = function (msg) {
  if (Buffer.isBuffer(msg)) {
    delete msg._isBuffer;
    var data = new Buffer(msg);
    this.push(data);
  } else {
    this.push(msg);
  }
};

PortDuplexStream.prototype._onDisconnect = function () {
  this.destroy();
};

// stream plumbing

PortDuplexStream.prototype._read = noop;

PortDuplexStream.prototype._write = function (msg, encoding, cb) {
  try {
    if (Buffer.isBuffer(msg)) {
      var data = msg.toJSON();
      data._isBuffer = true;
      this._port.postMessage(data);
    } else {
      this._port.postMessage(msg);
    }
  } catch (err) {
    return cb(new Error('PortDuplexStream - disconnected'));
  }
  cb();
};

}).call(this,_dereq_("buffer").Buffer)
},{"buffer":6,"readable-stream":31,"util":37}],3:[function(_dereq_,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],4:[function(_dereq_,module,exports){

},{}],5:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],6:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":3,"ieee754":12}],7:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":_dereq_("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":14}],8:[function(_dereq_,module,exports){
var once = _dereq_('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

},{"once":17}],9:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],10:[function(_dereq_,module,exports){
const apis = [
  'alarms',
  'bookmarks',
  'browserAction',
  'commands',
  'contextMenus',
  'cookies',
  'downloads',
  'events',
  'extension',
  'extensionTypes',
  'history',
  'i18n',
  'idle',
  'notifications',
  'pageAction',
  'runtime',
  'storage',
  'tabs',
  'webNavigation',
  'webRequest',
  'windows',
]

function Extension () {
  const _this = this

  apis.forEach(function (api) {

    _this[api] = null

    try {
      if (chrome[api]) {
        _this[api] = chrome[api]
      }
    } catch (e) {}

    try {
      if (window[api]) {
        _this[api] = window[api]
      }
    } catch (e) {}

    try {
      if (browser[api]) {
        _this[api] = browser[api]
      }
    } catch (e) {}
    try {
      _this.api = browser.extension[api]
    } catch (e) {}
  })

  try {
    if (browser && browser.runtime) {
      this.runtime = browser.runtime
    }
  } catch (e) {}

  try {
    if (browser && browser.browserAction) {
      this.browserAction = browser.browserAction
    }
  } catch (e) {}

}

module.exports = Extension

},{}],11:[function(_dereq_,module,exports){
/* Extension.js
 *
 * A module for unifying browser differences in the WebExtension API.
 *
 * Initially implemented because Chrome hides all of their WebExtension API
 * behind a global `chrome` variable, but we'd like to start grooming
 * the code-base for cross-browser extension support.
 *
 * You can read more about the WebExtension API here:
 * https://developer.mozilla.org/en-US/Add-ons/WebExtensions
 */

const Extension = _dereq_('./extension-instance')
module.exports = new Extension()

},{"./extension-instance":10}],12:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],13:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],14:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],15:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],16:[function(_dereq_,module,exports){
const { Duplex } = _dereq_('readable-stream')
const endOfStream = _dereq_('end-of-stream')
const once = _dereq_('once')
const noop = () => {}

const IGNORE_SUBSTREAM = {}


class ObjectMultiplex extends Duplex {

  constructor(_opts = {}) {
    const opts = Object.assign({}, _opts, {
      objectMode: true,
    })
    super(opts)

    this._substreams = {}
  }

  createStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')

    // create substream
    const substream = new Substream({ parent: this, name: name })
    this._substreams[name] = substream

    // listen for parent stream to end
    anyStreamEnd(this, (err) => {
      substream.destroy(err)
    })

    return substream
  }

  // ignore streams (dont display orphaned data warning)
  ignoreStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')
    // set
    this._substreams[name] = IGNORE_SUBSTREAM
  }

  // stream plumbing

  _read () {}

  _write(chunk, encoding, callback) {
    // parse message
    const name = chunk.name
    const data = chunk.data
    if (!name) {
      console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`)
      return callback()
    }

    // get corresponding substream
    const substream = this._substreams[name]
    if (!substream) {
      console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`)
      return callback()
    }

    // push data into substream
    if (substream !== IGNORE_SUBSTREAM) {
      substream.push(data)
    }

    callback()
  }

}


class Substream extends Duplex {

  constructor ({ parent, name }) {
    super({
      objectMode: true,
    })

    this._parent = parent
    this._name = name
  }

  _read () {}

  _write (chunk, enc, callback) {
    this._parent.push({
      name: this._name,
      data: chunk,
    })
    callback()
  }

}

module.exports = ObjectMultiplex

// util

function anyStreamEnd(stream, _cb) {
  const cb = once(_cb)
  endOfStream(stream, { readable: false }, cb)
  endOfStream(stream, { writable: false }, cb)
}
},{"end-of-stream":8,"once":17,"readable-stream":31}],17:[function(_dereq_,module,exports){
var wrappy = _dereq_('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":38}],18:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,_dereq_('_process'))
},{"_process":5}],19:[function(_dereq_,module,exports){
const Duplex = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PongStream

inherits(PongStream, Duplex)

function PongStream (opts) {
  const self = this
  opts = opts || {}
  Duplex.call(this, opts)
  self._heartbeatRequest = opts.heartbeatRequest || 'ping'
  self._heartbeatResponse = opts.heartbeatResponse || 'pong'
}

// private

PongStream.prototype._sendResponse = function (msg) {
  const self = this
  self.push(self._heartbeatResponse)
}

// stream plumbing

PongStream.prototype._read = noop

PongStream.prototype._write = function (msg, encoding, cb) {
  const self = this
  if (msg.toString() === self._heartbeatRequest.toString()) {
    // heartbeat heard
    self._sendResponse()
    cb()
  } else {
    // unknown message
    cb(new Error('PongStream - unknown request'))
  }
  
}

// util

function noop() {}
},{"readable-stream":31,"util":37}],20:[function(_dereq_,module,exports){
const DuplexStream = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PostMessageStream

inherits(PostMessageStream, DuplexStream)

function PostMessageStream (opts) {
  DuplexStream.call(this, {
    objectMode: true,
  })

  this._name = opts.name
  this._target = opts.target
  this._targetWindow = opts.targetWindow || window
  this._origin = (opts.targetWindow ? '*' : location.origin)

  // initialization flags
  this._init = false
  this._haveSyn = false

  window.addEventListener('message', this._onMessage.bind(this), false)
  // send syncorization message
  this._write('SYN', null, noop)
  this.cork()
}

// private
PostMessageStream.prototype._onMessage = function (event) {
  var msg = event.data

  // validate message
  if (this._origin !== '*' && event.origin !== this._origin) return
  if (event.source !== this._targetWindow) return
  if (typeof msg !== 'object') return
  if (msg.target !== this._name) return
  if (!msg.data) return

  if (!this._init) {
    if (msg.data === 'SYN') {
      this._haveSyn = true
      this._write('ACK', null, noop)
    } else if (msg.data === 'ACK') {
      this._init = true
      if (!this._haveSyn) {
        this._write('ACK', null, noop)
      }
      this.uncork()
    }
  } else {
    // forward message
    try {
      this.push(msg.data)
    } catch (err) {
      this.emit('error', err)
    }
  }
}

// stream plumbing
PostMessageStream.prototype._read = noop

PostMessageStream.prototype._write = function (data, encoding, cb) {
  var message = {
    target: this._target,
    data: data,
  }
  this._targetWindow.postMessage(message, this._origin)
  cb()
}

// util

function noop () {}

},{"readable-stream":31,"util":37}],21:[function(_dereq_,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,_dereq_('_process'))
},{"_process":5}],22:[function(_dereq_,module,exports){
var once = _dereq_('once')
var eos = _dereq_('end-of-stream')
var fs = _dereq_('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close() // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

},{"end-of-stream":8,"fs":4,"once":17}],23:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":25,"./_stream_writable":27,"core-util-is":7,"inherits":13,"process-nextick-args":21}],24:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":26,"core-util-is":7,"inherits":13}],25:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = _dereq_('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = _dereq_('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = _dereq_('./internal/streams/BufferList');
var destroyImpl = _dereq_('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":23,"./internal/streams/BufferList":28,"./internal/streams/destroy":29,"./internal/streams/stream":30,"_process":5,"core-util-is":7,"events":9,"inherits":13,"isarray":15,"process-nextick-args":21,"safe-buffer":32,"string_decoder/":33,"util":4}],26:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":23,"core-util-is":7,"inherits":13}],27:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: _dereq_('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = _dereq_('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":23,"./internal/streams/destroy":29,"./internal/streams/stream":30,"_process":5,"core-util-is":7,"inherits":13,"process-nextick-args":21,"safe-buffer":32,"util-deprecate":34}],28:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = _dereq_('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":32}],29:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":21}],30:[function(_dereq_,module,exports){
module.exports = _dereq_('events').EventEmitter;

},{"events":9}],31:[function(_dereq_,module,exports){
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":23,"./lib/_stream_passthrough.js":24,"./lib/_stream_readable.js":25,"./lib/_stream_transform.js":26,"./lib/_stream_writable.js":27}],32:[function(_dereq_,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = _dereq_('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":6}],33:[function(_dereq_,module,exports){
'use strict';

var Buffer = _dereq_('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":32}],34:[function(_dereq_,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],35:[function(_dereq_,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],36:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],37:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":36,"_process":5,"inherits":35}],38:[function(_dereq_,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}]},{},[1]);
